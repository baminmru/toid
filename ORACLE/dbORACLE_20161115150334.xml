<?xml version="1.0"?>
<root>
  <ModuleHolder ModuleName="--PreInstall" File="">
    <BlockHolder BlockName="--body" BlockCode="


/*NEWID (NEWID)*/
create or replace function NEWID return varchar2 as
  Result varchar2(38);
  lguid raw(128);
  sTempString varchar2(38);
begin
  select sys_guid() into lguid from dual;
  sTempString:=to_char(lguid);
  Result:='{' || 
              Substr(sTempString, 1, 8) 
              || '-' ||
              Substr(sTempString, 9, 4) 
              || '-' ||
              Substr(sTempString, 13, 4) 
              || '-' ||
              Substr(sTempString, 17, 4) 
              || '-' ||
              Substr(sTempString, 21, 12) 
              || '}';
  return(Result);
end NEWID;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Tables" File="">
    <BlockHolder BlockName="--kernel" BlockCode=" 

-- Kernel Tables --
drop table MTO.sysoptions
/
create table MTO.sysoptions(
sysoptionsID CHAR(38) primary key,
Name varchar2(255) null,
TheValue varchar2(255) null,
OptionType VarChar2(255) null
)
/
drop table MTO.typelist
/
create  table MTO.typelist(
typelistID CHAR(38) primary key  ,
Name varchar2(255) not null,
SecurityStyleID CHAR(38) null, 
RegisterProc varchar2(255) null,
DeleteProc varchar2(255) null,
HCLProc varchar2(255) null ,
PropagateProc varchar2(255) null 
)
/
drop table MTO.Instance
/
create table MTO.Instance(
InstanceID CHAR(38) not null primary key,
LockUserID CHAR(38) null, 
LockSessionID CHAR(38) null, 
SecurityStyleID CHAR(38) null, 
Name varchar2(255) null,
ObjType varchar2(255) null
)
/
alter table instance add OwnerPartName varchar2(255) null
/
alter table instance add OwnerRowID CHAR(38) null
/
alter  table instance add status CHAR(38) null
/
alter  table instance add archived NUMBER null
/
drop table MTO.QueryResult
/
CREATE TABLE MTO.QueryResult (
  QueryResultid CHAR(38) NOT NULL ,
  result CHAR(38) NULL 
)
/
drop table MTO.RPRESULT
/
CREATE TABLE MTO.RPRESULT (
  RPRESULTID CHAR(38) NOT NULL ,
  PARENTLEVEL NUMBER NOT NULL ,
  PARTNAME varchar2 (255) NULL ,
  THEROWID CHAR(38) NULL 
)
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--body" BlockCode=" 

/*Пакет генерации*/
drop table MTO.genpackage/*Пакет генерации*/ 
/
create table MTO.genpackage/*Пакет генерации*/ (
InstanceID CHAR(38) ,
genpackageid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.genpackage add 
name
 VARCHAR2 (255) null /* Название */
/

/*Генераторы*/
drop table MTO.generator_target/*Генераторы*/ 
/
create table MTO.generator_target/*Генераторы*/ (
ParentStructRowID CHAR(38) not null,
generator_targetid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.generator_target add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.generator_target add 
targettype
 NUMBER null 
 check (targettype in ( 0/* СУБД */
, 3/* Документация */
, 1/* МОДЕЛЬ */
, 2/* Приложение */
, 4/* АРМ */ )) /* Тип платформы */
/
alter  table MTO.generator_target add 
queuename
 VARCHAR2 (255) null /* Очередь */
/
alter  table MTO.generator_target add 
generatorprogid
 VARCHAR2 (255) null /* COM класс */
/
alter  table MTO.generator_target add 
generatorstyle
 NUMBER null 
 check (generatorstyle in ( 0/* Один тип */
, 1/* Все типы сразу */ )) /* Вариант */
/
alter  table MTO.generator_target add 
thedevelopmentenv
 NUMBER null 
 check (thedevelopmentenv in ( 3/* OTHER */
, 1/* DOTNET */
, 2/* JAVA */
, 0/* VB6 */ )) /* Среда разработки */
/

/*Библиотеки*/
drop table MTO.genreference/*Библиотеки, которые используются при генерации*/ 
/
create table MTO.genreference/*Библиотеки, которые используются при генерации*/ (
ParentStructRowID CHAR(38) not null,
genreferenceid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.genreference add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.genreference add 
refclassid
 VARCHAR2 (40) null /* Класс ссылки */
/
alter  table MTO.genreference add 
versionmajor
 NUMBER null /* Номер версии */
/
alter  table MTO.genreference add 
versionminor
 NUMBER null /* Подверсия */
/

/*Ручной код*/
drop table MTO.genmanualcode/*Код, который не укладывается в описание модели*/ 
/
create table MTO.genmanualcode/*Код, который не укладывается в описание модели*/ (
ParentStructRowID CHAR(38) not null,
genmanualcodeid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.genmanualcode add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.genmanualcode add 
the_alias
 VARCHAR2 (80) null /* Псевдоним */
/
alter  table MTO.genmanualcode add 
code VARCHAR2(4000) null /* Код */
/

/*Контрольные элементы*/
drop table MTO.gencontrols/*Контрольные элементы, которые используются при генерации*/ 
/
create table MTO.gencontrols/*Контрольные элементы, которые используются при генерации*/ (
ParentStructRowID CHAR(38) not null,
gencontrolsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.gencontrols add 
controlprogid
 VARCHAR2 (255) null /* ProgID контрольконо элемента */
/
alter  table MTO.gencontrols add 
controlclassid
 VARCHAR2 (40) null /* Класс контрольногоэлемента */
/
alter  table MTO.gencontrols add 
versionmajor
 NUMBER null /* Версия */
/
alter  table MTO.gencontrols add 
versionminor
 NUMBER null /* Подверсия */
/

/*Локализация*/
drop table MTO.localizeinfo/**/ 
/
create table MTO.localizeinfo/**/ (
InstanceID CHAR(38) ,
localizeinfoid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.localizeinfo add 
langfull
 VARCHAR2 (255) null /* Язык - название */
/
alter  table MTO.localizeinfo add 
langshort
 VARCHAR2 (255) null /* Код языка */
/

/*Тип поля*/
drop table MTO.fieldtype/*Типы полей, перечисления, интервалы*/ 
/
create table MTO.fieldtype/*Типы полей, перечисления, интервалы*/ (
InstanceID CHAR(38) ,
fieldtypeid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldtype add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.fieldtype add 
typestyle
 NUMBER null 
 check (typestyle in ( 4/* Ссылка */
, 1/* Выражение */
, 5/* Элемент оформления */
, 3/* Интервал */
, 2/* Перечисление */
, 0/* Скалярный тип */ )) /* Трактовка */
/
alter  table MTO.fieldtype add 
the_comment VARCHAR2(4000) null /* Описание */
/
alter  table MTO.fieldtype add 
allowsize
 NUMBER null 
 check (allowsize in ( -1/* Да */
, 0/* Нет */ )) /* Нужен размер */
/
alter  table MTO.fieldtype add 
minimum
 VARCHAR2 (64) null /* Минимум */
/
alter  table MTO.fieldtype add 
maximum
 VARCHAR2 (64) null /* Максимум */
/
alter  table MTO.fieldtype add 
allowlikesearch
 NUMBER null 
 check (allowlikesearch in ( -1/* Да */
, 0/* Нет */ )) /* Поиск текста */
/
alter  table MTO.fieldtype add 
gridsorttype
 NUMBER null 
 check (gridsorttype in ( 0/* As String */
, 1/* As Numeric */
, 2/* As Date */ )) /* Вариант сортировки в табличном представлении */
/
alter  table MTO.fieldtype add 
delayedsave
 NUMBER null 
 check (delayedsave in ( -1/* Да */
, 0/* Нет */ )) /* Отложенное сохранение */
/

/*Зачения*/
drop table MTO.enumitem/*Для описания Enum типов*/ 
/
create table MTO.enumitem/*Для описания Enum типов*/ (
ParentStructRowID CHAR(38) not null,
enumitemid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.enumitem add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.enumitem add 
namevalue
 NUMBER null /* Значение */
/
alter  table MTO.enumitem add 
nameincode
 VARCHAR2 (100) null /* Название в коде */
/

/*Отображение*/
drop table MTO.fieldtypemap/*Отображение типа поля на физический тип хранения*/ 
/
create table MTO.fieldtypemap/*Отображение типа поля на физический тип хранения*/ (
ParentStructRowID CHAR(38) not null,
fieldtypemapid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldtypemap add 
target CHAR(38) null /* Платформа */
/
alter  table MTO.fieldtypemap add 
stoagetype
 VARCHAR2 (255) null /* Тип хранения */
/
alter  table MTO.fieldtypemap add 
fixedsize
 NUMBER null /* Размер */
/

/*Методы и процедуры*/
drop table MTO.sharedmethod/*Методы и процедуры*/ 
/
create table MTO.sharedmethod/*Методы и процедуры*/ (
InstanceID CHAR(38) ,
sharedmethodid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.sharedmethod add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.sharedmethod add 
the_comment VARCHAR2(4000) null /* Описание метода */
/
alter  table MTO.sharedmethod add 
returntype CHAR(38) null /* Возвращаемый тип */
/

/*Реализация*/
drop table MTO.script/*Код метода на понятном конкретному генератору языке*/ 
/
create table MTO.script/*Код метода на понятном конкретному генератору языке*/ (
ParentStructRowID CHAR(38) not null,
scriptid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.script add 
target CHAR(38) null /* Целевая платформа */
/
alter  table MTO.script add 
code VARCHAR2(4000) null /* Скрипт */
/

/*Параметры*/
drop table MTO.parameters/*Параметры метода*/ 
/
create table MTO.parameters/*Параметры метода*/ (
ParentStructRowID CHAR(38) not null,
parametersid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.parameters add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTO.parameters add 
name
 VARCHAR2 (80) null /* Имя */
/
alter  table MTO.parameters add 
caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTO.parameters add 
typeofparm CHAR(38) null /* Тип данных */
/
alter  table MTO.parameters add 
datasize
 NUMBER null /* Размер */
/
alter  table MTO.parameters add 
allownull
 NUMBER null 
 check (allownull in ( -1/* Да */
, 0/* Нет */ )) /* Можно не задавать */
/
alter  table MTO.parameters add 
outparam
 NUMBER null 
 check (outparam in ( -1/* Да */
, 0/* Нет */ )) /* Возвращает значение */
/
alter  table MTO.parameters add 
referencetype
 NUMBER null 
 check (referencetype in ( 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 2/* На строку раздела */
, 1/* На объект  */ )) /* Тип ссылки */
/
alter  table MTO.parameters add 
reftotype CHAR(38) null /* Ссылка на тип */
/
alter  table MTO.parameters add 
reftopart CHAR(38) null /* Ссылка на раздел */
/

/*Тип объекта*/
drop table MTO.objecttype/*Тип объекта (карточки)*/ 
/
create table MTO.objecttype/*Тип объекта (карточки)*/ (
InstanceID CHAR(38) ,
objecttypeid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.objecttype add 
package CHAR(38) null /* Приложение */
/
alter  table MTO.objecttype add 
the_comment
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.objecttype add 
name
 VARCHAR2 (14) null /* Код */
/
alter  table MTO.objecttype add 
issingleinstance
 NUMBER null 
 check (issingleinstance in ( -1/* Да */
, 0/* Нет */ )) /* Допускается только один объект */
/
alter  table MTO.objecttype add 
chooseview CHAR(38) null /* Представление для выбора */
/
alter  table MTO.objecttype add 
onrun CHAR(38) null /* При запуске */
/
alter  table MTO.objecttype add 
oncreate CHAR(38) null /* При создании */
/
alter  table MTO.objecttype add 
ondelete CHAR(38) null /* При удалении */
/
alter  table MTO.objecttype add 
allowreftoobject
 NUMBER null 
 check (allowreftoobject in ( -1/* Да */
, 0/* Нет */ )) /* Отображать при выборе ссылки */
/
alter  table MTO.objecttype add 
allowsearch
 NUMBER null 
 check (allowsearch in ( -1/* Да */
, 0/* Нет */ )) /* Отображать при поиске */
/
alter  table MTO.objecttype add 
replicatype
 NUMBER null 
 check (replicatype in ( 1/* Построчно */
, 0/* Весь документ */
, 2/* Локальный */ )) /* Тип репликации */
/
alter  table MTO.objecttype add 
thecomment VARCHAR2(4000) null /* Описание */
/
alter  table MTO.objecttype add 
useownership
 NUMBER null 
 check (useownership in ( -1/* Да */
, 0/* Нет */ )) /* Видмость зависит от пользователя */
/
alter  table MTO.objecttype add 
usearchiving
 NUMBER null 
 check (usearchiving in ( -1/* Да */
, 0/* Нет */ )) /* Архивировать вместо удаления */
/
alter  table MTO.objecttype add 
commitfullobject
 NUMBER null 
 check (commitfullobject in ( -1/* Да */
, 0/* Нет */ )) /* Сохранять объект целиком */
/
alter  table MTO.objecttype add 
objiconcls
 VARCHAR2 (80) null /* Иконка объекта */
/

/*Состояния*/
drop table MTO.objstatus/*Возможные логические состояния документа*/ 
/
create table MTO.objstatus/*Возможные логические состояния документа*/ (
ParentStructRowID CHAR(38) not null,
objstatusid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.objstatus add 
name
 VARCHAR2 (80) null /* Название */
/
alter  table MTO.objstatus add 
isstartup
 NUMBER null 
 check (isstartup in ( -1/* Да */
, 0/* Нет */ )) /* Начальное */
/
alter  table MTO.objstatus add 
isarchive
 NUMBER null 
 check (isarchive in ( -1/* Да */
, 0/* Нет */ )) /* Архивное */
/
alter  table MTO.objstatus add 
the_comment VARCHAR2(4000) null /* Описание */
/

/*Разрешенные переходы*/
drop table MTO.nextstate/*Матрица переходов */ 
/
create table MTO.nextstate/*Матрица переходов */ (
ParentStructRowID CHAR(38) not null,
nextstateid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.nextstate add 
thestate CHAR(38) null /* Разрешенное состояние */
/

/*Режим работы*/
drop table MTO.objectmode/*Режим работы*/ 
/
create table MTO.objectmode/*Режим работы*/ (
ParentStructRowID CHAR(38) not null,
objectmodeid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.objectmode add 
name
 VARCHAR2 (5) null /* Название режима */
/
alter  table MTO.objectmode add 
defaultmode
 NUMBER null 
 check (defaultmode in ( -1/* Да */
, 0/* Нет */ )) /* Этот режим является основным режимом работы объекта */
/
alter  table MTO.objectmode add 
thecomment VARCHAR2(4000) null /* Описание */
/

/*Органичения разделов*/
drop table MTO.structrestriction/*Ораничения на доступ к разделу документа*/ 
/
create table MTO.structrestriction/*Ораничения на доступ к разделу документа*/ (
ParentStructRowID CHAR(38) not null,
structrestrictionid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.structrestriction add 
struct CHAR(38) null /* структура, доступ к которой ограничен */
/
alter  table MTO.structrestriction add 
allowread
 NUMBER null 
 check (allowread in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен просмотр */
/
alter  table MTO.structrestriction add 
allowadd
 NUMBER null 
 check (allowadd in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено добавлять */
/
alter  table MTO.structrestriction add 
allowedit
 NUMBER null 
 check (allowedit in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено изменять */
/
alter  table MTO.structrestriction add 
allowdelete
 NUMBER null 
 check (allowdelete in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено удалять */
/

/*Ограничения методов*/
drop table MTO.methodrestriction/*Ограничение на использование методов раздела*/ 
/
create table MTO.methodrestriction/*Ограничение на использование методов раздела*/ (
ParentStructRowID CHAR(38) not null,
methodrestrictionid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.methodrestriction add 
part CHAR(38) null /* Структура, которой принадлежит метод */
/
alter  table MTO.methodrestriction add 
method CHAR(38) null /* Метод */
/
alter  table MTO.methodrestriction add 
isrestricted
 NUMBER null 
 check (isrestricted in ( -1/* Да */
, 0/* Нет */ )) /* Запрещено использовать */
/

/*Ограничения полей*/
drop table MTO.fieldrestriction/*Ограничения на доступ к полям раздела*/ 
/
create table MTO.fieldrestriction/*Ограничения на доступ к полям раздела*/ (
ParentStructRowID CHAR(38) not null,
fieldrestrictionid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldrestriction add 
thepart CHAR(38) null /* Структура, которой принадлежит поле */
/
alter  table MTO.fieldrestriction add 
thefield CHAR(38) null /* Поле, на которое накладывается ограничение */
/
alter  table MTO.fieldrestriction add 
allowread
 NUMBER null 
 check (allowread in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен просмотр */
/
alter  table MTO.fieldrestriction add 
allowmodify
 NUMBER null 
 check (allowmodify in ( -1/* Да */
, 0/* Нет */ )) /* Разрешена модификация */
/
alter  table MTO.fieldrestriction add 
mandatoryfield
 NUMBER null 
 check (mandatoryfield in ( -1/* Не существенно */
, 1/* Да */
, 0/* Нет */ )) /* Обязательное поле */
/

/*Методы типа*/
drop table MTO.typemenu/*Методы уровня типа*/ 
/
create table MTO.typemenu/*Методы уровня типа*/ (
ParentStructRowID CHAR(38) not null,
typemenuid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.typemenu add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.typemenu add 
caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTO.typemenu add 
tooltip
 VARCHAR2 (80) null /* Подсказка */
/
alter  table MTO.typemenu add 
the_action CHAR(38) null /* Метод */
/
alter  table MTO.typemenu add 
ismenuitem
 NUMBER null 
 check (ismenuitem in ( -1/* Да */
, 0/* Нет */ )) /* Включать в меню */
/
alter  table MTO.typemenu add 
istoolbarbutton
 NUMBER null 
 check (istoolbarbutton in ( -1/* Да */
, 0/* Нет */ )) /* Включать в тулбар */
/
alter  table MTO.typemenu add 
hotkey
 VARCHAR2 (20) null /* Горячая клавиша */
/

/*Проверка правильности*/
drop table MTO.instancevalidator/*Проверка правильности для объекта в целом*/ 
/
create table MTO.instancevalidator/*Проверка правильности для объекта в целом*/ (
ParentStructRowID CHAR(38) not null,
instancevalidatorid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.instancevalidator add 
target CHAR(38) null /* Платформа */
/
alter  table MTO.instancevalidator add 
code VARCHAR2(4000) null /* Скрипт */
/

/*Раздел*/
drop table MTO.part/*Раздел объекта*/ 
/
create table MTO.part/*Раздел объекта*/ (
ParentStructRowID CHAR(38) not null,
partid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTO.part add 
sequence
 NUMBER null /* № п/п */
/
alter  table MTO.part add 
parttype
 NUMBER null 
 check (parttype in ( 1/* Коллекция */
, 2/* Дерево */
, 0/* Строка */
, 4/* Расширение с данными */
, 3/* Расширение */ )) /* Тип структры */
/
alter  table MTO.part add 
caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTO.part add 
name
 VARCHAR2 (20) null /* Название */
/
alter  table MTO.part add 
the_comment VARCHAR2(4000) null /* Описание */
/
alter  table MTO.part add 
nolog
 NUMBER null 
 check (nolog in ( -1/* Да */
, 0/* Нет */ )) /* Не записывать в журнал */
/
alter  table MTO.part add 
manualregister
 NUMBER null 
 check (manualregister in ( -1/* Да */
, 0/* Нет */ )) /* Исключить из индексирования */
/
alter  table MTO.part add 
oncreate CHAR(38) null /* При создании */
/
alter  table MTO.part add 
onsave CHAR(38) null /* При сохранении */
/
alter  table MTO.part add 
onrun CHAR(38) null /* При открытии */
/
alter  table MTO.part add 
ondelete CHAR(38) null /* При удалении */
/
alter  table MTO.part add 
addbehaivor
 NUMBER null 
 check (addbehaivor in ( 0/* AddForm */
, 2/* RunAction */
, 1/* RefreshOnly */ )) /* Поведение при добавлении */
/
alter  table MTO.part add 
extenderobject CHAR(38) null /* Объект расширения */
/
alter  table MTO.part add 
shablonbrief
 VARCHAR2 (100) null /* Шаблон для краткого отображения */
/
alter  table MTO.part add 
rulebrief
 VARCHAR2 (500) null /* Правило составления BRIEF поля */
/
alter  table MTO.part add 
isjormalchange
 NUMBER null 
 check (isjormalchange in ( -1/* Да */
, 0/* Нет */ )) /* Вести журнал изменений */
/
alter  table MTO.part add 
usearchiving
 NUMBER null 
 check (usearchiving in ( -1/* Да */
, 0/* Нет */ )) /* Архивировать вместо удаления */
/
alter  table MTO.part add 
integerpkey
 NUMBER null 
 check (integerpkey in ( -1/* Да */
, 0/* Нет */ )) /* Целочисленный ключ */
/
alter  table MTO.part add 
particoncls
 VARCHAR2 (80) null /* Иконка раздела */
/

/*Методы раздела*/
drop table MTO.partmenu/*Методы уровня раздела*/ 
/
create table MTO.partmenu/*Методы уровня раздела*/ (
ParentStructRowID CHAR(38) not null,
partmenuid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.partmenu add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.partmenu add 
caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTO.partmenu add 
tooltip
 VARCHAR2 (80) null /* Подсказка */
/
alter  table MTO.partmenu add 
the_action CHAR(38) null /* Метод */
/
alter  table MTO.partmenu add 
ismenuitem
 NUMBER null 
 check (ismenuitem in ( -1/* Да */
, 0/* Нет */ )) /* Включать в меню */
/
alter  table MTO.partmenu add 
istoolbarbutton
 NUMBER null 
 check (istoolbarbutton in ( -1/* Да */
, 0/* Нет */ )) /* В тулбар */
/
alter  table MTO.partmenu add 
hotkey
 VARCHAR2 (20) null /* Горячая клавиша */
/

/*Отображение параметров*/
drop table MTO.partparammap/*отображение значений полей раздела на параметры метода*/ 
/
create table MTO.partparammap/*отображение значений полей раздела на параметры метода*/ (
ParentStructRowID CHAR(38) not null,
partparammapid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.partparammap add 
fieldname
 VARCHAR2 (255) null /* Поле (значение) */
/
alter  table MTO.partparammap add 
paramname
 VARCHAR2 (80) null /* Параметр */
/
alter  table MTO.partparammap add 
noedit
 NUMBER null 
 check (noedit in ( -1/* Да */
, 0/* Нет */ )) /* Редактировать параметр нельзя */
/

/*Представление*/
drop table MTO.partview/*Вариант представления, который может использоваться для создания журнала*/ 
/
create table MTO.partview/*Вариант представления, который может использоваться для создания журнала*/ (
ParentStructRowID CHAR(38) not null,
partviewid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.partview add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.partview add 
the_alias
 VARCHAR2 (64) null /* Псевдоним */
/
alter  table MTO.partview add 
forchoose
 NUMBER null 
 check (forchoose in ( -1/* Да */
, 0/* Нет */ )) /* Для поиска */
/
alter  table MTO.partview add 
filterfield0
 VARCHAR2 (255) null /* Поле - фильтр 0 */
/
alter  table MTO.partview add 
filterfield1
 VARCHAR2 (255) null /* Поле - фильтр 1 */
/
alter  table MTO.partview add 
filterfield2
 VARCHAR2 (255) null /* Поле - фильтр 2 */
/
alter  table MTO.partview add 
filterfield3
 VARCHAR2 (255) null /* Поле - фильтр 3 */
/

/*Колонка*/
drop table MTO.viewcolumn/*Колонка пердставления*/ 
/
create table MTO.viewcolumn/*Колонка пердставления*/ (
ParentStructRowID CHAR(38) not null,
viewcolumnid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.viewcolumn add 
sequence
 NUMBER null /* № */
/
alter  table MTO.viewcolumn add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.viewcolumn add 
the_alias
 VARCHAR2 (64) null /* Псвдоним */
/
alter  table MTO.viewcolumn add 
frompart CHAR(38) null /* Раздел */
/
alter  table MTO.viewcolumn add 
field CHAR(38) null /* Поле */
/
alter  table MTO.viewcolumn add 
aggregation
 NUMBER null 
 check (aggregation in ( 3/* SUM */
, 1/* AVG */
, 6/* CUSTOM */
, 0/* none */
, 2/* COUNT */
, 5/* MAX */
, 4/* MIN */ )) /* Агрегация */
/
alter  table MTO.viewcolumn add 
expression VARCHAR2(4000) null /* Формула */
/
alter  table MTO.viewcolumn add 
forcombo
 NUMBER null 
 check (forcombo in ( -1/* Да */
, 0/* Нет */ )) /* Для комбо */
/

/*Связанные представления*/
drop table MTO.partview_lnk/**/ 
/
create table MTO.partview_lnk/**/ (
ParentStructRowID CHAR(38) not null,
partview_lnkid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.partview_lnk add 
theview CHAR(38) null /* Представление */
/
alter  table MTO.partview_lnk add 
thejoinsource CHAR(38) null /* Связь: Поле для join источник */
/
alter  table MTO.partview_lnk add 
reftype
 NUMBER null 
 check (reftype in ( 0/* Нет */
, 4/* Связка ParentStructRowID  (в передлах объекта) */
, 3/* Связка InstanceID (в передлах объекта) */
, 1/* Ссылка на объект */
, 2/* Ссылка на строку */ )) /* Связывать как */
/
alter  table MTO.partview_lnk add 
thejoindestination CHAR(38) null /* Свзяь: Поле для join приемник */
/
alter  table MTO.partview_lnk add 
handjoin
 VARCHAR2 (255) null /* Ручной join */
/
alter  table MTO.partview_lnk add 
seq
 NUMBER null /* Порядок */
/

/*Логика на форме*/
drop table MTO.validator/*Действия в впроцессе редактирования*/ 
/
create table MTO.validator/*Действия в впроцессе редактирования*/ (
ParentStructRowID CHAR(38) not null,
validatorid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.validator add 
target CHAR(38) null /* Целевая платформа */
/
alter  table MTO.validator add 
code VARCHAR2(4000) null /* Скрипт */
/

/*Ограничение уникальности*/
drop table MTO.uniqueconstraint/*Ограничение уникальности*/ 
/
create table MTO.uniqueconstraint/*Ограничение уникальности*/ (
ParentStructRowID CHAR(38) not null,
uniqueconstraintid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.uniqueconstraint add 
name
 VARCHAR2 (80) null /* Название */
/
alter  table MTO.uniqueconstraint add 
perparent
 NUMBER null 
 check (perparent in ( -1/* Да */
, 0/* Нет */ )) /* По родителю */
/
alter  table MTO.uniqueconstraint add 
thecomment VARCHAR2(4000) null /* Описание */
/

/*Поля ограничения*/
drop table MTO.constraintfield/*Поля ограничения*/ 
/
create table MTO.constraintfield/*Поля ограничения*/ (
ParentStructRowID CHAR(38) not null,
constraintfieldid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.constraintfield add 
thefield CHAR(38) null /* Поле */
/

/*Интерфейсы расширения*/
drop table MTO.extenderinterface/**/ 
/
create table MTO.extenderinterface/**/ (
ParentStructRowID CHAR(38) not null,
extenderinterfaceid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.extenderinterface add 
thename
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.extenderinterface add 
targetplatform CHAR(38) null /* Целевая платформа */
/
alter  table MTO.extenderinterface add 
theobject
 VARCHAR2 (255) null /* Объект */
/
alter  table MTO.extenderinterface add 
theconfig
 VARCHAR2 (512) null /* Конфиг */
/

/*Поле*/
drop table MTO.field/*Поле*/ 
/
create table MTO.field/*Поле*/ (
ParentStructRowID CHAR(38) not null,
fieldid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.field add 
tabname
 VARCHAR2 (60) null /* Имя вкладки */
/
alter  table MTO.field add 
fieldgroupbox
 VARCHAR2 (60) null /* Имя группы */
/
alter  table MTO.field add 
sequence
 NUMBER null /* № п/п */
/
alter  table MTO.field add 
caption
 VARCHAR2 (80) null /* Надпись */
/
alter  table MTO.field add 
name
 VARCHAR2 (64) null /* Имя поля */
/
alter  table MTO.field add 
fieldtype CHAR(38) null /* Тип поля */
/
alter  table MTO.field add 
isbrief
 NUMBER null 
 check (isbrief in ( -1/* Да */
, 0/* Нет */ )) /* Краткая информация */
/
alter  table MTO.field add 
istabbrief
 NUMBER null 
 check (istabbrief in ( -1/* Да */
, 0/* Нет */ )) /* Для отображения в таблице */
/
alter  table MTO.field add 
allownull
 NUMBER null 
 check (allownull in ( -1/* Да */
, 0/* Нет */ )) /* Может быть пустым */
/
alter  table MTO.field add 
datasize
 NUMBER null /* Размер поля */
/
alter  table MTO.field add 
referencetype
 NUMBER null 
 check (referencetype in ( 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 2/* На строку раздела */
, 1/* На объект  */ )) /* Тип ссылки */
/
alter  table MTO.field add 
reftotype CHAR(38) null /* Ссылка на тип */
/
alter  table MTO.field add 
reftopart CHAR(38) null /* Ссылка на раздел */
/
alter  table MTO.field add 
thestyle
 VARCHAR2 (50) null /* Стиль */
/
alter  table MTO.field add 
internalreference
 NUMBER null 
 check (internalreference in ( -1/* Да */
, 0/* Нет */ )) /* Ссылка в пределах объекта */
/
alter  table MTO.field add 
createrefonly
 NUMBER null 
 check (createrefonly in ( -1/* Да */
, 0/* Нет */ )) /* Только создание объекта */
/
alter  table MTO.field add 
isautonumber
 NUMBER null 
 check (isautonumber in ( -1/* Да */
, 0/* Нет */ )) /* Автонумерация */
/
alter  table MTO.field add 
thenumerator CHAR(38) null /* Нумератор */
/
alter  table MTO.field add 
zonetemplate
 VARCHAR2 (255) null /* Шаблон зоны нумерации */
/
alter  table MTO.field add 
numberdatefield CHAR(38) null /* Поле для расчета даты */
/
alter  table MTO.field add 
thecomment VARCHAR2(4000) null /* Описание */
/
alter  table MTO.field add 
shablonbrief
 VARCHAR2 (100) null /* Шаблон для краткого отображения */
/
alter  table MTO.field add 
thenameclass
 VARCHAR2 (100) null /* Имя класса для мастера строк */
/
alter  table MTO.field add 
themask
 VARCHAR2 (64) null /* Маска */
/

/*Интерфейсы расширения*/
drop table MTO.fldextenders/**/ 
/
create table MTO.fldextenders/**/ (
ParentStructRowID CHAR(38) not null,
fldextendersid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fldextenders add 
thename
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.fldextenders add 
targetplatform CHAR(38) null /* Целевая платформа */
/
alter  table MTO.fldextenders add 
theobject
 VARCHAR2 (255) null /* Объект */
/
alter  table MTO.fldextenders add 
theconfig
 VARCHAR2 (512) null /* Конфиг */
/

/*Описание источника данных*/
drop table MTO.fieldsrcdef/*Описание источника данных для полей типа ReferenceSQL */ 
/
create table MTO.fieldsrcdef/*Описание источника данных для полей типа ReferenceSQL */ (
ParentStructRowID CHAR(38) not null,
fieldsrcdefid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldsrcdef add 
provider
 VARCHAR2 (128) null /* Провайдер */
/
alter  table MTO.fieldsrcdef add 
connectionstring
 VARCHAR2 (512) null /* Строка соединения с источником */
/
alter  table MTO.fieldsrcdef add 
datasource
 VARCHAR2 (512) null /* Источник данных */
/
alter  table MTO.fieldsrcdef add 
idfield
 VARCHAR2 (128) null /* ID */
/
alter  table MTO.fieldsrcdef add 
briefstring
 VARCHAR2 (512) null /* Источник краткой информации */
/
alter  table MTO.fieldsrcdef add 
filterstring
 VARCHAR2 (512) null /* Фильтр источника данных */
/
alter  table MTO.fieldsrcdef add 
sortfield
 VARCHAR2 (512) null /* Сортировка источника данных */
/
alter  table MTO.fieldsrcdef add 
descriptionstring VARCHAR2(4000) null /* Примечания */
/
alter  table MTO.fieldsrcdef add 
dontshowdialog
 NUMBER null 
 check (dontshowdialog in ( 1/* Да */
, 0/* Нет */ )) /* Не показывать форму выбора */
/

/*Динамический фильтр*/
drop table MTO.dinamicfilterscript/*Выражение для построения дополнительного фильтра для ссылочных полей*/ 
/
create table MTO.dinamicfilterscript/*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
ParentStructRowID CHAR(38) not null,
dinamicfilterscriptid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.dinamicfilterscript add 
target CHAR(38) null /* Целевая платформа */
/
alter  table MTO.dinamicfilterscript add 
code VARCHAR2(4000) null /* Скрипт */
/

/*Значение по умолчанию*/
drop table MTO.fieldexpression/*Выражение для вычисления поля
или значение по умолчанию*/ 
/
create table MTO.fieldexpression/*Выражение для вычисления поля
или значение по умолчанию*/ (
ParentStructRowID CHAR(38) not null,
fieldexpressionid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldexpression add 
target CHAR(38) null /* Платформа */
/
alter  table MTO.fieldexpression add 
code VARCHAR2(4000) null /* Скрипт */
/

/*Логика поля на форме*/
drop table MTO.fieldvalidator/*Логика взаимосвязей на форме при изменении поля*/ 
/
create table MTO.fieldvalidator/*Логика взаимосвязей на форме при изменении поля*/ (
ParentStructRowID CHAR(38) not null,
fieldvalidatorid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldvalidator add 
target CHAR(38) null /* Платформа */
/
alter  table MTO.fieldvalidator add 
code VARCHAR2(4000) null /* Скрипт */
/

/*Методы поля*/
drop table MTO.fieldmenu/*Методы, ассоциированные с полем*/ 
/
create table MTO.fieldmenu/*Методы, ассоциированные с полем*/ (
ParentStructRowID CHAR(38) not null,
fieldmenuid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldmenu add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.fieldmenu add 
caption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTO.fieldmenu add 
tooltip
 VARCHAR2 (80) null /* Подсказка */
/
alter  table MTO.fieldmenu add 
actionid CHAR(38) null /* Идентификатор вызываемого метода */
/
alter  table MTO.fieldmenu add 
ismenuitem
 NUMBER null 
 check (ismenuitem in ( -1/* Да */
, 0/* Нет */ )) /* В меню */
/
alter  table MTO.fieldmenu add 
istoolbarbutton
 NUMBER null 
 check (istoolbarbutton in ( -1/* Да */
, 0/* Нет */ )) /* В тулбар */
/
alter  table MTO.fieldmenu add 
hotkey
 VARCHAR2 (20) null /* Горячая клавиша */
/

/*Отображение параметров*/
drop table MTO.fieldparammap/*Отображение значений на параметры метода*/ 
/
create table MTO.fieldparammap/*Отображение значений на параметры метода*/ (
ParentStructRowID CHAR(38) not null,
fieldparammapid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fieldparammap add 
fieldname
 VARCHAR2 (255) null /* Поле (значение) */
/
alter  table MTO.fieldparammap add 
paramname
 VARCHAR2 (80) null /* Параметр */
/
alter  table MTO.fieldparammap add 
noedit
 NUMBER null 
 check (noedit in ( -1/* Да */
, 0/* Нет */ )) /* Редактировать параметр нельзя */
/

/*Приложение*/
drop table MTO.mtzapp/*Группа взаимосвязных документов*/ 
/
create table MTO.mtzapp/*Группа взаимосвязных документов*/ (
InstanceID CHAR(38) ,
mtzappid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.mtzapp add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.mtzapp add 
dbname
 VARCHAR2 (64) null /* База данных */
/
alter  table MTO.mtzapp add 
thecomment VARCHAR2(4000) null /* Описание */
/

/*Обязательные приложения*/
drop table MTO.parentpackage/*Приложения от которых зависит данное приложение*/ 
/
create table MTO.parentpackage/*Приложения от которых зависит данное приложение*/ (
ParentStructRowID CHAR(38) not null,
parentpackageid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.parentpackage add 
package CHAR(38) null /* Приложение */
/

/*Колонки журнала*/
drop table MTO.journalcolumn/*Колонки журнала*/ 
/
create table MTO.journalcolumn/*Колонки журнала*/ (
InstanceID CHAR(38) ,
journalcolumnid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.journalcolumn add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTO.journalcolumn add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.journalcolumn add 
columnalignment
 NUMBER null 
 check (columnalignment in ( 6/* Right Top */
, 7/* Right Center */
, 8/* Right Bottom */
, 3/* Center Top */
, 0/* Left Top */
, 4/* Center Center */
, 1/* Left Center */
, 5/* Center Bottom */
, 2/* Left Bottom */ )) /* Выравнивание */
/
alter  table MTO.journalcolumn add 
colsort
 NUMBER null 
 check (colsort in ( 0/* As String */
, 1/* As Numeric */
, 2/* As Date */ )) /* Сортировка колонки */
/
alter  table MTO.journalcolumn add 
groupaggregation
 NUMBER null 
 check (groupaggregation in ( 3/* SUM */
, 1/* AVG */
, 6/* CUSTOM */
, 0/* none */
, 2/* COUNT */
, 5/* MAX */
, 4/* MIN */ )) /* Аггрегация при группировке */
/

/*Состав колонки*/
drop table MTO.jcolumnsource/*Состав колонки*/ 
/
create table MTO.jcolumnsource/*Состав колонки*/ (
ParentStructRowID CHAR(38) not null,
jcolumnsourceid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.jcolumnsource add 
srcpartview CHAR(38) null /* Представление */
/
alter  table MTO.jcolumnsource add 
viewfield
 VARCHAR2 (255) null /* Поле представления */
/

/*Источники журнала*/
drop table MTO.journalsrc/*Источники журнала*/ 
/
create table MTO.journalsrc/*Источники журнала*/ (
InstanceID CHAR(38) ,
journalsrcid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.journalsrc add 
spartview
 VARCHAR2 (38) null /* Представление */
/
alter  table MTO.journalsrc add 
onrun
 NUMBER null 
 check (onrun in ( 2/* Открыть документ */
, 0/* Ничего не делать */
, 1/* Открыть строку */ )) /* При открытии */
/
alter  table MTO.journalsrc add 
openmode
 VARCHAR2 (64) null /* Режим открытия */
/
alter  table MTO.journalsrc add 
viewalias
 VARCHAR2 (255) null /* Псевдоним представления */
/

/*Журнал*/
drop table MTO.journal/*Журнал*/ 
/
create table MTO.journal/*Журнал*/ (
InstanceID CHAR(38) ,
journalid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.journal add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.journal add 
the_alias
 VARCHAR2 (32) null /* Псевдоним */
/
alter  table MTO.journal add 
thecomment VARCHAR2(4000) null /* Описание */
/
alter  table MTO.journal add 
jrnliconcls
 VARCHAR2 (80) null /* Иконка журнала */
/
alter  table MTO.journal add 
usefavorites
 NUMBER null 
 check (usefavorites in ( -1/* Да */
, 0/* Нет */ )) /* Массовое выделение */
/

/*Завод*/
drop table MTO.tod_factory/**/ 
/
create table MTO.tod_factory/**/ (
InstanceID CHAR(38) ,
tod_factoryid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_factory add 
name
 VARCHAR2 (255) null /* Завод */
/

/*Типичные проблемы*/
drop table MTO.tod_bug/**/ 
/
create table MTO.tod_bug/**/ (
InstanceID CHAR(38) ,
tod_bugid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_bug add 
the_system CHAR(38) null /* Узел */
/
alter  table MTO.tod_bug add 
name
 VARCHAR2 (255) null /* Название  */
/
alter  table MTO.tod_bug add 
the_comment VARCHAR2(4000) null /* Примечание */
/

/*Цех*/
drop table MTO.tod_building/**/ 
/
create table MTO.tod_building/**/ (
InstanceID CHAR(38) ,
tod_buildingid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_building add 
thefactory CHAR(38) null /* Завод */
/
alter  table MTO.tod_building add 
name
 VARCHAR2 (255) null /* Цех */
/

/*Тип измерения*/
drop table MTO.tod_valtype/**/ 
/
create table MTO.tod_valtype/**/ (
InstanceID CHAR(38) ,
tod_valtypeid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_valtype add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.tod_valtype add 
edizm CHAR(38) null /* Ед. изм. */
/
alter  table MTO.tod_valtype add 
fieldtype CHAR(38) null /* Трактовка */
/

/*Модели станков*/
drop table MTO.tod_model/**/ 
/
create table MTO.tod_model/**/ (
InstanceID CHAR(38) ,
tod_modelid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_model add 
name
 VARCHAR2 (120) null /* Название */
/

/*Группы узлов*/
drop table MTO.tod_system/**/ 
/
create table MTO.tod_system/**/ (
InstanceID CHAR(38) ,
tod_systemid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_system add 
name
 VARCHAR2 (255) null /* Название */
/

/*Роль*/
drop table MTO.tod_oprole/**/ 
/
create table MTO.tod_oprole/**/ (
InstanceID CHAR(38) ,
tod_oproleid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_oprole add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.tod_oprole add 
docmode
 VARCHAR2 (4) null /* Режим документов */
/

/*Тип тренда*/
drop table MTO.tod_trand/**/ 
/
create table MTO.tod_trand/**/ (
InstanceID CHAR(38) ,
tod_trandid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_trand add 
name
 VARCHAR2 (255) null /* Название */
/

/*Станки*/
drop table MTO.tod_st/**/ 
/
create table MTO.tod_st/**/ (
InstanceID CHAR(38) ,
tod_stid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_st add 
invn
 VARCHAR2 (20) null /* Инвентарный номер */
/
alter  table MTO.tod_st add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.tod_st add 
the_model CHAR(38) null /* Модель станка */
/
alter  table MTO.tod_st add 
thebuilding CHAR(38) null /* Цех */
/

/*Материалы и инструменты*/
drop table MTO.tod_material/**/ 
/
create table MTO.tod_material/**/ (
InstanceID CHAR(38) ,
tod_materialid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_material add 
name
 VARCHAR2 (255) null /* Название */
/

/*Единицы измерения*/
drop table MTO.tod_edizm/**/ 
/
create table MTO.tod_edizm/**/ (
InstanceID CHAR(38) ,
tod_edizmid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tod_edizm add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.tod_edizm add 
fullname
 VARCHAR2 (255) null /* Полное наименование */
/

/*Папка*/
drop table MTO.folder/*Папка каталога*/ 
/
create table MTO.folder/*Папка каталога*/ (
InstanceID CHAR(38) ,
folderid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTO.folder add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.folder add 
foldertype
 NUMBER null 
 check (foldertype in ( 3/* Удаленные */
, 1/* Входящие */
, 9/* Отложенные */
, 4/* Журнал */
, 2/* Исходящие */
, 7/* Черновики */
, 6/* Отправленные */
, 8/* В работе */
, 5/* Календарь */
, 10/* Завершенные */
, 0/* cls__ */ )) /* Тип папки */
/

/*Документы*/
drop table MTO.shortcut/*Ярлыки документов*/ 
/
create table MTO.shortcut/*Ярлыки документов*/ (
ParentStructRowID CHAR(38) not null,
shortcutid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.shortcut add 
docitem CHAR(38) null /* Документ */
/
alter  table MTO.shortcut add 
startmode
 VARCHAR2 (255) null /* Режим */
/

/*Описание*/
drop table MTO.infostoredef/*Описание каталога*/ 
/
create table MTO.infostoredef/*Описание каталога*/ (
InstanceID CHAR(38) ,
infostoredefid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.infostoredef add 
thegroup CHAR(38) null /* Группа */
/
alter  table MTO.infostoredef add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.infostoredef add 
infostoretype
 NUMBER null 
 check (infostoretype in ( 2/* Групповой */
, 0/*  Общий */
, 1/* Персональный */ )) /* Тип каталога */
/
alter  table MTO.infostoredef add 
theuser CHAR(38) null /* Пользователь */
/

/*Сессия пользователя*/
drop table MTO.the_session/*Зарегистрированные сессии пользователей*/ 
/
create table MTO.the_session/*Зарегистрированные сессии пользователей*/ (
InstanceID CHAR(38) ,
the_sessionid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.the_session add 
applicationid CHAR(38) null /* Приложение */
/
alter  table MTO.the_session add 
userrole CHAR(38) null /* Текущая роль пользователя */
/
alter  table MTO.the_session add 
closedat
 DATE null /* Момент закрытия */
/
alter  table MTO.the_session add 
closed
 NUMBER null 
 check (closed in ( 1/* Да */
, 0/* Нет */ )) /* Закрыта */
/
alter  table MTO.the_session add 
usersid CHAR(38) null /* Пользователь */
/
alter  table MTO.the_session add 
lastaccess
 DATE null /* Последнее подтверждение */
/
alter  table MTO.the_session add 
startat
 DATE null /* Момент открытия */
/
alter  table MTO.the_session add 
lang
 VARCHAR2 (25) null /* Локализация */
/
alter  table MTO.the_session add 
login
 VARCHAR2 (255) null /* Login */
/

/*Разрешенные владельцы*/
drop table MTO.sysrefcache/*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ 
/
create table MTO.sysrefcache/*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
InstanceID CHAR(38) ,
sysrefcacheid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.sysrefcache add 
cachetype
 NUMBER null 
 check (cachetype in ( 2/* Все */
, 0/* Только свои */
, 1/* Подчиненные */ )) /* Тип кеширования */
/
alter  table MTO.sysrefcache add 
objectownerid CHAR(38) null /* Идентификатор владельца */
/
alter  table MTO.sysrefcache add 
sessionid CHAR(38) null /* Сессия */
/
alter  table MTO.sysrefcache add 
modulename
 VARCHAR2 (40) null /* модуль */
/

/*Журнал событий*/
drop table MTO.syslog/*Журнал событий, которые произошли в системе*/ 
/
create table MTO.syslog/*Журнал событий, которые произошли в системе*/ (
InstanceID CHAR(38) ,
syslogid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.syslog add 
thesession CHAR(38) null /* Сессия */
/
alter  table MTO.syslog add 
the_resource
 VARCHAR2 (255) null /* Ресурс */
/
alter  table MTO.syslog add 
logstructid
 VARCHAR2 (255) null /* Раздел с которым происхоит действие */
/
alter  table MTO.syslog add 
verb
 VARCHAR2 (80) null /* Действие */
/
alter  table MTO.syslog add 
loginstanceid CHAR(38) null /* Идентификатор документа */
/

/*Поведение журналов*/
drop table MTO.armjournal/*Описание действий журанлов*/ 
/
create table MTO.armjournal/*Описание действий журанлов*/ (
InstanceID CHAR(38) ,
armjournalid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.armjournal add 
thejournal CHAR(38) null /* Журнал */
/

/*Отчеты*/
drop table MTO.armjrnlrep/*Отчеты из журнала*/ 
/
create table MTO.armjrnlrep/*Отчеты из журнала*/ (
ParentStructRowID CHAR(38) not null,
armjrnlrepid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.armjrnlrep add 
repname
 VARCHAR2 (255) null /* Название отчета */
/
alter  table MTO.armjrnlrep add 
thereport CHAR(38) null /* Отчет */
/

/*Действия*/
drop table MTO.armjrnlrun/*Дополнительные действия в журнале*/ 
/
create table MTO.armjrnlrun/*Дополнительные действия в журнале*/ (
ParentStructRowID CHAR(38) not null,
armjrnlrunid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.armjrnlrun add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.armjrnlrun add 
theextention CHAR(38) null /* Расширение */
/

/*Добавление*/
drop table MTO.armjrnladd/*Варианты обработки добавления*/ 
/
create table MTO.armjrnladd/*Варианты обработки добавления*/ (
ParentStructRowID CHAR(38) not null,
armjrnladdid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.armjrnladd add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.armjrnladd add 
theextention CHAR(38) null /* Расширение */
/

/*Меню*/
drop table MTO.entrypoints/*Меню*/ 
/
create table MTO.entrypoints/*Меню*/ (
InstanceID CHAR(38) ,
entrypointsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTO.entrypoints add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTO.entrypoints add 
name
 VARCHAR2 (38) null /* Название */
/
alter  table MTO.entrypoints add 
caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTO.entrypoints add 
astoolbaritem
 NUMBER null 
 check (astoolbaritem in ( -1/* Да */
, 0/* Нет */ )) /* Включить в тулбар */
/
alter  table MTO.entrypoints add 
actiontype
 NUMBER null 
 check (actiontype in ( 4/* Запустить АРМ */
, 2/* Выполнить метод */
, 5/* Открыть отчет */
, 0/* Ничего не делать */
, 1/* Открыть документ */
, 3/* Открыть журнал */ )) /* Вариант действия */
/
alter  table MTO.entrypoints add 
thefilter CHAR(38) null /* Фильтр */
/
alter  table MTO.entrypoints add 
journal CHAR(38) null /* Журнал */
/
alter  table MTO.entrypoints add 
report CHAR(38) null /* Отчет */
/
alter  table MTO.entrypoints add 
document CHAR(38) null /* Документ */
/
alter  table MTO.entrypoints add 
method CHAR(38) null /* Метод */
/
alter  table MTO.entrypoints add 
iconfile
 VARCHAR2 (2000) null /* Файл картинки */
/
alter  table MTO.entrypoints add 
theextention CHAR(38) null /* Расширение */
/
alter  table MTO.entrypoints add 
arm CHAR(38) null /* АРМ */
/
alter  table MTO.entrypoints add 
thecomment VARCHAR2(4000) null /* Примечание */
/
alter  table MTO.entrypoints add 
objecttype CHAR(38) null /* Тип документа */
/
alter  table MTO.entrypoints add 
journalfixedquery VARCHAR2(4000) null /* Ограничения к журналу */
/
alter  table MTO.entrypoints add 
allowadd
 NUMBER null 
 check (allowadd in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено добавление */
/
alter  table MTO.entrypoints add 
allowedit
 NUMBER null 
 check (allowedit in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено редактирование */
/
alter  table MTO.entrypoints add 
allowdel
 NUMBER null 
 check (allowdel in ( -1/* Да */
, 0/* Нет */ )) /* Рарешено удаление */
/
alter  table MTO.entrypoints add 
allowfilter
 NUMBER null 
 check (allowfilter in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен фильтр */
/
alter  table MTO.entrypoints add 
allowprint
 NUMBER null 
 check (allowprint in ( -1/* Да */
, 0/* Нет */ )) /* Разрешена печать */
/

/*Привязка фильтра*/
drop table MTO.epfilterlink/*Привязка фильтра к журналу*/ 
/
create table MTO.epfilterlink/*Привязка фильтра к журналу*/ (
ParentStructRowID CHAR(38) not null,
epfilterlinkid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.epfilterlink add 
rowsource
 VARCHAR2 (255) null /* Источник */
/
alter  table MTO.epfilterlink add 
theexpression VARCHAR2(4000) null /* Выражение */
/
alter  table MTO.epfilterlink add 
filterfield
 VARCHAR2 (255) null /* Поле фильтра */
/

/*Арм*/
drop table MTO.workplace/*Арм*/ 
/
create table MTO.workplace/*Арм*/ (
InstanceID CHAR(38) ,
workplaceid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.workplace add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.workplace add 
caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTO.workplace add 
theversion
 VARCHAR2 (30) null /* Версия */
/
alter  table MTO.workplace add 
theplatform
 NUMBER null 
 check (theplatform in ( 3/* OTHER */
, 1/* DOTNET */
, 2/* JAVA */
, 0/* VB6 */ )) /* Платформа реализации */
/
alter  table MTO.workplace add 
thecomment VARCHAR2(4000) null /* Примечание */
/

/*Список типов*/
drop table MTO.armtypes/*Типы документов, которые подключаются в MDI режиме*/ 
/
create table MTO.armtypes/*Типы документов, которые подключаются в MDI режиме*/ (
InstanceID CHAR(38) ,
armtypesid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.armtypes add 
thedocumenttype CHAR(38) null /* Тип документа */
/

/*Доступные действия*/
drop table MTO.roles_operations/*Именованные операции*/ 
/
create table MTO.roles_operations/*Именованные операции*/ (
InstanceID CHAR(38) ,
roles_operationsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_operations add 
info
 VARCHAR2 (256) null /* Описание */
/
alter  table MTO.roles_operations add 
allowaction
 NUMBER null 
 check (allowaction in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено */
/
alter  table MTO.roles_operations add 
name
 VARCHAR2 (255) null /* Код */
/

/*Доступные приложения*/
drop table MTO.roles_wp/*Доступные приложения*/ 
/
create table MTO.roles_wp/*Доступные приложения*/ (
InstanceID CHAR(38) ,
roles_wpid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_wp add 
wp CHAR(38) null /* Приложение */
/

/*Разрешенные пункты меню*/
drop table MTO.roles_act/*Разрешенные пункты меню*/ 
/
create table MTO.roles_act/*Разрешенные пункты меню*/ (
ParentStructRowID CHAR(38) not null,
roles_actid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_act add 
accesible
 NUMBER null 
 check (accesible in ( 1/* Да */
, 0/* Нет */ )) /* Доступность */
/
alter  table MTO.roles_act add 
menuname
 VARCHAR2 (255) null /* Меню */
/
alter  table MTO.roles_act add 
menucode
 VARCHAR2 (255) null /* Код пункта меню */
/

/*Модули*/
drop table MTO.roles2_module/**/ 
/
create table MTO.roles2_module/**/ (
InstanceID CHAR(38) ,
roles2_moduleid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles2_module add 
groupname
 VARCHAR2 (60) null /* Имя группы */
/
alter  table MTO.roles2_module add 
caption
 VARCHAR2 (80) null /* Надпись */
/
alter  table MTO.roles2_module add 
sequence
 NUMBER null /* № п/п */
/
alter  table MTO.roles2_module add 
moduleaccessible
 NUMBER null 
 check (moduleaccessible in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен */
/
alter  table MTO.roles2_module add 
customizevisibility
 NUMBER null 
 check (customizevisibility in ( -1/* Да */
, 0/* Нет */ )) /* Настраивать видимость */
/
alter  table MTO.roles2_module add 
theicon
 VARCHAR2 (64) null /* Иконка */
/
alter  table MTO.roles2_module add 
name
 VARCHAR2 (255) null /* Код модуля */
/
alter  table MTO.roles2_module add 
thecomment VARCHAR2(4000) null /* Описание */
/
alter  table MTO.roles2_module add 
allobjects
 NUMBER null 
 check (allobjects in ( -1/* Да */
, 0/* Нет */ )) /* Вся фирма */
/
alter  table MTO.roles2_module add 
colegsobject
 NUMBER null 
 check (colegsobject in ( -1/* Да */
, 0/* Нет */ )) /* Объекты коллег */
/
alter  table MTO.roles2_module add 
substructobjects
 NUMBER null 
 check (substructobjects in ( -1/* Да */
, 0/* Нет */ )) /* Подчиненные подразделения */
/

/*Действия и отчеты*/
drop table MTO.roles2_modreport/**/ 
/
create table MTO.roles2_modreport/**/ (
ParentStructRowID CHAR(38) not null,
roles2_modreportid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles2_modreport add 
name
 VARCHAR2 (64) null /* Код */
/
alter  table MTO.roles2_modreport add 
allowaction
 NUMBER null 
 check (allowaction in ( -1/* Да */
, 0/* Нет */ )) /* Разрешен */
/
alter  table MTO.roles2_modreport add 
caption
 VARCHAR2 (80) null /* Надпись */
/
alter  table MTO.roles2_modreport add 
sequence
 NUMBER null /* № п/п */
/
alter  table MTO.roles2_modreport add 
theicon
 VARCHAR2 (64) null /* Иконка */
/
alter  table MTO.roles2_modreport add 
isreport
 NUMBER null 
 check (isreport in ( -1/* Да */
, 0/* Нет */ )) /* Это отчет */
/
alter  table MTO.roles2_modreport add 
selecttype
 NUMBER null /* Вариант выбора */
/

/*Доступные документы*/
drop table MTO.roles_doc/**/ 
/
create table MTO.roles_doc/**/ (
InstanceID CHAR(38) ,
roles_docid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_doc add 
the_document CHAR(38) null /* Тип документа */
/
alter  table MTO.roles_doc add 
the_denied
 NUMBER null 
 check (the_denied in ( 1/* Да */
, 0/* Нет */ )) /* Запрещен */
/
alter  table MTO.roles_doc add 
allowdeletedoc
 NUMBER null 
 check (allowdeletedoc in ( -1/* Да */
, 0/* Нет */ )) /* Разрешено удаление */
/

/*Доступные состояния*/
drop table MTO.roles_doc_state/**/ 
/
create table MTO.roles_doc_state/**/ (
ParentStructRowID CHAR(38) not null,
roles_doc_stateid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_doc_state add 
the_state CHAR(38) null /* Состояние */
/
alter  table MTO.roles_doc_state add 
the_mode CHAR(38) null /* Режим */
/
alter  table MTO.roles_doc_state add 
allowdelete
 NUMBER null 
 check (allowdelete in ( -1/* Да */
, 0/* Нет */ )) /* Можно удалять */
/
alter  table MTO.roles_doc_state add 
statechangedisabled
 NUMBER null 
 check (statechangedisabled in ( -1/* Да */
, 0/* Нет */ )) /* Запрещена смена состояния */
/

/*Отчёты*/
drop table MTO.roles_reports/**/ 
/
create table MTO.roles_reports/**/ (
InstanceID CHAR(38) ,
roles_reportsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_reports add 
the_report CHAR(38) null /* Отчёт */
/

/*Пользователи*/
drop table MTO.roles_user/*Пользователи*/ 
/
create table MTO.roles_user/*Пользователи*/ (
InstanceID CHAR(38) ,
roles_userid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_user add 
theuser CHAR(38) null /* Пользователь */
/

/*Отображение на группы*/
drop table MTO.roles_map/*Отображение на группы защиты*/ 
/
create table MTO.roles_map/*Отображение на группы защиты*/ (
InstanceID CHAR(38) ,
roles_mapid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_map add 
thegroup CHAR(38) null /* Группа */
/

/*Определение роли*/
drop table MTO.roles_def/*Определение роли*/ 
/
create table MTO.roles_def/*Определение роли*/ (
InstanceID CHAR(38) ,
roles_defid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.roles_def add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.roles_def add 
allobjects
 NUMBER null 
 check (allobjects in ( -1/* Да */
, 0/* Нет */ )) /* Вся фирма */
/
alter  table MTO.roles_def add 
colegsobject
 NUMBER null 
 check (colegsobject in ( -1/* Да */
, 0/* Нет */ )) /* Объекты коллег */
/
alter  table MTO.roles_def add 
substructobjects
 NUMBER null 
 check (substructobjects in ( -1/* Да */
, 0/* Нет */ )) /* Подчиненные подразделения */
/

/*Расписание ТО*/
drop table MTO.to_scheditems/**/ 
/
create table MTO.to_scheditems/**/ (
InstanceID CHAR(38) ,
to_scheditemsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_scheditems add 
themachine CHAR(38) null /* Станок */
/
alter  table MTO.to_scheditems add 
todate
 DATE null /* Плановая дата ТО */
/
alter  table MTO.to_scheditems add 
checkin
 DATE null /* Взят в работу */
/
alter  table MTO.to_scheditems add 
oper CHAR(38) null /* Оператор */
/
alter  table MTO.to_scheditems add 
isdone
 NUMBER null 
 check (isdone in ( -1/* Да */
, 0/* Нет */ )) /* ТО проведено */
/
alter  table MTO.to_scheditems add 
finishdate
 DATE null /* Дата завершения ТО */
/

/*Описание*/
drop table MTO.to_schedinfo/**/ 
/
create table MTO.to_schedinfo/**/ (
InstanceID CHAR(38) ,
to_schedinfoid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_schedinfo add 
dfrom
 DATE null /* С */
/
alter  table MTO.to_schedinfo add 
dto
 DATE null /* По */
/

/*Данные тренда*/
drop table MTO.totrn_data/**/ 
/
create table MTO.totrn_data/**/ (
InstanceID CHAR(38) ,
totrn_dataid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.totrn_data add 
time_label
 DATE null /* Временная метка */
/
alter  table MTO.totrn_data add 
thevalue
 NUMBER null /* Значение */
/

/*Описание тренда*/
drop table MTO.totrn_def/**/ 
/
create table MTO.totrn_def/**/ (
InstanceID CHAR(38) ,
totrn_defid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.totrn_def add 
themachine CHAR(38) null /* Станок */
/
alter  table MTO.totrn_def add 
trandtype CHAR(38) null /* Тип тренда */
/
alter  table MTO.totrn_def add 
topvalue
 NUMBER null /* Верхняя граница */
/
alter  table MTO.totrn_def add 
bottomval
 NUMBER null /* Нижняя граница */
/

/*Примечания*/
drop table MTO.to_taskcomment/**/ 
/
create table MTO.to_taskcomment/**/ (
InstanceID CHAR(38) ,
to_taskcommentid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_taskcomment add 
codetocomment CHAR(38) null /* Узел */
/
alter  table MTO.to_taskcomment add 
thecomment VARCHAR2(4000) null /* Примечание */
/
alter  table MTO.to_taskcomment add 
the_operator CHAR(38) null /* Оператор */
/
alter  table MTO.to_taskcomment add 
the_date
 DATE null /* Дата комментария */
/

/*Описание*/
drop table MTO.to_taskinfo/**/ 
/
create table MTO.to_taskinfo/**/ (
InstanceID CHAR(38) ,
to_taskinfoid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_taskinfo add 
themachine CHAR(38) null /* Пункт расписания */
/
alter  table MTO.to_taskinfo add 
oper CHAR(38) null /* Оператор */
/
alter  table MTO.to_taskinfo add 
thecard CHAR(38) null /* Диагностическая карта */
/
alter  table MTO.to_taskinfo add 
crdate
 DATE null /* Дата создания */
/
alter  table MTO.to_taskinfo add 
taskfinished
 NUMBER null 
 check (taskfinished in ( -1/* Да */
, 0/* Нет */ )) /* Задача завершена */
/
alter  table MTO.to_taskinfo add 
finishtime
 DATE null /* Время завершения задачи */
/

/*Проверки*/
drop table MTO.to_taskchecks/**/ 
/
create table MTO.to_taskchecks/**/ (
InstanceID CHAR(38) ,
to_taskchecksid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_taskchecks add 
the_system CHAR(38) null /* Группа узлов */
/
alter  table MTO.to_taskchecks add 
thesubsystem
 VARCHAR2 (255) null /* Узел */
/
alter  table MTO.to_taskchecks add 
the_check
 VARCHAR2 (255) null /* Показатель */
/
alter  table MTO.to_taskchecks add 
normochas
 NUMBER null /* Нормочас */
/
alter  table MTO.to_taskchecks add 
valuetype CHAR(38) null /* Измерение */
/
alter  table MTO.to_taskchecks add 
lowvalue
 VARCHAR2 (255) null /* Нижняя граница (&gt;=) */
/
alter  table MTO.to_taskchecks add 
hivalue
 VARCHAR2 (255) null /* Верхняя граница (&lt;=) */
/
alter  table MTO.to_taskchecks add 
the_comment VARCHAR2(4000) null /* Примечание */
/
alter  table MTO.to_taskchecks add 
thevalue
 VARCHAR2 (255) null /* Значение */
/
alter  table MTO.to_taskchecks add 
the_doc VARCHAR2(255) null /* Документация */
/
alter  table MTO.to_taskchecks add 
checkref CHAR(38) null /* Основание для проверки */
/
alter  table MTO.to_taskchecks add 
tagid
 VARCHAR2 (64) null /* Метка */
/
alter  table MTO.to_taskchecks add 
tagtime
 DATE null /* Дата регистрации метки */
/

/*Комментарии к проверке*/
drop table MTO.to_taskcheckcomment/**/ 
/
create table MTO.to_taskcheckcomment/**/ (
ParentStructRowID CHAR(38) not null,
to_taskcheckcommentid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_taskcheckcomment add 
the_operator CHAR(38) null /* Оператор */
/
alter  table MTO.to_taskcheckcomment add 
the_date
 DATE null /* Дата комментария */
/
alter  table MTO.to_taskcheckcomment add 
info VARCHAR2(4000) null /* Суть комментария */
/

/*Пользователи*/
drop table MTO.users/*Пользователи*/ 
/
create table MTO.users/*Пользователи*/ (
InstanceID CHAR(38) ,
usersid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.users add 
family
 VARCHAR2 (255) null /* Фамилия */
/
alter  table MTO.users add 
name
 VARCHAR2 (64) null /* Имя */
/
alter  table MTO.users add 
surname
 VARCHAR2 (255) null /* Отчество */
/
alter  table MTO.users add 
login
 VARCHAR2 (64) null /* Имя для входа */
/
alter  table MTO.users add 
password VARCHAR2(80) null /* Пароль */
/
alter  table MTO.users add 
domainame
 VARCHAR2 (255) null /* Доменное имя */
/
alter  table MTO.users add 
email VARCHAR2(255) null /* e-mail */
/
alter  table MTO.users add 
phone
 VARCHAR2 (20) null /* Телефон */
/
alter  table MTO.users add 
localphone
 VARCHAR2 (20) null /* Местный телефон */
/

/*Группы*/
drop table MTO.groups/*Группы*/ 
/
create table MTO.groups/*Группы*/ (
InstanceID CHAR(38) ,
groupsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.groups add 
name
 VARCHAR2 (80) null /* Название */
/
alter  table MTO.groups add 
adgroup
 VARCHAR2 (255) null /* Группа AD */
/

/*Состав группы*/
drop table MTO.groupuser/*Состав группы*/ 
/
create table MTO.groupuser/*Состав группы*/ (
ParentStructRowID CHAR(38) not null,
groupuserid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.groupuser add 
theuser CHAR(38) null /* Пользователь */
/

/*Оператор*/
drop table MTO.to_oper/**/ 
/
create table MTO.to_oper/**/ (
InstanceID CHAR(38) ,
to_operid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_oper add 
familyname
 VARCHAR2 (256) null /* Фамилия */
/
alter  table MTO.to_oper add 
name
 VARCHAR2 (255) null /* Имя */
/
alter  table MTO.to_oper add 
surname
 VARCHAR2 (255) null /* Отчество */
/
alter  table MTO.to_oper add 
tnum
 VARCHAR2 (20) null /* Табельный номер */
/
alter  table MTO.to_oper add 
therole CHAR(38) null /* Роль */
/
alter  table MTO.to_oper add 
login
 VARCHAR2 (64) null /* Логин */
/

/*Зоны*/
drop table MTO.num_zones/*Зоны уникальных нумеров*/ 
/
create table MTO.num_zones/*Зоны уникальных нумеров*/ (
InstanceID CHAR(38) ,
num_zonesid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.num_zones add 
zonemask
 VARCHAR2 (255) null /* Маска зоны */
/

/*Номера*/
drop table MTO.num_values/*уникальные номера*/ 
/
create table MTO.num_values/*уникальные номера*/ (
ParentStructRowID CHAR(38) not null,
num_valuesid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.num_values add 
the_value
 NUMBER null /* Значение */
/
alter  table MTO.num_values add 
ownerpartname
 VARCHAR2 (64) null /* Раздел */
/
alter  table MTO.num_values add 
ownerrowid CHAR(38) null /* Идентификатор строки */
/

/*Описание*/
drop table MTO.num_head/*Описание нумератора*/ 
/
create table MTO.num_head/*Описание нумератора*/ (
InstanceID CHAR(38) ,
num_headid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.num_head add 
name
 VARCHAR2 (80) null /* Название */
/
alter  table MTO.num_head add 
shema
 NUMBER null 
 check (shema in ( 2/* По кварталу */
, 3/* По месяцу */
, 0/* Единая зона */
, 4/* По дню */
, 1/* По году */
, 10/* Произвольные зоны */ )) /* Схема нумерации */
/

/*Записи о рабочих станциях*/
drop table MTO.tor_info/**/ 
/
create table MTO.tor_info/**/ (
InstanceID CHAR(38) ,
tor_infoid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.tor_info add 
name
 VARCHAR2 (255) null /* Название станции */
/
alter  table MTO.tor_info add 
serverdata
 DATE null /* Дата сервер */
/
alter  table MTO.tor_info add 
clientdata
 DATE null /* Дата клиент */
/

/*Описание*/
drop table MTO.mtzext_def/*Список зарегистрированных расширений*/ 
/
create table MTO.mtzext_def/*Список зарегистрированных расширений*/ (
InstanceID CHAR(38) ,
mtzext_defid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.mtzext_def add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.mtzext_def add 
exttype
 NUMBER null 
 check (exttype in ( 6/* VerifyRowExt */
, 7/* CodeGenerator */
, 5/* DefaultExt */
, 0/* StatusExt */
, 4/* JrnlRunExt */
, 2/* CustomExt */
, 8/* ARMGenerator */
, 1/* OnFormExt */
, 3/* JrnlAddExt */ )) /* Тип расширения */
/
alter  table MTO.mtzext_def add 
thedescription VARCHAR2(4000) null /* Описание */
/

/*Реализации расширения*/
drop table MTO.mtzextrel/*Реализации расширения для разных разработческих плаформ*/ 
/
create table MTO.mtzextrel/*Реализации расширения для разных разработческих плаформ*/ (
InstanceID CHAR(38) ,
mtzextrelid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.mtzextrel add 
theplatform
 NUMBER null 
 check (theplatform in ( 3/* OTHER */
, 1/* DOTNET */
, 2/* JAVA */
, 0/* VB6 */ )) /* Реализация */
/
alter  table MTO.mtzextrel add 
theclassname
 VARCHAR2 (255) null /* Название класса */
/
alter  table MTO.mtzextrel add 
thelibraryname
 VARCHAR2 (255) null /* Название библиотеки */
/

/*Описание*/
drop table MTO.to_cardinfo/*Описание диагностической карты*/ 
/
create table MTO.to_cardinfo/*Описание диагностической карты*/ (
InstanceID CHAR(38) ,
to_cardinfoid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_cardinfo add 
the_machine CHAR(38) null /* Станок */
/
alter  table MTO.to_cardinfo add 
card_date
 DATE null /* Дата составления карты */
/
alter  table MTO.to_cardinfo add 
card_archived
 NUMBER null 
 check (card_archived in ( -1/* Да */
, 0/* Нет */ )) /* Архивная карта */
/

/*Проверки*/
drop table MTO.to_cardchecks/*Проверяемые параметры*/ 
/
create table MTO.to_cardchecks/*Проверяемые параметры*/ (
InstanceID CHAR(38) ,
to_cardchecksid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_cardchecks add 
the_system CHAR(38) null /* Группа узлов */
/
alter  table MTO.to_cardchecks add 
thesubsystem
 VARCHAR2 (255) null /* Узел */
/
alter  table MTO.to_cardchecks add 
the_check
 VARCHAR2 (255) null /* Показатель */
/
alter  table MTO.to_cardchecks add 
normochas
 NUMBER null /* Нормочас */
/
alter  table MTO.to_cardchecks add 
valuetype CHAR(38) null /* Измерение */
/
alter  table MTO.to_cardchecks add 
lowvalue
 VARCHAR2 (255) null /* Нижняя граница (&gt;=) */
/
alter  table MTO.to_cardchecks add 
hivalue
 VARCHAR2 (255) null /* Верхняя граница (&lt;=) */
/
alter  table MTO.to_cardchecks add 
the_comment VARCHAR2(4000) null /* Примечание */
/
alter  table MTO.to_cardchecks add 
tagid
 VARCHAR2 (255) null /* Метка */
/
alter  table MTO.to_cardchecks add 
the_doc VARCHAR2(255) null /* Документация */
/

/*Инструменты и материалы*/
drop table MTO.to_carddevices/*Инструменты и материалы*/ 
/
create table MTO.to_carddevices/*Инструменты и материалы*/ (
ParentStructRowID CHAR(38) not null,
to_carddevicesid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.to_carddevices add 
mat CHAR(38) null /* Требуется */
/

/*Картинки*/
drop table MTO.toimg_data/**/ 
/
create table MTO.toimg_data/**/ (
InstanceID CHAR(38) ,
toimg_dataid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.toimg_data add 
fname
 VARCHAR2 (255) null /* Имя файла */
/
alter  table MTO.toimg_data add 
link2part
 VARCHAR2 (64) null /* Раздел привязки */
/
alter  table MTO.toimg_data add 
link2id
 VARCHAR2 (38) null /* Идентификатор привязки */
/
alter  table MTO.toimg_data add 
filetype
 VARCHAR2 (40) null /* Тип файла */
/
alter  table MTO.toimg_data add 
link1part
 VARCHAR2 (64) null /* Раздел2 */
/
alter  table MTO.toimg_data add 
link1id
 VARCHAR2 (38) null /* Идентификатор2 */
/
alter  table MTO.toimg_data add 
oper CHAR(38) null /* Оператор */
/

/*Файлы на удаление*/
drop table MTO.toimg_todelete/*Передать информацию серверу об удалении локального файла*/ 
/
create table MTO.toimg_todelete/*Передать информацию серверу об удалении локального файла*/ (
InstanceID CHAR(38) ,
toimg_todeleteid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.toimg_todelete add 
fname
 VARCHAR2 (255) null /* Имя файла */
/
alter  table MTO.toimg_todelete add 
filerowid
 VARCHAR2 (38) null /* ид строки дя удаления */
/

/*Описание хранилища*/
drop table MTO.toimg_def/**/ 
/
create table MTO.toimg_def/**/ (
InstanceID CHAR(38) ,
toimg_defid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.toimg_def add 
computername
 VARCHAR2 (255) null /* Имя  станции */
/
alter  table MTO.toimg_def add 
imagestore
 VARCHAR2 (255) null /* Папка с фотографиями */
/
alter  table MTO.toimg_def add 
sharedfolder
 VARCHAR2 (255) null /* Имя общей директории */
/

/*Отложенное событие*/
drop table MTO.mtz2job_def/*Описание отложенного события*/ 
/
create table MTO.mtz2job_def/*Описание отложенного события*/ (
InstanceID CHAR(38) ,
mtz2job_defid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.mtz2job_def add 
eventdate
 DATE null /* Отложено до */
/
alter  table MTO.mtz2job_def add 
eventype
 VARCHAR2 (255) null /* Тип события */
/
alter  table MTO.mtz2job_def add 
thruobject CHAR(38) null /* Объект - причина события */
/
alter  table MTO.mtz2job_def add 
thrustate CHAR(38) null /* Состояние - причина */
/
alter  table MTO.mtz2job_def add 
nextstate CHAR(38) null /* Состояние после обработки */
/
alter  table MTO.mtz2job_def add 
processdate
 DATE null /* Момент обработки */
/
alter  table MTO.mtz2job_def add 
processed
 NUMBER null 
 check (processed in ( -1/* Да */
, 0/* Нет */ )) /* Обработан */
/

/*Группа полей фильтра*/
drop table MTO.filterfieldgroup/*Группа полей фильтра*/ 
/
create table MTO.filterfieldgroup/*Группа полей фильтра*/ (
InstanceID CHAR(38) ,
filterfieldgroupid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.filterfieldgroup add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTO.filterfieldgroup add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.filterfieldgroup add 
caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTO.filterfieldgroup add 
allowignore
 NUMBER null 
 check (allowignore in ( -1/* Да */
, 0/* Нет */ )) /* Можно отключать */
/

/*Поле фильтра*/
drop table MTO.fileterfield/*Поле фильтра*/ 
/
create table MTO.fileterfield/*Поле фильтра*/ (
ParentStructRowID CHAR(38) not null,
fileterfieldid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.fileterfield add 
sequence
 NUMBER null /* Последовательность */
/
alter  table MTO.fileterfield add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.fileterfield add 
caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTO.fileterfield add 
fieldtype CHAR(38) null /* Тип поля */
/
alter  table MTO.fileterfield add 
fieldsize
 NUMBER null /* Размер */
/
alter  table MTO.fileterfield add 
reftype
 NUMBER null 
 check (reftype in ( 3/* На источник данных */
, 0/* Скалярное поле ( не ссылка) */
, 2/* На строку раздела */
, 1/* На объект  */ )) /* Тип ссылки */
/
alter  table MTO.fileterfield add 
reftotype CHAR(38) null /* Тип, куда ссылаемся */
/
alter  table MTO.fileterfield add 
reftopart CHAR(38) null /* Раздел, куда ссылаемся */
/
alter  table MTO.fileterfield add 
valuearray
 NUMBER null 
 check (valuearray in ( -1/* Да */
, 0/* Нет */ )) /* Массив значений */
/

/*Фильтр*/
drop table MTO.filters/*Фильтр*/ 
/
create table MTO.filters/*Фильтр*/ (
InstanceID CHAR(38) ,
filtersid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.filters add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.filters add 
thecaption
 VARCHAR2 (80) null /* Заголовок */
/
alter  table MTO.filters add 
thecomment VARCHAR2(4000) null /* Описание */
/

/*Секции*/
drop table MTO.rptstruct/*Секции*/ 
/
create table MTO.rptstruct/*Секции*/ (
InstanceID CHAR(38) ,
rptstructid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
,ParentRowid CHAR(38) 
)
/
alter  table MTO.rptstruct add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.rptstruct add 
caption
 VARCHAR2 (255) null /* Заголовок */
/

/*Поля секции*/
drop table MTO.rptfields/*Поля секции*/ 
/
create table MTO.rptfields/*Поля секции*/ (
ParentStructRowID CHAR(38) not null,
rptfieldsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.rptfields add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.rptfields add 
fieldtype CHAR(38) null /* Тип поля */
/
alter  table MTO.rptfields add 
fieldsize
 NUMBER null /* Размер */
/
alter  table MTO.rptfields add 
caption
 VARCHAR2 (255) null /* Заголовок */
/

/*Формулы*/
drop table MTO.rptformula/*Формулы*/ 
/
create table MTO.rptformula/*Формулы*/ (
InstanceID CHAR(38) ,
rptformulaid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.rptformula add 
name
 VARCHAR2 (64) null /* Название */
/
alter  table MTO.rptformula add 
code VARCHAR2(4000) null /* Выражение */
/
alter  table MTO.rptformula add 
platform CHAR(38) null /* Платформа */
/

/*Описание*/
drop table MTO.reports/*Описание*/ 
/
create table MTO.reports/*Описание*/ (
InstanceID CHAR(38) ,
reportsid CHAR(38) not null primary key  
,ChangeStamp date default (sysdate)  /* Время последнего изменения */
,LockSessionID CHAR(38) null  /* temporary lock */
,LockUserID CHAR(38) null /* checkout lock */
,SecurityStyleID CHAR(38) null /* security formula */
)
/
alter  table MTO.reports add 
name
 VARCHAR2 (255) null /* Название */
/
alter  table MTO.reports add 
reportfile VARCHAR2(4000) null /* Файл отчета */
/
alter  table MTO.reports add 
 reportfile_EXT varchar2(4) null
/
alter  table MTO.reports add 
caption
 VARCHAR2 (255) null /* Заголовок */
/
alter  table MTO.reports add 
preparemethod CHAR(38) null /* Метод для формирования */
/
alter  table MTO.reports add 
reporttype
 NUMBER null 
 check (reporttype in ( 4/* Экспорт по Excel шаблону */
, 0/* Таблица */
, 3/* Экспорт по WORD шаблону */
, 1/* Двумерная матрица */
, 2/* Только расчет */ )) /* Тип отчета */
/
alter  table MTO.reports add 
thereportext CHAR(38) null /* Расширение для создания отчета */
/
alter  table MTO.reports add 
reportview
 VARCHAR2 (255) null /* Базовый запрос */
/
alter  table MTO.reports add 
thecomment VARCHAR2(4000) null /* Описание */
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--ForeignKey" BlockCode=" 

alter  TABLE genpackage DROP CONSTRAINT fk_0
/
alter  table MTO.genpackage add constraint fk_0 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE generator_target DROP CONSTRAINT fk_1
/
alter  table MTO.generator_target add constraint fk_1 foreign key(ParentStructRowID) references MTO.genpackage (genpackageID)
/

alter  TABLE genreference DROP CONSTRAINT fk_2
/
alter  table MTO.genreference add constraint fk_2 foreign key(ParentStructRowID) references MTO.generator_target (generator_targetID)
/

alter  TABLE genmanualcode DROP CONSTRAINT fk_3
/
alter  table MTO.genmanualcode add constraint fk_3 foreign key(ParentStructRowID) references MTO.generator_target (generator_targetID)
/

alter  TABLE gencontrols DROP CONSTRAINT fk_4
/
alter  table MTO.gencontrols add constraint fk_4 foreign key(ParentStructRowID) references MTO.generator_target (generator_targetID)
/

alter  TABLE localizeinfo DROP CONSTRAINT fk_5
/
alter  table MTO.localizeinfo add constraint fk_5 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE fieldtype DROP CONSTRAINT fk_6
/
alter  table MTO.fieldtype add constraint fk_6 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE enumitem DROP CONSTRAINT fk_7
/
alter  table MTO.enumitem add constraint fk_7 foreign key(ParentStructRowID) references MTO.fieldtype (fieldtypeID)
/

alter  TABLE fieldtypemap DROP CONSTRAINT fk_8
/
alter  table MTO.fieldtypemap add constraint fk_8 foreign key(ParentStructRowID) references MTO.fieldtype (fieldtypeID)
/

alter  TABLE sharedmethod DROP CONSTRAINT fk_9
/
alter  table MTO.sharedmethod add constraint fk_9 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE script DROP CONSTRAINT fk_10
/
alter  table MTO.script add constraint fk_10 foreign key(ParentStructRowID) references MTO.sharedmethod (sharedmethodID)
/

alter  TABLE parameters DROP CONSTRAINT fk_11
/
alter  table MTO.parameters add constraint fk_11 foreign key(ParentStructRowID) references MTO.script (scriptID)
/

alter  TABLE objecttype DROP CONSTRAINT fk_12
/
alter  table MTO.objecttype add constraint fk_12 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE objstatus DROP CONSTRAINT fk_13
/
alter  table MTO.objstatus add constraint fk_13 foreign key(ParentStructRowID) references MTO.objecttype (objecttypeID)
/

alter  TABLE nextstate DROP CONSTRAINT fk_14
/
alter  table MTO.nextstate add constraint fk_14 foreign key(ParentStructRowID) references MTO.objstatus (objstatusID)
/

alter  TABLE objectmode DROP CONSTRAINT fk_15
/
alter  table MTO.objectmode add constraint fk_15 foreign key(ParentStructRowID) references MTO.objecttype (objecttypeID)
/

alter  TABLE structrestriction DROP CONSTRAINT fk_16
/
alter  table MTO.structrestriction add constraint fk_16 foreign key(ParentStructRowID) references MTO.objectmode (objectmodeID)
/

alter  TABLE methodrestriction DROP CONSTRAINT fk_17
/
alter  table MTO.methodrestriction add constraint fk_17 foreign key(ParentStructRowID) references MTO.objectmode (objectmodeID)
/

alter  TABLE fieldrestriction DROP CONSTRAINT fk_18
/
alter  table MTO.fieldrestriction add constraint fk_18 foreign key(ParentStructRowID) references MTO.objectmode (objectmodeID)
/

alter  TABLE typemenu DROP CONSTRAINT fk_19
/
alter  table MTO.typemenu add constraint fk_19 foreign key(ParentStructRowID) references MTO.objecttype (objecttypeID)
/

alter  TABLE instancevalidator DROP CONSTRAINT fk_20
/
alter  table MTO.instancevalidator add constraint fk_20 foreign key(ParentStructRowID) references MTO.objecttype (objecttypeID)
/

alter  TABLE part DROP CONSTRAINT fk_21
/
alter  table MTO.part add constraint fk_21 foreign key(ParentStructRowID) references MTO.objecttype (objecttypeID)
/

alter  TABLE partmenu DROP CONSTRAINT fk_22
/
alter  table MTO.partmenu add constraint fk_22 foreign key(ParentStructRowID) references MTO.part (partID)
/

alter  TABLE partparammap DROP CONSTRAINT fk_23
/
alter  table MTO.partparammap add constraint fk_23 foreign key(ParentStructRowID) references MTO.partmenu (partmenuID)
/

alter  TABLE partview DROP CONSTRAINT fk_24
/
alter  table MTO.partview add constraint fk_24 foreign key(ParentStructRowID) references MTO.part (partID)
/

alter  TABLE viewcolumn DROP CONSTRAINT fk_25
/
alter  table MTO.viewcolumn add constraint fk_25 foreign key(ParentStructRowID) references MTO.partview (partviewID)
/

alter  TABLE partview_lnk DROP CONSTRAINT fk_26
/
alter  table MTO.partview_lnk add constraint fk_26 foreign key(ParentStructRowID) references MTO.partview (partviewID)
/

alter  TABLE validator DROP CONSTRAINT fk_27
/
alter  table MTO.validator add constraint fk_27 foreign key(ParentStructRowID) references MTO.part (partID)
/

alter  TABLE uniqueconstraint DROP CONSTRAINT fk_28
/
alter  table MTO.uniqueconstraint add constraint fk_28 foreign key(ParentStructRowID) references MTO.part (partID)
/

alter  TABLE constraintfield DROP CONSTRAINT fk_29
/
alter  table MTO.constraintfield add constraint fk_29 foreign key(ParentStructRowID) references MTO.uniqueconstraint (uniqueconstraintID)
/

alter  TABLE extenderinterface DROP CONSTRAINT fk_30
/
alter  table MTO.extenderinterface add constraint fk_30 foreign key(ParentStructRowID) references MTO.part (partID)
/

alter  TABLE field DROP CONSTRAINT fk_31
/
alter  table MTO.field add constraint fk_31 foreign key(ParentStructRowID) references MTO.part (partID)
/

alter  TABLE fldextenders DROP CONSTRAINT fk_32
/
alter  table MTO.fldextenders add constraint fk_32 foreign key(ParentStructRowID) references MTO.field (fieldID)
/

alter  TABLE fieldsrcdef DROP CONSTRAINT fk_33
/
alter  table MTO.fieldsrcdef add constraint fk_33 foreign key(ParentStructRowID) references MTO.field (fieldID)
/

alter  TABLE dinamicfilterscript DROP CONSTRAINT fk_34
/
alter  table MTO.dinamicfilterscript add constraint fk_34 foreign key(ParentStructRowID) references MTO.field (fieldID)
/

alter  TABLE fieldexpression DROP CONSTRAINT fk_35
/
alter  table MTO.fieldexpression add constraint fk_35 foreign key(ParentStructRowID) references MTO.field (fieldID)
/

alter  TABLE fieldvalidator DROP CONSTRAINT fk_36
/
alter  table MTO.fieldvalidator add constraint fk_36 foreign key(ParentStructRowID) references MTO.field (fieldID)
/

alter  TABLE fieldmenu DROP CONSTRAINT fk_37
/
alter  table MTO.fieldmenu add constraint fk_37 foreign key(ParentStructRowID) references MTO.field (fieldID)
/

alter  TABLE fieldparammap DROP CONSTRAINT fk_38
/
alter  table MTO.fieldparammap add constraint fk_38 foreign key(ParentStructRowID) references MTO.fieldmenu (fieldmenuID)
/

alter  TABLE mtzapp DROP CONSTRAINT fk_39
/
alter  table MTO.mtzapp add constraint fk_39 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE parentpackage DROP CONSTRAINT fk_40
/
alter  table MTO.parentpackage add constraint fk_40 foreign key(ParentStructRowID) references MTO.mtzapp (mtzappID)
/

alter  TABLE journalcolumn DROP CONSTRAINT fk_41
/
alter  table MTO.journalcolumn add constraint fk_41 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE jcolumnsource DROP CONSTRAINT fk_42
/
alter  table MTO.jcolumnsource add constraint fk_42 foreign key(ParentStructRowID) references MTO.journalcolumn (journalcolumnID)
/

alter  TABLE journalsrc DROP CONSTRAINT fk_43
/
alter  table MTO.journalsrc add constraint fk_43 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE journal DROP CONSTRAINT fk_44
/
alter  table MTO.journal add constraint fk_44 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_factory DROP CONSTRAINT fk_130
/
alter  table MTO.tod_factory add constraint fk_130 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_bug DROP CONSTRAINT fk_113
/
alter  table MTO.tod_bug add constraint fk_113 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_building DROP CONSTRAINT fk_131
/
alter  table MTO.tod_building add constraint fk_131 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_valtype DROP CONSTRAINT fk_115
/
alter  table MTO.tod_valtype add constraint fk_115 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_model DROP CONSTRAINT fk_116
/
alter  table MTO.tod_model add constraint fk_116 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_system DROP CONSTRAINT fk_117
/
alter  table MTO.tod_system add constraint fk_117 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_oprole DROP CONSTRAINT fk_132
/
alter  table MTO.tod_oprole add constraint fk_132 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_trand DROP CONSTRAINT fk_133
/
alter  table MTO.tod_trand add constraint fk_133 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_st DROP CONSTRAINT fk_114
/
alter  table MTO.tod_st add constraint fk_114 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_material DROP CONSTRAINT fk_118
/
alter  table MTO.tod_material add constraint fk_118 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tod_edizm DROP CONSTRAINT fk_119
/
alter  table MTO.tod_edizm add constraint fk_119 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE folder DROP CONSTRAINT fk_53
/
alter  table MTO.folder add constraint fk_53 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE shortcut DROP CONSTRAINT fk_54
/
alter  table MTO.shortcut add constraint fk_54 foreign key(ParentStructRowID) references MTO.folder (folderID)
/

alter  TABLE infostoredef DROP CONSTRAINT fk_55
/
alter  table MTO.infostoredef add constraint fk_55 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE the_session DROP CONSTRAINT fk_60
/
alter  table MTO.the_session add constraint fk_60 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE sysrefcache DROP CONSTRAINT fk_61
/
alter  table MTO.sysrefcache add constraint fk_61 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE syslog DROP CONSTRAINT fk_62
/
alter  table MTO.syslog add constraint fk_62 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE armjournal DROP CONSTRAINT fk_63
/
alter  table MTO.armjournal add constraint fk_63 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE armjrnlrep DROP CONSTRAINT fk_64
/
alter  table MTO.armjrnlrep add constraint fk_64 foreign key(ParentStructRowID) references MTO.armjournal (armjournalID)
/

alter  TABLE armjrnlrun DROP CONSTRAINT fk_65
/
alter  table MTO.armjrnlrun add constraint fk_65 foreign key(ParentStructRowID) references MTO.armjournal (armjournalID)
/

alter  TABLE armjrnladd DROP CONSTRAINT fk_66
/
alter  table MTO.armjrnladd add constraint fk_66 foreign key(ParentStructRowID) references MTO.armjournal (armjournalID)
/

alter  TABLE entrypoints DROP CONSTRAINT fk_67
/
alter  table MTO.entrypoints add constraint fk_67 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE epfilterlink DROP CONSTRAINT fk_68
/
alter  table MTO.epfilterlink add constraint fk_68 foreign key(ParentStructRowID) references MTO.entrypoints (entrypointsID)
/

alter  TABLE workplace DROP CONSTRAINT fk_69
/
alter  table MTO.workplace add constraint fk_69 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE armtypes DROP CONSTRAINT fk_70
/
alter  table MTO.armtypes add constraint fk_70 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles_operations DROP CONSTRAINT fk_71
/
alter  table MTO.roles_operations add constraint fk_71 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles_wp DROP CONSTRAINT fk_72
/
alter  table MTO.roles_wp add constraint fk_72 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles_act DROP CONSTRAINT fk_73
/
alter  table MTO.roles_act add constraint fk_73 foreign key(ParentStructRowID) references MTO.roles_wp (roles_wpID)
/

alter  TABLE roles2_module DROP CONSTRAINT fk_74
/
alter  table MTO.roles2_module add constraint fk_74 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles2_modreport DROP CONSTRAINT fk_75
/
alter  table MTO.roles2_modreport add constraint fk_75 foreign key(ParentStructRowID) references MTO.roles2_module (roles2_moduleID)
/

alter  TABLE roles_doc DROP CONSTRAINT fk_76
/
alter  table MTO.roles_doc add constraint fk_76 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles_doc_state DROP CONSTRAINT fk_77
/
alter  table MTO.roles_doc_state add constraint fk_77 foreign key(ParentStructRowID) references MTO.roles_doc (roles_docID)
/

alter  TABLE roles_reports DROP CONSTRAINT fk_78
/
alter  table MTO.roles_reports add constraint fk_78 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles_user DROP CONSTRAINT fk_79
/
alter  table MTO.roles_user add constraint fk_79 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles_map DROP CONSTRAINT fk_80
/
alter  table MTO.roles_map add constraint fk_80 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE roles_def DROP CONSTRAINT fk_81
/
alter  table MTO.roles_def add constraint fk_81 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_scheditems DROP CONSTRAINT fk_120
/
alter  table MTO.to_scheditems add constraint fk_120 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_schedinfo DROP CONSTRAINT fk_121
/
alter  table MTO.to_schedinfo add constraint fk_121 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE totrn_data DROP CONSTRAINT fk_134
/
alter  table MTO.totrn_data add constraint fk_134 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE totrn_def DROP CONSTRAINT fk_135
/
alter  table MTO.totrn_def add constraint fk_135 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_taskcomment DROP CONSTRAINT fk_122
/
alter  table MTO.to_taskcomment add constraint fk_122 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_taskinfo DROP CONSTRAINT fk_124
/
alter  table MTO.to_taskinfo add constraint fk_124 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_taskchecks DROP CONSTRAINT fk_125
/
alter  table MTO.to_taskchecks add constraint fk_125 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_taskcheckcomment DROP CONSTRAINT fk_136
/
alter  table MTO.to_taskcheckcomment add constraint fk_136 foreign key(ParentStructRowID) references MTO.to_taskchecks (to_taskchecksID)
/

alter  TABLE users DROP CONSTRAINT fk_85
/
alter  table MTO.users add constraint fk_85 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE groups DROP CONSTRAINT fk_86
/
alter  table MTO.groups add constraint fk_86 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE groupuser DROP CONSTRAINT fk_87
/
alter  table MTO.groupuser add constraint fk_87 foreign key(ParentStructRowID) references MTO.groups (groupsID)
/

alter  TABLE to_oper DROP CONSTRAINT fk_126
/
alter  table MTO.to_oper add constraint fk_126 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE num_zones DROP CONSTRAINT fk_88
/
alter  table MTO.num_zones add constraint fk_88 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE num_values DROP CONSTRAINT fk_89
/
alter  table MTO.num_values add constraint fk_89 foreign key(ParentStructRowID) references MTO.num_zones (num_zonesID)
/

alter  TABLE num_head DROP CONSTRAINT fk_90
/
alter  table MTO.num_head add constraint fk_90 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE tor_info DROP CONSTRAINT fk_137
/
alter  table MTO.tor_info add constraint fk_137 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE mtzext_def DROP CONSTRAINT fk_92
/
alter  table MTO.mtzext_def add constraint fk_92 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE mtzextrel DROP CONSTRAINT fk_93
/
alter  table MTO.mtzextrel add constraint fk_93 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_cardinfo DROP CONSTRAINT fk_127
/
alter  table MTO.to_cardinfo add constraint fk_127 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_cardchecks DROP CONSTRAINT fk_128
/
alter  table MTO.to_cardchecks add constraint fk_128 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE to_carddevices DROP CONSTRAINT fk_129
/
alter  table MTO.to_carddevices add constraint fk_129 foreign key(ParentStructRowID) references MTO.to_cardchecks (to_cardchecksID)
/

alter  TABLE toimg_data DROP CONSTRAINT fk_138
/
alter  table MTO.toimg_data add constraint fk_138 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE toimg_todelete DROP CONSTRAINT fk_139
/
alter  table MTO.toimg_todelete add constraint fk_139 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE toimg_def DROP CONSTRAINT fk_140
/
alter  table MTO.toimg_def add constraint fk_140 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE mtz2job_def DROP CONSTRAINT fk_105
/
alter  table MTO.mtz2job_def add constraint fk_105 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE filterfieldgroup DROP CONSTRAINT fk_106
/
alter  table MTO.filterfieldgroup add constraint fk_106 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE fileterfield DROP CONSTRAINT fk_107
/
alter  table MTO.fileterfield add constraint fk_107 foreign key(ParentStructRowID) references MTO.filterfieldgroup (filterfieldgroupID)
/

alter  TABLE filters DROP CONSTRAINT fk_108
/
alter  table MTO.filters add constraint fk_108 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE rptstruct DROP CONSTRAINT fk_109
/
alter  table MTO.rptstruct add constraint fk_109 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE rptfields DROP CONSTRAINT fk_110
/
alter  table MTO.rptfields add constraint fk_110 foreign key(ParentStructRowID) references MTO.rptstruct (rptstructID)
/

alter  TABLE rptformula DROP CONSTRAINT fk_111
/
alter  table MTO.rptformula add constraint fk_111 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/

alter  TABLE reports DROP CONSTRAINT fk_112
/
alter  table MTO.reports add constraint fk_112 foreign key(INSTANCEID) references MTO.INSTANCE (INSTANCEID)
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--index" BlockCode=" 

drop index parent_genpackage
/
create index MTO.parent_genpackage on MTO.genpackage(&quot;INSTANCEID&quot;)
/

drop index parent_generator_target
/
create index MTO.parent_generator_target on MTO.generator_target(ParentStructRowID)
/

drop index parent_genreference
/
create index MTO.parent_genreference on MTO.genreference(ParentStructRowID)
/

drop index parent_genmanualcode
/
create index MTO.parent_genmanualcode on MTO.genmanualcode(ParentStructRowID)
/

drop index parent_gencontrols
/
create index MTO.parent_gencontrols on MTO.gencontrols(ParentStructRowID)
/

drop index parent_localizeinfo
/
create index MTO.parent_localizeinfo on MTO.localizeinfo(&quot;INSTANCEID&quot;)
/

drop index parent_fieldtype
/
create index MTO.parent_fieldtype on MTO.fieldtype(&quot;INSTANCEID&quot;)
/

drop index parent_enumitem
/
create index MTO.parent_enumitem on MTO.enumitem(ParentStructRowID)
/

drop index parent_fieldtypemap
/
create index MTO.parent_fieldtypemap on MTO.fieldtypemap(ParentStructRowID)
/

drop index parent_sharedmethod
/
create index MTO.parent_sharedmethod on MTO.sharedmethod(&quot;INSTANCEID&quot;)
/

drop index parent_script
/
create index MTO.parent_script on MTO.script(ParentStructRowID)
/

drop index parent_parameters
/
create index MTO.parent_parameters on MTO.parameters(ParentStructRowID)
/

drop index parent_objecttype
/
create index MTO.parent_objecttype on MTO.objecttype(&quot;INSTANCEID&quot;)
/

drop index parent_objstatus
/
create index MTO.parent_objstatus on MTO.objstatus(ParentStructRowID)
/

drop index parent_nextstate
/
create index MTO.parent_nextstate on MTO.nextstate(ParentStructRowID)
/

drop index parent_objectmode
/
create index MTO.parent_objectmode on MTO.objectmode(ParentStructRowID)
/

drop index parent_structrestriction
/
create index MTO.parent_structrestriction on MTO.structrestriction(ParentStructRowID)
/

drop index parent_methodrestriction
/
create index MTO.parent_methodrestriction on MTO.methodrestriction(ParentStructRowID)
/

drop index parent_fieldrestriction
/
create index MTO.parent_fieldrestriction on MTO.fieldrestriction(ParentStructRowID)
/

drop index parent_typemenu
/
create index MTO.parent_typemenu on MTO.typemenu(ParentStructRowID)
/

drop index parent_instancevalidator
/
create index MTO.parent_instancevalidator on MTO.instancevalidator(ParentStructRowID)
/

drop index parent_part
/
create index MTO.parent_part on MTO.part(ParentStructRowID)
/

drop index parent_partmenu
/
create index MTO.parent_partmenu on MTO.partmenu(ParentStructRowID)
/

drop index parent_partparammap
/
create index MTO.parent_partparammap on MTO.partparammap(ParentStructRowID)
/

drop index parent_partview
/
create index MTO.parent_partview on MTO.partview(ParentStructRowID)
/

drop index parent_viewcolumn
/
create index MTO.parent_viewcolumn on MTO.viewcolumn(ParentStructRowID)
/

drop index parent_partview_lnk
/
create index MTO.parent_partview_lnk on MTO.partview_lnk(ParentStructRowID)
/

drop index parent_validator
/
create index MTO.parent_validator on MTO.validator(ParentStructRowID)
/

drop index parent_uniqueconstraint
/
create index MTO.parent_uniqueconstraint on MTO.uniqueconstraint(ParentStructRowID)
/

drop index parent_constraintfield
/
create index MTO.parent_constraintfield on MTO.constraintfield(ParentStructRowID)
/

drop index parent_extenderinterface
/
create index MTO.parent_extenderinterface on MTO.extenderinterface(ParentStructRowID)
/

drop index parent_field
/
create index MTO.parent_field on MTO.field(ParentStructRowID)
/

drop index parent_fldextenders
/
create index MTO.parent_fldextenders on MTO.fldextenders(ParentStructRowID)
/

drop index parent_fieldsrcdef
/
create index MTO.parent_fieldsrcdef on MTO.fieldsrcdef(ParentStructRowID)
/

drop index parent_dinamicfilterscript
/
create index MTO.parent_dinamicfilterscript on MTO.dinamicfilterscript(ParentStructRowID)
/

drop index parent_fieldexpression
/
create index MTO.parent_fieldexpression on MTO.fieldexpression(ParentStructRowID)
/

drop index parent_fieldvalidator
/
create index MTO.parent_fieldvalidator on MTO.fieldvalidator(ParentStructRowID)
/

drop index parent_fieldmenu
/
create index MTO.parent_fieldmenu on MTO.fieldmenu(ParentStructRowID)
/

drop index parent_fieldparammap
/
create index MTO.parent_fieldparammap on MTO.fieldparammap(ParentStructRowID)
/

drop index parent_mtzapp
/
create index MTO.parent_mtzapp on MTO.mtzapp(&quot;INSTANCEID&quot;)
/

drop index parent_parentpackage
/
create index MTO.parent_parentpackage on MTO.parentpackage(ParentStructRowID)
/

drop index parent_journalcolumn
/
create index MTO.parent_journalcolumn on MTO.journalcolumn(&quot;INSTANCEID&quot;)
/

drop index parent_jcolumnsource
/
create index MTO.parent_jcolumnsource on MTO.jcolumnsource(ParentStructRowID)
/

drop index parent_journalsrc
/
create index MTO.parent_journalsrc on MTO.journalsrc(&quot;INSTANCEID&quot;)
/

drop index parent_journal
/
create index MTO.parent_journal on MTO.journal(&quot;INSTANCEID&quot;)
/

drop index parent_tod_factory
/
create index MTO.parent_tod_factory on MTO.tod_factory(&quot;INSTANCEID&quot;)
/

drop index parent_tod_bug
/
create index MTO.parent_tod_bug on MTO.tod_bug(&quot;INSTANCEID&quot;)
/

drop index parent_tod_building
/
create index MTO.parent_tod_building on MTO.tod_building(&quot;INSTANCEID&quot;)
/

drop index parent_tod_valtype
/
create index MTO.parent_tod_valtype on MTO.tod_valtype(&quot;INSTANCEID&quot;)
/

drop index parent_tod_model
/
create index MTO.parent_tod_model on MTO.tod_model(&quot;INSTANCEID&quot;)
/

drop index parent_tod_system
/
create index MTO.parent_tod_system on MTO.tod_system(&quot;INSTANCEID&quot;)
/

drop index parent_tod_oprole
/
create index MTO.parent_tod_oprole on MTO.tod_oprole(&quot;INSTANCEID&quot;)
/

drop index parent_tod_trand
/
create index MTO.parent_tod_trand on MTO.tod_trand(&quot;INSTANCEID&quot;)
/

drop index parent_tod_st
/
create index MTO.parent_tod_st on MTO.tod_st(&quot;INSTANCEID&quot;)
/

drop index parent_tod_material
/
create index MTO.parent_tod_material on MTO.tod_material(&quot;INSTANCEID&quot;)
/

drop index parent_tod_edizm
/
create index MTO.parent_tod_edizm on MTO.tod_edizm(&quot;INSTANCEID&quot;)
/

drop index parent_folder
/
create index MTO.parent_folder on MTO.folder(&quot;INSTANCEID&quot;)
/

drop index parent_shortcut
/
create index MTO.parent_shortcut on MTO.shortcut(ParentStructRowID)
/

drop index parent_infostoredef
/
create index MTO.parent_infostoredef on MTO.infostoredef(&quot;INSTANCEID&quot;)
/

drop index parent_the_session
/
create index MTO.parent_the_session on MTO.the_session(&quot;INSTANCEID&quot;)
/

drop index parent_sysrefcache
/
create index MTO.parent_sysrefcache on MTO.sysrefcache(&quot;INSTANCEID&quot;)
/

drop index parent_syslog
/
create index MTO.parent_syslog on MTO.syslog(&quot;INSTANCEID&quot;)
/

drop index parent_armjournal
/
create index MTO.parent_armjournal on MTO.armjournal(&quot;INSTANCEID&quot;)
/

drop index parent_armjrnlrep
/
create index MTO.parent_armjrnlrep on MTO.armjrnlrep(ParentStructRowID)
/

drop index parent_armjrnlrun
/
create index MTO.parent_armjrnlrun on MTO.armjrnlrun(ParentStructRowID)
/

drop index parent_armjrnladd
/
create index MTO.parent_armjrnladd on MTO.armjrnladd(ParentStructRowID)
/

drop index parent_entrypoints
/
create index MTO.parent_entrypoints on MTO.entrypoints(&quot;INSTANCEID&quot;)
/

drop index parent_epfilterlink
/
create index MTO.parent_epfilterlink on MTO.epfilterlink(ParentStructRowID)
/

drop index parent_workplace
/
create index MTO.parent_workplace on MTO.workplace(&quot;INSTANCEID&quot;)
/

drop index parent_armtypes
/
create index MTO.parent_armtypes on MTO.armtypes(&quot;INSTANCEID&quot;)
/

drop index parent_roles_operations
/
create index MTO.parent_roles_operations on MTO.roles_operations(&quot;INSTANCEID&quot;)
/

drop index parent_roles_wp
/
create index MTO.parent_roles_wp on MTO.roles_wp(&quot;INSTANCEID&quot;)
/

drop index parent_roles_act
/
create index MTO.parent_roles_act on MTO.roles_act(ParentStructRowID)
/

drop index parent_roles2_module
/
create index MTO.parent_roles2_module on MTO.roles2_module(&quot;INSTANCEID&quot;)
/

drop index parent_roles2_modreport
/
create index MTO.parent_roles2_modreport on MTO.roles2_modreport(ParentStructRowID)
/

drop index parent_roles_doc
/
create index MTO.parent_roles_doc on MTO.roles_doc(&quot;INSTANCEID&quot;)
/

drop index parent_roles_doc_state
/
create index MTO.parent_roles_doc_state on MTO.roles_doc_state(ParentStructRowID)
/

drop index parent_roles_reports
/
create index MTO.parent_roles_reports on MTO.roles_reports(&quot;INSTANCEID&quot;)
/

drop index parent_roles_user
/
create index MTO.parent_roles_user on MTO.roles_user(&quot;INSTANCEID&quot;)
/

drop index parent_roles_map
/
create index MTO.parent_roles_map on MTO.roles_map(&quot;INSTANCEID&quot;)
/

drop index parent_roles_def
/
create index MTO.parent_roles_def on MTO.roles_def(&quot;INSTANCEID&quot;)
/

drop index parent_to_scheditems
/
create index MTO.parent_to_scheditems on MTO.to_scheditems(&quot;INSTANCEID&quot;)
/

drop index parent_to_schedinfo
/
create index MTO.parent_to_schedinfo on MTO.to_schedinfo(&quot;INSTANCEID&quot;)
/

drop index parent_totrn_data
/
create index MTO.parent_totrn_data on MTO.totrn_data(&quot;INSTANCEID&quot;)
/

drop index parent_totrn_def
/
create index MTO.parent_totrn_def on MTO.totrn_def(&quot;INSTANCEID&quot;)
/

drop index parent_to_taskcomment
/
create index MTO.parent_to_taskcomment on MTO.to_taskcomment(&quot;INSTANCEID&quot;)
/

drop index parent_to_taskinfo
/
create index MTO.parent_to_taskinfo on MTO.to_taskinfo(&quot;INSTANCEID&quot;)
/

drop index parent_to_taskchecks
/
create index MTO.parent_to_taskchecks on MTO.to_taskchecks(&quot;INSTANCEID&quot;)
/

drop index parent_to_taskcheckcomment
/
create index MTO.parent_to_taskcheckcomment on MTO.to_taskcheckcomment(ParentStructRowID)
/

drop index parent_users
/
create index MTO.parent_users on MTO.users(&quot;INSTANCEID&quot;)
/

drop index parent_groups
/
create index MTO.parent_groups on MTO.groups(&quot;INSTANCEID&quot;)
/

drop index parent_groupuser
/
create index MTO.parent_groupuser on MTO.groupuser(ParentStructRowID)
/

drop index parent_to_oper
/
create index MTO.parent_to_oper on MTO.to_oper(&quot;INSTANCEID&quot;)
/

drop index parent_num_zones
/
create index MTO.parent_num_zones on MTO.num_zones(&quot;INSTANCEID&quot;)
/

drop index parent_num_values
/
create index MTO.parent_num_values on MTO.num_values(ParentStructRowID)
/

drop index parent_num_head
/
create index MTO.parent_num_head on MTO.num_head(&quot;INSTANCEID&quot;)
/

drop index parent_tor_info
/
create index MTO.parent_tor_info on MTO.tor_info(&quot;INSTANCEID&quot;)
/

drop index parent_mtzext_def
/
create index MTO.parent_mtzext_def on MTO.mtzext_def(&quot;INSTANCEID&quot;)
/

drop index parent_mtzextrel
/
create index MTO.parent_mtzextrel on MTO.mtzextrel(&quot;INSTANCEID&quot;)
/

drop index parent_to_cardinfo
/
create index MTO.parent_to_cardinfo on MTO.to_cardinfo(&quot;INSTANCEID&quot;)
/

drop index parent_to_cardchecks
/
create index MTO.parent_to_cardchecks on MTO.to_cardchecks(&quot;INSTANCEID&quot;)
/

drop index parent_to_carddevices
/
create index MTO.parent_to_carddevices on MTO.to_carddevices(ParentStructRowID)
/

drop index parent_toimg_data
/
create index MTO.parent_toimg_data on MTO.toimg_data(&quot;INSTANCEID&quot;)
/

drop index parent_toimg_todelete
/
create index MTO.parent_toimg_todelete on MTO.toimg_todelete(&quot;INSTANCEID&quot;)
/

drop index parent_toimg_def
/
create index MTO.parent_toimg_def on MTO.toimg_def(&quot;INSTANCEID&quot;)
/

drop index parent_mtz2job_def
/
create index MTO.parent_mtz2job_def on MTO.mtz2job_def(&quot;INSTANCEID&quot;)
/

drop index parent_filterfieldgroup
/
create index MTO.parent_filterfieldgroup on MTO.filterfieldgroup(&quot;INSTANCEID&quot;)
/

drop index parent_fileterfield
/
create index MTO.parent_fileterfield on MTO.fileterfield(ParentStructRowID)
/

drop index parent_filters
/
create index MTO.parent_filters on MTO.filters(&quot;INSTANCEID&quot;)
/

drop index parent_rptstruct
/
create index MTO.parent_rptstruct on MTO.rptstruct(&quot;INSTANCEID&quot;)
/

drop index parent_rptfields
/
create index MTO.parent_rptfields on MTO.rptfields(ParentStructRowID)
/

drop index parent_rptformula
/
create index MTO.parent_rptformula on MTO.rptformula(&quot;INSTANCEID&quot;)
/

drop index parent_reports
/
create index MTO.parent_reports on MTO.reports(&quot;INSTANCEID&quot;)
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Functions.Header" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package Func as

  function instance_BRIEF_F  (
 ainstanceid CHAR
)return varchar2;
 function genpackage_BRIEF_F  (
 agenpackageid CHAR
) return varchar2;

 function generator_target_BRIEF_F  (
 agenerator_targetid CHAR
) return varchar2;

 function genreference_BRIEF_F  (
 agenreferenceid CHAR
) return varchar2;

 function genmanualcode_BRIEF_F  (
 agenmanualcodeid CHAR
) return varchar2;

 function gencontrols_BRIEF_F  (
 agencontrolsid CHAR
) return varchar2;

 function localizeinfo_BRIEF_F  (
 alocalizeinfoid CHAR
) return varchar2;

 function fieldtype_BRIEF_F  (
 afieldtypeid CHAR
) return varchar2;

 function enumitem_BRIEF_F  (
 aenumitemid CHAR
) return varchar2;

 function fieldtypemap_BRIEF_F  (
 afieldtypemapid CHAR
) return varchar2;

 function sharedmethod_BRIEF_F  (
 asharedmethodid CHAR
) return varchar2;

 function script_BRIEF_F  (
 ascriptid CHAR
) return varchar2;

 function parameters_BRIEF_F  (
 aparametersid CHAR
) return varchar2;

 function objecttype_BRIEF_F  (
 aobjecttypeid CHAR
) return varchar2;

 function objstatus_BRIEF_F  (
 aobjstatusid CHAR
) return varchar2;

 function nextstate_BRIEF_F  (
 anextstateid CHAR
) return varchar2;

 function objectmode_BRIEF_F  (
 aobjectmodeid CHAR
) return varchar2;

 function structrestriction_BRIEF_F  (
 astructrestrictionid CHAR
) return varchar2;

 function methodrestriction_BRIEF_F  (
 amethodrestrictionid CHAR
) return varchar2;

 function fieldrestriction_BRIEF_F  (
 afieldrestrictionid CHAR
) return varchar2;

 function typemenu_BRIEF_F  (
 atypemenuid CHAR
) return varchar2;

 function instancevalidator_BRIEF_F  (
 ainstancevalidatorid CHAR
) return varchar2;

 function part_BRIEF_F  (
 apartid CHAR
) return varchar2;

 function partmenu_BRIEF_F  (
 apartmenuid CHAR
) return varchar2;

 function partparammap_BRIEF_F  (
 apartparammapid CHAR
) return varchar2;

 function partview_BRIEF_F  (
 apartviewid CHAR
) return varchar2;

 function viewcolumn_BRIEF_F  (
 aviewcolumnid CHAR
) return varchar2;

 function partview_lnk_BRIEF_F  (
 apartview_lnkid CHAR
) return varchar2;

 function validator_BRIEF_F  (
 avalidatorid CHAR
) return varchar2;

 function uniqueconstraint_BRIEF_F  (
 auniqueconstraintid CHAR
) return varchar2;

 function constraintfield_BRIEF_F  (
 aconstraintfieldid CHAR
) return varchar2;

 function extenderinterface_BRIEF_F  (
 aextenderinterfaceid CHAR
) return varchar2;

 function field_BRIEF_F  (
 afieldid CHAR
) return varchar2;

 function fldextenders_BRIEF_F  (
 afldextendersid CHAR
) return varchar2;

 function fieldsrcdef_BRIEF_F  (
 afieldsrcdefid CHAR
) return varchar2;

 function dinamicfilterscript_BRIEF_F  (
 adinamicfilterscriptid CHAR
) return varchar2;

 function fieldexpression_BRIEF_F  (
 afieldexpressionid CHAR
) return varchar2;

 function fieldvalidator_BRIEF_F  (
 afieldvalidatorid CHAR
) return varchar2;

 function fieldmenu_BRIEF_F  (
 afieldmenuid CHAR
) return varchar2;

 function fieldparammap_BRIEF_F  (
 afieldparammapid CHAR
) return varchar2;

 function mtzapp_BRIEF_F  (
 amtzappid CHAR
) return varchar2;

 function parentpackage_BRIEF_F  (
 aparentpackageid CHAR
) return varchar2;

 function journalcolumn_BRIEF_F  (
 ajournalcolumnid CHAR
) return varchar2;

 function jcolumnsource_BRIEF_F  (
 ajcolumnsourceid CHAR
) return varchar2;

 function journalsrc_BRIEF_F  (
 ajournalsrcid CHAR
) return varchar2;

 function journal_BRIEF_F  (
 ajournalid CHAR
) return varchar2;

 function tod_factory_BRIEF_F  (
 atod_factoryid CHAR
) return varchar2;

 function tod_bug_BRIEF_F  (
 atod_bugid CHAR
) return varchar2;

 function tod_building_BRIEF_F  (
 atod_buildingid CHAR
) return varchar2;

 function tod_valtype_BRIEF_F  (
 atod_valtypeid CHAR
) return varchar2;

 function tod_model_BRIEF_F  (
 atod_modelid CHAR
) return varchar2;

 function tod_system_BRIEF_F  (
 atod_systemid CHAR
) return varchar2;

 function tod_oprole_BRIEF_F  (
 atod_oproleid CHAR
) return varchar2;

 function tod_trand_BRIEF_F  (
 atod_trandid CHAR
) return varchar2;

 function tod_st_BRIEF_F  (
 atod_stid CHAR
) return varchar2;

 function tod_material_BRIEF_F  (
 atod_materialid CHAR
) return varchar2;

 function tod_edizm_BRIEF_F  (
 atod_edizmid CHAR
) return varchar2;

 function folder_BRIEF_F  (
 afolderid CHAR
) return varchar2;

 function shortcut_BRIEF_F  (
 ashortcutid CHAR
) return varchar2;

 function infostoredef_BRIEF_F  (
 ainfostoredefid CHAR
) return varchar2;

 function the_session_BRIEF_F  (
 athe_sessionid CHAR
) return varchar2;

 function sysrefcache_BRIEF_F  (
 asysrefcacheid CHAR
) return varchar2;

 function syslog_BRIEF_F  (
 asyslogid CHAR
) return varchar2;

 function armjournal_BRIEF_F  (
 aarmjournalid CHAR
) return varchar2;

 function armjrnlrep_BRIEF_F  (
 aarmjrnlrepid CHAR
) return varchar2;

 function armjrnlrun_BRIEF_F  (
 aarmjrnlrunid CHAR
) return varchar2;

 function armjrnladd_BRIEF_F  (
 aarmjrnladdid CHAR
) return varchar2;

 function entrypoints_BRIEF_F  (
 aentrypointsid CHAR
) return varchar2;

 function epfilterlink_BRIEF_F  (
 aepfilterlinkid CHAR
) return varchar2;

 function workplace_BRIEF_F  (
 aworkplaceid CHAR
) return varchar2;

 function armtypes_BRIEF_F  (
 aarmtypesid CHAR
) return varchar2;

 function roles_operations_BRIEF_F  (
 aroles_operationsid CHAR
) return varchar2;

 function roles_wp_BRIEF_F  (
 aroles_wpid CHAR
) return varchar2;

 function roles_act_BRIEF_F  (
 aroles_actid CHAR
) return varchar2;

 function roles2_module_BRIEF_F  (
 aroles2_moduleid CHAR
) return varchar2;

 function roles2_modreport_BRIEF_F  (
 aroles2_modreportid CHAR
) return varchar2;

 function roles_doc_BRIEF_F  (
 aroles_docid CHAR
) return varchar2;

 function roles_doc_state_BRIEF_F  (
 aroles_doc_stateid CHAR
) return varchar2;

 function roles_reports_BRIEF_F  (
 aroles_reportsid CHAR
) return varchar2;

 function roles_user_BRIEF_F  (
 aroles_userid CHAR
) return varchar2;

 function roles_map_BRIEF_F  (
 aroles_mapid CHAR
) return varchar2;

 function roles_def_BRIEF_F  (
 aroles_defid CHAR
) return varchar2;

 function to_scheditems_BRIEF_F  (
 ato_scheditemsid CHAR
) return varchar2;

 function to_schedinfo_BRIEF_F  (
 ato_schedinfoid CHAR
) return varchar2;

 function totrn_data_BRIEF_F  (
 atotrn_dataid CHAR
) return varchar2;

 function totrn_def_BRIEF_F  (
 atotrn_defid CHAR
) return varchar2;

 function to_taskcomment_BRIEF_F  (
 ato_taskcommentid CHAR
) return varchar2;

 function to_taskinfo_BRIEF_F  (
 ato_taskinfoid CHAR
) return varchar2;

 function to_taskchecks_BRIEF_F  (
 ato_taskchecksid CHAR
) return varchar2;

 function to_taskcheckcomment_BRIEF_F  (
 ato_taskcheckcommentid CHAR
) return varchar2;

 function users_BRIEF_F  (
 ausersid CHAR
) return varchar2;

 function groups_BRIEF_F  (
 agroupsid CHAR
) return varchar2;

 function groupuser_BRIEF_F  (
 agroupuserid CHAR
) return varchar2;

 function to_oper_BRIEF_F  (
 ato_operid CHAR
) return varchar2;

 function num_zones_BRIEF_F  (
 anum_zonesid CHAR
) return varchar2;

 function num_values_BRIEF_F  (
 anum_valuesid CHAR
) return varchar2;

 function num_head_BRIEF_F  (
 anum_headid CHAR
) return varchar2;

 function tor_info_BRIEF_F  (
 ator_infoid CHAR
) return varchar2;

 function mtzext_def_BRIEF_F  (
 amtzext_defid CHAR
) return varchar2;

 function mtzextrel_BRIEF_F  (
 amtzextrelid CHAR
) return varchar2;

 function to_cardinfo_BRIEF_F  (
 ato_cardinfoid CHAR
) return varchar2;

 function to_cardchecks_BRIEF_F  (
 ato_cardchecksid CHAR
) return varchar2;

 function to_carddevices_BRIEF_F  (
 ato_carddevicesid CHAR
) return varchar2;

 function toimg_data_BRIEF_F  (
 atoimg_dataid CHAR
) return varchar2;

 function toimg_todelete_BRIEF_F  (
 atoimg_todeleteid CHAR
) return varchar2;

 function toimg_def_BRIEF_F  (
 atoimg_defid CHAR
) return varchar2;

 function mtz2job_def_BRIEF_F  (
 amtz2job_defid CHAR
) return varchar2;

 function filterfieldgroup_BRIEF_F  (
 afilterfieldgroupid CHAR
) return varchar2;

 function fileterfield_BRIEF_F  (
 afileterfieldid CHAR
) return varchar2;

 function filters_BRIEF_F  (
 afiltersid CHAR
) return varchar2;

 function rptstruct_BRIEF_F  (
 arptstructid CHAR
) return varchar2;

 function rptfields_BRIEF_F  (
 arptfieldsid CHAR
) return varchar2;

 function rptformula_BRIEF_F  (
 arptformulaid CHAR
) return varchar2;

 function reports_BRIEF_F  (
 areportsid CHAR
) return varchar2;
 end Func;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Views" File="">
    <BlockHolder BlockName="--body" BlockCode=" 

create or replace view v_instance as
select instance.*,objstatus.name statusname,objstatus.IsArchive
from instance left join objstatus on instance.status=objstatus.objstatusid
/
create or replace view V_autogenpackage as 
select   genpackageID
, 
genpackage.name 
genpackage_name 
, genpackage.InstanceID InstanceID 
, genpackage.genpackageID ID 
, 'genpackage' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from genpackage
 join INSTANCE on genpackage.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autogenerator_target as 
select   generator_targetID,genpackageID
, 
 generator_target.generatorstyle  
generator_target_generatorstyle_VAL, 
 decode(generator_target.generatorstyle 
, 0 ,'Один тип'
, 1 ,'Все типы сразу'
, '???') 
generator_target_generatorstyle 
, 
 generator_target.thedevelopmentenv  
generator_target_thedevelopmentenv_VAL, 
 decode(generator_target.thedevelopmentenv 
, 3 ,'OTHER'
, 1 ,'DOTNET'
, 2 ,'JAVA'
, 0 ,'VB6'
, '???') 
generator_target_thedevelopmentenv 
, 
generator_target.name 
generator_target_name 
, 
generator_target.generatorprogid 
generator_target_generatorprogid 
, 
generator_target.queuename 
generator_target_queuename 
, 
 generator_target.targettype  
generator_target_targettype_VAL, 
 decode(generator_target.targettype 
, 0 ,'СУБД'
, 3 ,'Документация'
, 1 ,'МОДЕЛЬ'
, 2 ,'Приложение'
, 4 ,'АРМ'
, '???') 
generator_target_targettype 
, genpackage.InstanceID InstanceID 
, generator_target.generator_targetID ID 
, 'generator_target' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from generator_target
 join genpackage on genpackage.genpackageID=generator_target.ParentStructRowID 
 join INSTANCE on genpackage.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autogenreference as 
select   genreferenceID,generator_targetID,genpackageID
, 
genreference.refclassid 
genreference_refclassid 
, 
genreference.versionmajor 
genreference_versionmajor 
, 
genreference.name 
genreference_name 
, 
genreference.versionminor 
genreference_versionminor 
, genpackage.InstanceID InstanceID 
, genreference.genreferenceID ID 
, 'genreference' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from genreference
 join generator_target on generator_target.generator_targetID=genreference.ParentStructRowID 
 join genpackage on genpackage.genpackageID=generator_target.ParentStructRowID 
 join INSTANCE on genpackage.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autogenmanualcode as 
select   genmanualcodeID,generator_targetID,genpackageID
, 
genmanualcode.the_alias 
genmanualcode_the_alias 
, 
genmanualcode.code 
genmanualcode_code 
, 
genmanualcode.name 
genmanualcode_name 
, genpackage.InstanceID InstanceID 
, genmanualcode.genmanualcodeID ID 
, 'genmanualcode' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from genmanualcode
 join generator_target on generator_target.generator_targetID=genmanualcode.ParentStructRowID 
 join genpackage on genpackage.genpackageID=generator_target.ParentStructRowID 
 join INSTANCE on genpackage.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autogencontrols as 
select   gencontrolsID,generator_targetID,genpackageID
, 
gencontrols.controlprogid 
gencontrols_controlprogid 
, 
gencontrols.controlclassid 
gencontrols_controlclassid 
, 
gencontrols.versionminor 
gencontrols_versionminor 
, 
gencontrols.versionmajor 
gencontrols_versionmajor 
, genpackage.InstanceID InstanceID 
, gencontrols.gencontrolsID ID 
, 'gencontrols' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from gencontrols
 join generator_target on generator_target.generator_targetID=gencontrols.ParentStructRowID 
 join genpackage on genpackage.genpackageID=generator_target.ParentStructRowID 
 join INSTANCE on genpackage.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autolocalizeinfo as 
select   localizeinfoID
, 
localizeinfo.langfull 
localizeinfo_langfull 
, 
localizeinfo.langshort 
localizeinfo_langshort 
, localizeinfo.InstanceID InstanceID 
, localizeinfo.localizeinfoID ID 
, 'localizeinfo' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from localizeinfo
 join INSTANCE on localizeinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldtype as 
select   fieldtypeID
, 
 fieldtype.allowsize  
fieldtype_allowsize_VAL, 
 decode(fieldtype.allowsize 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldtype_allowsize 
, 
 fieldtype.typestyle  
fieldtype_typestyle_VAL, 
 decode(fieldtype.typestyle 
, 4 ,'Ссылка'
, 1 ,'Выражение'
, 5 ,'Элемент оформления'
, 3 ,'Интервал'
, 2 ,'Перечисление'
, 0 ,'Скалярный тип'
, '???') 
fieldtype_typestyle 
, 
 fieldtype.allowlikesearch  
fieldtype_allowlikesearch_VAL, 
 decode(fieldtype.allowlikesearch 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldtype_allowlikesearch 
, 
fieldtype.the_comment 
fieldtype_the_comment 
, 
 fieldtype.gridsorttype  
fieldtype_gridsorttype_VAL, 
 decode(fieldtype.gridsorttype 
, 0 ,'As String'
, 1 ,'As Numeric'
, 2 ,'As Date'
, '???') 
fieldtype_gridsorttype 
, 
fieldtype.name 
fieldtype_name 
, 
fieldtype.maximum 
fieldtype_maximum 
, 
 fieldtype.delayedsave  
fieldtype_delayedsave_VAL, 
 decode(fieldtype.delayedsave 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldtype_delayedsave 
, 
fieldtype.minimum 
fieldtype_minimum 
, fieldtype.InstanceID InstanceID 
, fieldtype.fieldtypeID ID 
, 'fieldtype' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldtype
 join INSTANCE on fieldtype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoenumitem as 
select   enumitemID,fieldtypeID
, 
enumitem.nameincode 
enumitem_nameincode 
, 
enumitem.name 
enumitem_name 
, 
enumitem.namevalue 
enumitem_namevalue 
, fieldtype.InstanceID InstanceID 
, enumitem.enumitemID ID 
, 'enumitem' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from enumitem
 join fieldtype on fieldtype.fieldtypeID=enumitem.ParentStructRowID 
 join INSTANCE on fieldtype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldtypemap as 
select   fieldtypemapID,fieldtypeID
, 
 fieldtypemap.target  
fieldtypemap_target_ID, 
 MTO.Func.generator_target_BRIEF_F(fieldtypemap.target) 
fieldtypemap_target 
, 
fieldtypemap.fixedsize 
fieldtypemap_fixedsize 
, 
fieldtypemap.stoagetype 
fieldtypemap_stoagetype 
, fieldtype.InstanceID InstanceID 
, fieldtypemap.fieldtypemapID ID 
, 'fieldtypemap' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldtypemap
 join fieldtype on fieldtype.fieldtypeID=fieldtypemap.ParentStructRowID 
 join INSTANCE on fieldtype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autosharedmethod as 
select   sharedmethodID
, 
 sharedmethod.returntype  
sharedmethod_returntype_ID, 
 MTO.Func.fieldtype_BRIEF_F(sharedmethod.returntype) 
sharedmethod_returntype 
, 
sharedmethod.name 
sharedmethod_name 
, 
sharedmethod.the_comment 
sharedmethod_the_comment 
, sharedmethod.InstanceID InstanceID 
, sharedmethod.sharedmethodID ID 
, 'sharedmethod' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from sharedmethod
 join INSTANCE on sharedmethod.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoscript as 
select   scriptID,sharedmethodID
, 
 script.target  
script_target_ID, 
 MTO.Func.generator_target_BRIEF_F(script.target) 
script_target 
, 
script.code 
script_code 
, sharedmethod.InstanceID InstanceID 
, script.scriptID ID 
, 'script' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from script
 join sharedmethod on sharedmethod.sharedmethodID=script.ParentStructRowID 
 join INSTANCE on sharedmethod.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoparameters as 
select   parametersID,scriptID,sharedmethodID
, 
parameters.sequence 
parameters_sequence 
, 
 parameters.outparam  
parameters_outparam_VAL, 
 decode(parameters.outparam 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
parameters_outparam 
, 
 parameters.reftotype  
parameters_reftotype_ID, 
 MTO.Func.objecttype_BRIEF_F(parameters.reftotype) 
parameters_reftotype 
, 
 parameters.reftopart  
parameters_reftopart_ID, 
 MTO.Func.part_BRIEF_F(parameters.reftopart) 
parameters_reftopart 
, 
parameters.caption 
parameters_caption 
, 
parameters.datasize 
parameters_datasize 
, 
parameters.name 
parameters_name 
, 
 parameters.allownull  
parameters_allownull_VAL, 
 decode(parameters.allownull 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
parameters_allownull 
, 
 parameters.typeofparm  
parameters_typeofparm_ID, 
 MTO.Func.fieldtype_BRIEF_F(parameters.typeofparm) 
parameters_typeofparm 
, 
 parameters.referencetype  
parameters_referencetype_VAL, 
 decode(parameters.referencetype 
, 3 ,'На источник данных'
, 0 ,'Скалярное поле ( не ссылка)'
, 2 ,'На строку раздела'
, 1 ,'На объект '
, '???') 
parameters_referencetype 
, sharedmethod.InstanceID InstanceID 
, parameters.parametersID ID 
, 'parameters' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from parameters
 join script on script.scriptID=parameters.ParentStructRowID 
 join sharedmethod on sharedmethod.sharedmethodID=script.ParentStructRowID 
 join INSTANCE on sharedmethod.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoobjecttype as 
select   objecttypeID
, 
 objecttype.issingleinstance  
objecttype_issingleinstance_VAL, 
 decode(objecttype.issingleinstance 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objecttype_issingleinstance 
, 
 objecttype.ondelete  
objecttype_ondelete_ID, 
 MTO.Func.typemenu_BRIEF_F(objecttype.ondelete) 
objecttype_ondelete 
, 
objecttype.objiconcls 
objecttype_objiconcls 
, 
 objecttype.onrun  
objecttype_onrun_ID, 
 MTO.Func.typemenu_BRIEF_F(objecttype.onrun) 
objecttype_onrun 
, 
 objecttype.chooseview  
objecttype_chooseview_ID, 
 MTO.Func.partview_BRIEF_F(objecttype.chooseview) 
objecttype_chooseview 
, 
 objecttype.package  
objecttype_package_ID, 
 MTO.Func.mtzapp_BRIEF_F(objecttype.package) 
objecttype_package 
, 
 objecttype.oncreate  
objecttype_oncreate_ID, 
 MTO.Func.typemenu_BRIEF_F(objecttype.oncreate) 
objecttype_oncreate 
, 
objecttype.name 
objecttype_name 
, 
 objecttype.commitfullobject  
objecttype_commitfullobject_VAL, 
 decode(objecttype.commitfullobject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objecttype_commitfullobject 
, 
 objecttype.useownership  
objecttype_useownership_VAL, 
 decode(objecttype.useownership 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objecttype_useownership 
, 
 objecttype.allowreftoobject  
objecttype_allowreftoobject_VAL, 
 decode(objecttype.allowreftoobject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objecttype_allowreftoobject 
, 
 objecttype.usearchiving  
objecttype_usearchiving_VAL, 
 decode(objecttype.usearchiving 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objecttype_usearchiving 
, 
objecttype.thecomment 
objecttype_thecomment 
, 
 objecttype.replicatype  
objecttype_replicatype_VAL, 
 decode(objecttype.replicatype 
, 1 ,'Построчно'
, 0 ,'Весь документ'
, 2 ,'Локальный'
, '???') 
objecttype_replicatype 
, 
objecttype.the_comment 
objecttype_the_comment 
, 
 objecttype.allowsearch  
objecttype_allowsearch_VAL, 
 decode(objecttype.allowsearch 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objecttype_allowsearch 
, objecttype.InstanceID InstanceID 
, objecttype.objecttypeID ID 
, 'objecttype' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from objecttype
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoobjstatus as 
select   objstatusID,objecttypeID
, 
objstatus.the_comment 
objstatus_the_comment 
, 
 objstatus.isarchive  
objstatus_isarchive_VAL, 
 decode(objstatus.isarchive 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objstatus_isarchive 
, 
objstatus.name 
objstatus_name 
, 
 objstatus.isstartup  
objstatus_isstartup_VAL, 
 decode(objstatus.isstartup 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objstatus_isstartup 
, objecttype.InstanceID InstanceID 
, objstatus.objstatusID ID 
, 'objstatus' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from objstatus
 join objecttype on objecttype.objecttypeID=objstatus.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autonextstate as 
select   nextstateID,objstatusID,objecttypeID
, 
 nextstate.thestate  
nextstate_thestate_ID, 
 MTO.Func.objstatus_BRIEF_F(nextstate.thestate) 
nextstate_thestate 
, objecttype.InstanceID InstanceID 
, nextstate.nextstateID ID 
, 'nextstate' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from nextstate
 join objstatus on objstatus.objstatusID=nextstate.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=objstatus.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoobjectmode as 
select   objectmodeID,objecttypeID
, 
objectmode.name 
objectmode_name 
, 
objectmode.thecomment 
objectmode_thecomment 
, 
 objectmode.defaultmode  
objectmode_defaultmode_VAL, 
 decode(objectmode.defaultmode 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
objectmode_defaultmode 
, objecttype.InstanceID InstanceID 
, objectmode.objectmodeID ID 
, 'objectmode' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from objectmode
 join objecttype on objecttype.objecttypeID=objectmode.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autostructrestriction as 
select   structrestrictionID,objectmodeID,objecttypeID
, 
 structrestriction.allowread  
structrestriction_allowread_VAL, 
 decode(structrestriction.allowread 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
structrestriction_allowread 
, 
 structrestriction.allowdelete  
structrestriction_allowdelete_VAL, 
 decode(structrestriction.allowdelete 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
structrestriction_allowdelete 
, 
 structrestriction.allowedit  
structrestriction_allowedit_VAL, 
 decode(structrestriction.allowedit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
structrestriction_allowedit 
, 
 structrestriction.struct  
structrestriction_struct_ID, 
 MTO.Func.part_BRIEF_F(structrestriction.struct) 
structrestriction_struct 
, 
 structrestriction.allowadd  
structrestriction_allowadd_VAL, 
 decode(structrestriction.allowadd 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
structrestriction_allowadd 
, objecttype.InstanceID InstanceID 
, structrestriction.structrestrictionID ID 
, 'structrestriction' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from structrestriction
 join objectmode on objectmode.objectmodeID=structrestriction.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=objectmode.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_automethodrestriction as 
select   methodrestrictionID,objectmodeID,objecttypeID
, 
 methodrestriction.isrestricted  
methodrestriction_isrestricted_VAL, 
 decode(methodrestriction.isrestricted 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
methodrestriction_isrestricted 
, 
 methodrestriction.part  
methodrestriction_part_ID, 
 MTO.Func.part_BRIEF_F(methodrestriction.part) 
methodrestriction_part 
, 
 methodrestriction.method  
methodrestriction_method_ID, 
 MTO.Func.sharedmethod_BRIEF_F(methodrestriction.method) 
methodrestriction_method 
, objecttype.InstanceID InstanceID 
, methodrestriction.methodrestrictionID ID 
, 'methodrestriction' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from methodrestriction
 join objectmode on objectmode.objectmodeID=methodrestriction.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=objectmode.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldrestriction as 
select   fieldrestrictionID,objectmodeID,objecttypeID
, 
 fieldrestriction.allowmodify  
fieldrestriction_allowmodify_VAL, 
 decode(fieldrestriction.allowmodify 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldrestriction_allowmodify 
, 
 fieldrestriction.thefield  
fieldrestriction_thefield_ID, 
 MTO.Func.field_BRIEF_F(fieldrestriction.thefield) 
fieldrestriction_thefield 
, 
 fieldrestriction.mandatoryfield  
fieldrestriction_mandatoryfield_VAL, 
 decode(fieldrestriction.mandatoryfield 
, -1 ,'Не существенно'
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldrestriction_mandatoryfield 
, 
 fieldrestriction.thepart  
fieldrestriction_thepart_ID, 
 MTO.Func.part_BRIEF_F(fieldrestriction.thepart) 
fieldrestriction_thepart 
, 
 fieldrestriction.allowread  
fieldrestriction_allowread_VAL, 
 decode(fieldrestriction.allowread 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldrestriction_allowread 
, objecttype.InstanceID InstanceID 
, fieldrestriction.fieldrestrictionID ID 
, 'fieldrestriction' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldrestriction
 join objectmode on objectmode.objectmodeID=fieldrestriction.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=objectmode.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotypemenu as 
select   typemenuID,objecttypeID
, 
 typemenu.the_action  
typemenu_the_action_ID, 
 MTO.Func.sharedmethod_BRIEF_F(typemenu.the_action) 
typemenu_the_action 
, 
 typemenu.istoolbarbutton  
typemenu_istoolbarbutton_VAL, 
 decode(typemenu.istoolbarbutton 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
typemenu_istoolbarbutton 
, 
typemenu.tooltip 
typemenu_tooltip 
, 
typemenu.caption 
typemenu_caption 
, 
typemenu.hotkey 
typemenu_hotkey 
, 
typemenu.name 
typemenu_name 
, 
 typemenu.ismenuitem  
typemenu_ismenuitem_VAL, 
 decode(typemenu.ismenuitem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
typemenu_ismenuitem 
, objecttype.InstanceID InstanceID 
, typemenu.typemenuID ID 
, 'typemenu' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from typemenu
 join objecttype on objecttype.objecttypeID=typemenu.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoinstancevalidator as 
select   instancevalidatorID,objecttypeID
, 
 instancevalidator.target  
instancevalidator_target_ID, 
 MTO.Func.generator_target_BRIEF_F(instancevalidator.target) 
instancevalidator_target 
, 
instancevalidator.code 
instancevalidator_code 
, objecttype.InstanceID InstanceID 
, instancevalidator.instancevalidatorID ID 
, 'instancevalidator' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from instancevalidator
 join objecttype on objecttype.objecttypeID=instancevalidator.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autopart as 
select   partID,objecttypeID
, 
 part.oncreate  
part_oncreate_ID, 
 MTO.Func.partmenu_BRIEF_F(part.oncreate) 
part_oncreate 
, 
part.name 
part_name 
, 
part.sequence 
part_sequence 
, 
 part.nolog  
part_nolog_VAL, 
 decode(part.nolog 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
part_nolog 
, 
 part.manualregister  
part_manualregister_VAL, 
 decode(part.manualregister 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
part_manualregister 
, 
 part.onsave  
part_onsave_ID, 
 MTO.Func.partmenu_BRIEF_F(part.onsave) 
part_onsave 
, 
 part.isjormalchange  
part_isjormalchange_VAL, 
 decode(part.isjormalchange 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
part_isjormalchange 
, 
 part.addbehaivor  
part_addbehaivor_VAL, 
 decode(part.addbehaivor 
, 0 ,'AddForm'
, 2 ,'RunAction'
, 1 ,'RefreshOnly'
, '???') 
part_addbehaivor 
, 
 part.extenderobject  
part_extenderobject_ID, 
 MTO.Func.INSTANCE_BRIEF_F(part.extenderobject) 
part_extenderobject 
, 
 part.usearchiving  
part_usearchiving_VAL, 
 decode(part.usearchiving 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
part_usearchiving 
, 
 part.integerpkey  
part_integerpkey_VAL, 
 decode(part.integerpkey 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
part_integerpkey 
, 
 part.ondelete  
part_ondelete_ID, 
 MTO.Func.partmenu_BRIEF_F(part.ondelete) 
part_ondelete 
, 
part.particoncls 
part_particoncls 
, 
 part.parttype  
part_parttype_VAL, 
 decode(part.parttype 
, 1 ,'Коллекция'
, 2 ,'Дерево'
, 0 ,'Строка'
, 4 ,'Расширение с данными'
, 3 ,'Расширение'
, '???') 
part_parttype 
, 
 part.onrun  
part_onrun_ID, 
 MTO.Func.partmenu_BRIEF_F(part.onrun) 
part_onrun 
, 
part.shablonbrief 
part_shablonbrief 
, 
part.the_comment 
part_the_comment 
, 
part.caption 
part_caption 
, 
part.rulebrief 
part_rulebrief 
, objecttype.InstanceID InstanceID 
, part.partID ID 
, 'part' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from part
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autopartmenu as 
select   partmenuID,partID,objecttypeID
, 
partmenu.name 
partmenu_name 
, 
partmenu.hotkey 
partmenu_hotkey 
, 
partmenu.tooltip 
partmenu_tooltip 
, 
 partmenu.istoolbarbutton  
partmenu_istoolbarbutton_VAL, 
 decode(partmenu.istoolbarbutton 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
partmenu_istoolbarbutton 
, 
 partmenu.the_action  
partmenu_the_action_ID, 
 MTO.Func.sharedmethod_BRIEF_F(partmenu.the_action) 
partmenu_the_action 
, 
 partmenu.ismenuitem  
partmenu_ismenuitem_VAL, 
 decode(partmenu.ismenuitem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
partmenu_ismenuitem 
, 
partmenu.caption 
partmenu_caption 
, objecttype.InstanceID InstanceID 
, partmenu.partmenuID ID 
, 'partmenu' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from partmenu
 join part on part.partID=partmenu.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autopartparammap as 
select   partparammapID,partmenuID,partID,objecttypeID
, 
partparammap.fieldname 
partparammap_fieldname 
, 
partparammap.paramname 
partparammap_paramname 
, 
 partparammap.noedit  
partparammap_noedit_VAL, 
 decode(partparammap.noedit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
partparammap_noedit 
, objecttype.InstanceID InstanceID 
, partparammap.partparammapID ID 
, 'partparammap' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from partparammap
 join partmenu on partmenu.partmenuID=partparammap.ParentStructRowID 
 join part on part.partID=partmenu.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autopartview as 
select   partviewID,partID,objecttypeID
, 
partview.name 
partview_name 
, 
partview.filterfield2 
partview_filterfield2 
, 
partview.filterfield1 
partview_filterfield1 
, 
 partview.forchoose  
partview_forchoose_VAL, 
 decode(partview.forchoose 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
partview_forchoose 
, 
partview.filterfield0 
partview_filterfield0 
, 
partview.the_alias 
partview_the_alias 
, 
partview.filterfield3 
partview_filterfield3 
, objecttype.InstanceID InstanceID 
, partview.partviewID ID 
, 'partview' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from partview
 join part on part.partID=partview.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoviewcolumn as 
select   viewcolumnID,partviewID,partID,objecttypeID
, 
 viewcolumn.frompart  
viewcolumn_frompart_ID, 
 MTO.Func.part_BRIEF_F(viewcolumn.frompart) 
viewcolumn_frompart 
, 
viewcolumn.the_alias 
viewcolumn_the_alias 
, 
 viewcolumn.aggregation  
viewcolumn_aggregation_VAL, 
 decode(viewcolumn.aggregation 
, 3 ,'SUM'
, 1 ,'AVG'
, 6 ,'CUSTOM'
, 0 ,'none'
, 2 ,'COUNT'
, 5 ,'MAX'
, 4 ,'MIN'
, '???') 
viewcolumn_aggregation 
, 
viewcolumn.expression 
viewcolumn_expression 
, 
 viewcolumn.forcombo  
viewcolumn_forcombo_VAL, 
 decode(viewcolumn.forcombo 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
viewcolumn_forcombo 
, 
 viewcolumn.field  
viewcolumn_field_ID, 
 MTO.Func.field_BRIEF_F(viewcolumn.field) 
viewcolumn_field 
, 
viewcolumn.name 
viewcolumn_name 
, 
viewcolumn.sequence 
viewcolumn_sequence 
, objecttype.InstanceID InstanceID 
, viewcolumn.viewcolumnID ID 
, 'viewcolumn' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from viewcolumn
 join partview on partview.partviewID=viewcolumn.ParentStructRowID 
 join part on part.partID=partview.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autopartview_lnk as 
select   partview_lnkID,partviewID,partID,objecttypeID
, 
 partview_lnk.thejoindestination  
partview_lnk_thejoindestination_ID, 
 MTO.Func.viewcolumn_BRIEF_F(partview_lnk.thejoindestination) 
partview_lnk_thejoindestination 
, 
 partview_lnk.reftype  
partview_lnk_reftype_VAL, 
 decode(partview_lnk.reftype 
, 0 ,'Нет'
, 4 ,'Связка ParentStructRowID  (в передлах объекта)'
, 3 ,'Связка InstanceID (в передлах объекта)'
, 1 ,'Ссылка на объект'
, 2 ,'Ссылка на строку'
, '???') 
partview_lnk_reftype 
, 
 partview_lnk.theview  
partview_lnk_theview_ID, 
 MTO.Func.partview_BRIEF_F(partview_lnk.theview) 
partview_lnk_theview 
, 
partview_lnk.handjoin 
partview_lnk_handjoin 
, 
partview_lnk.seq 
partview_lnk_seq 
, 
 partview_lnk.thejoinsource  
partview_lnk_thejoinsource_ID, 
 MTO.Func.viewcolumn_BRIEF_F(partview_lnk.thejoinsource) 
partview_lnk_thejoinsource 
, objecttype.InstanceID InstanceID 
, partview_lnk.partview_lnkID ID 
, 'partview_lnk' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from partview_lnk
 join partview on partview.partviewID=partview_lnk.ParentStructRowID 
 join part on part.partID=partview.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autovalidator as 
select   validatorID,partID,objecttypeID
, 
 validator.target  
validator_target_ID, 
 MTO.Func.generator_target_BRIEF_F(validator.target) 
validator_target 
, 
validator.code 
validator_code 
, objecttype.InstanceID InstanceID 
, validator.validatorID ID 
, 'validator' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from validator
 join part on part.partID=validator.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autouniqueconstraint as 
select   uniqueconstraintID,partID,objecttypeID
, 
uniqueconstraint.thecomment 
uniqueconstraint_thecomment 
, 
 uniqueconstraint.perparent  
uniqueconstraint_perparent_VAL, 
 decode(uniqueconstraint.perparent 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
uniqueconstraint_perparent 
, 
uniqueconstraint.name 
uniqueconstraint_name 
, objecttype.InstanceID InstanceID 
, uniqueconstraint.uniqueconstraintID ID 
, 'uniqueconstraint' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from uniqueconstraint
 join part on part.partID=uniqueconstraint.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoconstraintfield as 
select   constraintfieldID,uniqueconstraintID,partID,objecttypeID
, 
 constraintfield.thefield  
constraintfield_thefield_ID, 
 MTO.Func.field_BRIEF_F(constraintfield.thefield) 
constraintfield_thefield 
, objecttype.InstanceID InstanceID 
, constraintfield.constraintfieldID ID 
, 'constraintfield' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from constraintfield
 join uniqueconstraint on uniqueconstraint.uniqueconstraintID=constraintfield.ParentStructRowID 
 join part on part.partID=uniqueconstraint.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoextenderinterface as 
select   extenderinterfaceID,partID,objecttypeID
, 
extenderinterface.thename 
extenderinterface_thename 
, 
extenderinterface.theconfig 
extenderinterface_theconfig 
, 
 extenderinterface.targetplatform  
extenderinterface_targetplatform_ID, 
 MTO.Func.generator_target_BRIEF_F(extenderinterface.targetplatform) 
extenderinterface_targetplatform 
, 
extenderinterface.theobject 
extenderinterface_theobject 
, objecttype.InstanceID InstanceID 
, extenderinterface.extenderinterfaceID ID 
, 'extenderinterface' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from extenderinterface
 join part on part.partID=extenderinterface.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofield as 
select   fieldID,partID,objecttypeID
, 
field.fieldgroupbox 
field_fieldgroupbox 
, 
 field.referencetype  
field_referencetype_VAL, 
 decode(field.referencetype 
, 3 ,'На источник данных'
, 0 ,'Скалярное поле ( не ссылка)'
, 2 ,'На строку раздела'
, 1 ,'На объект '
, '???') 
field_referencetype 
, 
 field.reftotype  
field_reftotype_ID, 
 MTO.Func.objecttype_BRIEF_F(field.reftotype) 
field_reftotype 
, 
 field.istabbrief  
field_istabbrief_VAL, 
 decode(field.istabbrief 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
field_istabbrief 
, 
field.caption 
field_caption 
, 
 field.reftopart  
field_reftopart_ID, 
 MTO.Func.part_BRIEF_F(field.reftopart) 
field_reftopart 
, 
 field.isautonumber  
field_isautonumber_VAL, 
 decode(field.isautonumber 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
field_isautonumber 
, 
 field.allownull  
field_allownull_VAL, 
 decode(field.allownull 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
field_allownull 
, 
field.name 
field_name 
, 
field.thecomment 
field_thecomment 
, 
field.datasize 
field_datasize 
, 
 field.createrefonly  
field_createrefonly_VAL, 
 decode(field.createrefonly 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
field_createrefonly 
, 
field.themask 
field_themask 
, 
 field.isbrief  
field_isbrief_VAL, 
 decode(field.isbrief 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
field_isbrief 
, 
 field.numberdatefield  
field_numberdatefield_ID, 
 MTO.Func.field_BRIEF_F(field.numberdatefield) 
field_numberdatefield 
, 
 field.thenumerator  
field_thenumerator_ID, 
 MTO.Func.INSTANCE_BRIEF_F(field.thenumerator) 
field_thenumerator 
, 
field.zonetemplate 
field_zonetemplate 
, 
field.thestyle 
field_thestyle 
, 
field.thenameclass 
field_thenameclass 
, 
 field.fieldtype  
field_fieldtype_ID, 
 MTO.Func.fieldtype_BRIEF_F(field.fieldtype) 
field_fieldtype 
, 
field.sequence 
field_sequence 
, 
field.shablonbrief 
field_shablonbrief 
, 
field.tabname 
field_tabname 
, 
 field.internalreference  
field_internalreference_VAL, 
 decode(field.internalreference 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
field_internalreference 
, objecttype.InstanceID InstanceID 
, field.fieldID ID 
, 'field' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from field
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofldextenders as 
select   fldextendersID,fieldID,partID,objecttypeID
, 
fldextenders.theconfig 
fldextenders_theconfig 
, 
fldextenders.theobject 
fldextenders_theobject 
, 
 fldextenders.targetplatform  
fldextenders_targetplatform_ID, 
 MTO.Func.generator_target_BRIEF_F(fldextenders.targetplatform) 
fldextenders_targetplatform 
, 
fldextenders.thename 
fldextenders_thename 
, objecttype.InstanceID InstanceID 
, fldextenders.fldextendersID ID 
, 'fldextenders' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fldextenders
 join field on field.fieldID=fldextenders.ParentStructRowID 
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldsrcdef as 
select   fieldsrcdefID,fieldID,partID,objecttypeID
, 
fieldsrcdef.datasource 
fieldsrcdef_datasource 
, 
fieldsrcdef.descriptionstring 
fieldsrcdef_descriptionstring 
, 
fieldsrcdef.filterstring 
fieldsrcdef_filterstring 
, 
 fieldsrcdef.dontshowdialog  
fieldsrcdef_dontshowdialog_VAL, 
 decode(fieldsrcdef.dontshowdialog 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldsrcdef_dontshowdialog 
, 
fieldsrcdef.briefstring 
fieldsrcdef_briefstring 
, 
fieldsrcdef.connectionstring 
fieldsrcdef_connectionstring 
, 
fieldsrcdef.idfield 
fieldsrcdef_idfield 
, 
fieldsrcdef.provider 
fieldsrcdef_provider 
, 
fieldsrcdef.sortfield 
fieldsrcdef_sortfield 
, objecttype.InstanceID InstanceID 
, fieldsrcdef.fieldsrcdefID ID 
, 'fieldsrcdef' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldsrcdef
 join field on field.fieldID=fieldsrcdef.ParentStructRowID 
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autodinamicfilterscript as 
select   dinamicfilterscriptID,fieldID,partID,objecttypeID
, 
dinamicfilterscript.code 
dinamicfilterscript_code 
, 
 dinamicfilterscript.target  
dinamicfilterscript_target_ID, 
 MTO.Func.generator_target_BRIEF_F(dinamicfilterscript.target) 
dinamicfilterscript_target 
, objecttype.InstanceID InstanceID 
, dinamicfilterscript.dinamicfilterscriptID ID 
, 'dinamicfilterscript' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from dinamicfilterscript
 join field on field.fieldID=dinamicfilterscript.ParentStructRowID 
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldexpression as 
select   fieldexpressionID,fieldID,partID,objecttypeID
, 
fieldexpression.code 
fieldexpression_code 
, 
 fieldexpression.target  
fieldexpression_target_ID, 
 MTO.Func.generator_target_BRIEF_F(fieldexpression.target) 
fieldexpression_target 
, objecttype.InstanceID InstanceID 
, fieldexpression.fieldexpressionID ID 
, 'fieldexpression' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldexpression
 join field on field.fieldID=fieldexpression.ParentStructRowID 
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldvalidator as 
select   fieldvalidatorID,fieldID,partID,objecttypeID
, 
 fieldvalidator.target  
fieldvalidator_target_ID, 
 MTO.Func.generator_target_BRIEF_F(fieldvalidator.target) 
fieldvalidator_target 
, 
fieldvalidator.code 
fieldvalidator_code 
, objecttype.InstanceID InstanceID 
, fieldvalidator.fieldvalidatorID ID 
, 'fieldvalidator' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldvalidator
 join field on field.fieldID=fieldvalidator.ParentStructRowID 
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldmenu as 
select   fieldmenuID,fieldID,partID,objecttypeID
, 
fieldmenu.tooltip 
fieldmenu_tooltip 
, 
fieldmenu.name 
fieldmenu_name 
, 
 fieldmenu.actionid  
fieldmenu_actionid_ID, 
 MTO.Func.sharedmethod_BRIEF_F(fieldmenu.actionid) 
fieldmenu_actionid 
, 
 fieldmenu.ismenuitem  
fieldmenu_ismenuitem_VAL, 
 decode(fieldmenu.ismenuitem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldmenu_ismenuitem 
, 
 fieldmenu.istoolbarbutton  
fieldmenu_istoolbarbutton_VAL, 
 decode(fieldmenu.istoolbarbutton 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldmenu_istoolbarbutton 
, 
fieldmenu.hotkey 
fieldmenu_hotkey 
, 
fieldmenu.caption 
fieldmenu_caption 
, objecttype.InstanceID InstanceID 
, fieldmenu.fieldmenuID ID 
, 'fieldmenu' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldmenu
 join field on field.fieldID=fieldmenu.ParentStructRowID 
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofieldparammap as 
select   fieldparammapID,fieldmenuID,fieldID,partID,objecttypeID
, 
fieldparammap.fieldname 
fieldparammap_fieldname 
, 
 fieldparammap.noedit  
fieldparammap_noedit_VAL, 
 decode(fieldparammap.noedit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fieldparammap_noedit 
, 
fieldparammap.paramname 
fieldparammap_paramname 
, objecttype.InstanceID InstanceID 
, fieldparammap.fieldparammapID ID 
, 'fieldparammap' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fieldparammap
 join fieldmenu on fieldmenu.fieldmenuID=fieldparammap.ParentStructRowID 
 join field on field.fieldID=fieldmenu.ParentStructRowID 
 join part on part.partID=field.ParentStructRowID 
 join objecttype on objecttype.objecttypeID=part.ParentStructRowID 
 join INSTANCE on objecttype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_automtzapp as 
select   mtzappID
, 
mtzapp.thecomment 
mtzapp_thecomment 
, 
mtzapp.name 
mtzapp_name 
, 
mtzapp.dbname 
mtzapp_dbname 
, mtzapp.InstanceID InstanceID 
, mtzapp.mtzappID ID 
, 'mtzapp' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from mtzapp
 join INSTANCE on mtzapp.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoparentpackage as 
select   parentpackageID,mtzappID
, 
 parentpackage.package  
parentpackage_package_ID, 
 MTO.Func.mtzapp_BRIEF_F(parentpackage.package) 
parentpackage_package 
, mtzapp.InstanceID InstanceID 
, parentpackage.parentpackageID ID 
, 'parentpackage' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from parentpackage
 join mtzapp on mtzapp.mtzappID=parentpackage.ParentStructRowID 
 join INSTANCE on mtzapp.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autojournalcolumn as 
select   journalcolumnID
, 
 journalcolumn.groupaggregation  
journalcolumn_groupaggregation_VAL, 
 decode(journalcolumn.groupaggregation 
, 3 ,'SUM'
, 1 ,'AVG'
, 6 ,'CUSTOM'
, 0 ,'none'
, 2 ,'COUNT'
, 5 ,'MAX'
, 4 ,'MIN'
, '???') 
journalcolumn_groupaggregation 
, 
 journalcolumn.columnalignment  
journalcolumn_columnalignment_VAL, 
 decode(journalcolumn.columnalignment 
, 6 ,'Right Top'
, 7 ,'Right Center'
, 8 ,'Right Bottom'
, 3 ,'Center Top'
, 0 ,'Left Top'
, 4 ,'Center Center'
, 1 ,'Left Center'
, 5 ,'Center Bottom'
, 2 ,'Left Bottom'
, '???') 
journalcolumn_columnalignment 
, 
 journalcolumn.colsort  
journalcolumn_colsort_VAL, 
 decode(journalcolumn.colsort 
, 0 ,'As String'
, 1 ,'As Numeric'
, 2 ,'As Date'
, '???') 
journalcolumn_colsort 
, 
journalcolumn.sequence 
journalcolumn_sequence 
, 
journalcolumn.name 
journalcolumn_name 
, journalcolumn.InstanceID InstanceID 
, journalcolumn.journalcolumnID ID 
, 'journalcolumn' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from journalcolumn
 join INSTANCE on journalcolumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autojcolumnsource as 
select   jcolumnsourceID,journalcolumnID
, 
 jcolumnsource.srcpartview  
jcolumnsource_srcpartview_ID, 
 MTO.Func.journalsrc_BRIEF_F(jcolumnsource.srcpartview) 
jcolumnsource_srcpartview 
, 
jcolumnsource.viewfield 
jcolumnsource_viewfield 
, journalcolumn.InstanceID InstanceID 
, jcolumnsource.jcolumnsourceID ID 
, 'jcolumnsource' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from jcolumnsource
 join journalcolumn on journalcolumn.journalcolumnID=jcolumnsource.ParentStructRowID 
 join INSTANCE on journalcolumn.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autojournalsrc as 
select   journalsrcID
, 
journalsrc.openmode 
journalsrc_openmode 
, 
journalsrc.spartview 
journalsrc_spartview 
, 
 journalsrc.onrun  
journalsrc_onrun_VAL, 
 decode(journalsrc.onrun 
, 2 ,'Открыть документ'
, 0 ,'Ничего не делать'
, 1 ,'Открыть строку'
, '???') 
journalsrc_onrun 
, 
journalsrc.viewalias 
journalsrc_viewalias 
, journalsrc.InstanceID InstanceID 
, journalsrc.journalsrcID ID 
, 'journalsrc' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from journalsrc
 join INSTANCE on journalsrc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autojournal as 
select   journalID
, 
journal.the_alias 
journal_the_alias 
, 
 journal.usefavorites  
journal_usefavorites_VAL, 
 decode(journal.usefavorites 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
journal_usefavorites 
, 
journal.jrnliconcls 
journal_jrnliconcls 
, 
journal.name 
journal_name 
, 
journal.thecomment 
journal_thecomment 
, journal.InstanceID InstanceID 
, journal.journalID ID 
, 'journal' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from journal
 join INSTANCE on journal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_factory as 
select   tod_factoryID
, 
tod_factory.name 
tod_factory_name 
, tod_factory.InstanceID InstanceID 
, tod_factory.tod_factoryID ID 
, 'tod_factory' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_factory
 join INSTANCE on tod_factory.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_bug as 
select   tod_bugID
, 
 tod_bug.the_system  
tod_bug_the_system_ID, 
 MTO.Func.tod_system_BRIEF_F(tod_bug.the_system) 
tod_bug_the_system 
, 
tod_bug.name 
tod_bug_name 
, 
tod_bug.the_comment 
tod_bug_the_comment 
, tod_bug.InstanceID InstanceID 
, tod_bug.tod_bugID ID 
, 'tod_bug' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_bug
 join INSTANCE on tod_bug.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_building as 
select   tod_buildingID
, 
 tod_building.thefactory  
tod_building_thefactory_ID, 
 MTO.Func.tod_factory_BRIEF_F(tod_building.thefactory) 
tod_building_thefactory 
, 
tod_building.name 
tod_building_name 
, tod_building.InstanceID InstanceID 
, tod_building.tod_buildingID ID 
, 'tod_building' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_building
 join INSTANCE on tod_building.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_valtype as 
select   tod_valtypeID
, 
tod_valtype.name 
tod_valtype_name 
, 
 tod_valtype.fieldtype  
tod_valtype_fieldtype_ID, 
 MTO.Func.fieldtype_BRIEF_F(tod_valtype.fieldtype) 
tod_valtype_fieldtype 
, 
 tod_valtype.edizm  
tod_valtype_edizm_ID, 
 MTO.Func.tod_edizm_BRIEF_F(tod_valtype.edizm) 
tod_valtype_edizm 
, tod_valtype.InstanceID InstanceID 
, tod_valtype.tod_valtypeID ID 
, 'tod_valtype' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_valtype
 join INSTANCE on tod_valtype.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_model as 
select   tod_modelID
, 
tod_model.name 
tod_model_name 
, tod_model.InstanceID InstanceID 
, tod_model.tod_modelID ID 
, 'tod_model' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_model
 join INSTANCE on tod_model.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_system as 
select   tod_systemID
, 
tod_system.name 
tod_system_name 
, tod_system.InstanceID InstanceID 
, tod_system.tod_systemID ID 
, 'tod_system' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_system
 join INSTANCE on tod_system.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_oprole as 
select   tod_oproleID
, 
tod_oprole.docmode 
tod_oprole_docmode 
, 
tod_oprole.name 
tod_oprole_name 
, tod_oprole.InstanceID InstanceID 
, tod_oprole.tod_oproleID ID 
, 'tod_oprole' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_oprole
 join INSTANCE on tod_oprole.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_trand as 
select   tod_trandID
, 
tod_trand.name 
tod_trand_name 
, tod_trand.InstanceID InstanceID 
, tod_trand.tod_trandID ID 
, 'tod_trand' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_trand
 join INSTANCE on tod_trand.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_st as 
select   tod_stID
, 
 tod_st.the_model  
tod_st_the_model_ID, 
 MTO.Func.tod_model_BRIEF_F(tod_st.the_model) 
tod_st_the_model 
, 
tod_st.name 
tod_st_name 
, 
tod_st.invn 
tod_st_invn 
, 
 tod_st.thebuilding  
tod_st_thebuilding_ID, 
 MTO.Func.tod_building_BRIEF_F(tod_st.thebuilding) 
tod_st_thebuilding 
, tod_st.InstanceID InstanceID 
, tod_st.tod_stID ID 
, 'tod_st' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_st
 join INSTANCE on tod_st.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_material as 
select   tod_materialID
, 
tod_material.name 
tod_material_name 
, tod_material.InstanceID InstanceID 
, tod_material.tod_materialID ID 
, 'tod_material' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_material
 join INSTANCE on tod_material.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotod_edizm as 
select   tod_edizmID
, 
tod_edizm.fullname 
tod_edizm_fullname 
, 
tod_edizm.name 
tod_edizm_name 
, tod_edizm.InstanceID InstanceID 
, tod_edizm.tod_edizmID ID 
, 'tod_edizm' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tod_edizm
 join INSTANCE on tod_edizm.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofolder as 
select   folderID
, 
folder.name 
folder_name 
, 
 folder.foldertype  
folder_foldertype_VAL, 
 decode(folder.foldertype 
, 3 ,'Удаленные'
, 1 ,'Входящие'
, 9 ,'Отложенные'
, 4 ,'Журнал'
, 2 ,'Исходящие'
, 7 ,'Черновики'
, 6 ,'Отправленные'
, 8 ,'В работе'
, 5 ,'Календарь'
, 10 ,'Завершенные'
, 0 ,'cls__'
, '???') 
folder_foldertype 
, folder.InstanceID InstanceID 
, folder.folderID ID 
, 'folder' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from folder
 join INSTANCE on folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoshortcut as 
select   shortcutID,folderID
, 
shortcut.startmode 
shortcut_startmode 
, 
 shortcut.docitem  
shortcut_docitem_ID, 
 MTO.Func.INSTANCE_BRIEF_F(shortcut.docitem) 
shortcut_docitem 
, folder.InstanceID InstanceID 
, shortcut.shortcutID ID 
, 'shortcut' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from shortcut
 join folder on folder.folderID=shortcut.ParentStructRowID 
 join INSTANCE on folder.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoinfostoredef as 
select   infostoredefID
, 
 infostoredef.theuser  
infostoredef_theuser_ID, 
 MTO.Func.users_BRIEF_F(infostoredef.theuser) 
infostoredef_theuser 
, 
infostoredef.name 
infostoredef_name 
, 
 infostoredef.infostoretype  
infostoredef_infostoretype_VAL, 
 decode(infostoredef.infostoretype 
, 2 ,'Групповой'
, 0 ,' Общий'
, 1 ,'Персональный'
, '???') 
infostoredef_infostoretype 
, 
 infostoredef.thegroup  
infostoredef_thegroup_ID, 
 MTO.Func.groups_BRIEF_F(infostoredef.thegroup) 
infostoredef_thegroup 
, infostoredef.InstanceID InstanceID 
, infostoredef.infostoredefID ID 
, 'infostoredef' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from infostoredef
 join INSTANCE on infostoredef.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autothe_session as 
select   the_sessionID
, 
 the_session.applicationid  
the_session_applicationid_ID, 
 MTO.Func.workplace_BRIEF_F(the_session.applicationid) 
the_session_applicationid 
, 
 the_session.closed  
the_session_closed_VAL, 
 decode(the_session.closed 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
the_session_closed 
, 
 the_session.userrole  
the_session_userrole_ID, 
 MTO.Func.groups_BRIEF_F(the_session.userrole) 
the_session_userrole 
, 
 the_session.usersid  
the_session_usersid_ID, 
 MTO.Func.users_BRIEF_F(the_session.usersid) 
the_session_usersid 
, 
the_session.login 
the_session_login 
, 
the_session.lang 
the_session_lang 
, 
the_session.lastaccess 
the_session_lastaccess 
, 
the_session.closedat 
the_session_closedat 
, 
the_session.startat 
the_session_startat 
, the_session.InstanceID InstanceID 
, the_session.the_sessionID ID 
, 'the_session' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from the_session
 join INSTANCE on the_session.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autosysrefcache as 
select   sysrefcacheID
, 
 sysrefcache.cachetype  
sysrefcache_cachetype_VAL, 
 decode(sysrefcache.cachetype 
, 2 ,'Все'
, 0 ,'Только свои'
, 1 ,'Подчиненные'
, '???') 
sysrefcache_cachetype 
, 
sysrefcache.modulename 
sysrefcache_modulename 
, 
 sysrefcache.sessionid  
sysrefcache_sessionid_ID, 
 MTO.Func.the_session_BRIEF_F(sysrefcache.sessionid) 
sysrefcache_sessionid 
, 
sysrefcache.objectownerid 
sysrefcache_objectownerid 
, sysrefcache.InstanceID InstanceID 
, sysrefcache.sysrefcacheID ID 
, 'sysrefcache' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from sysrefcache
 join INSTANCE on sysrefcache.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autosyslog as 
select   syslogID
, 
syslog.logstructid 
syslog_logstructid 
, 
syslog.verb 
syslog_verb 
, 
syslog.the_resource 
syslog_the_resource 
, 
syslog.loginstanceid 
syslog_loginstanceid 
, 
 syslog.thesession  
syslog_thesession_ID, 
 MTO.Func.the_session_BRIEF_F(syslog.thesession) 
syslog_thesession 
, syslog.InstanceID InstanceID 
, syslog.syslogID ID 
, 'syslog' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from syslog
 join INSTANCE on syslog.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoarmjournal as 
select   armjournalID
, 
 armjournal.thejournal  
armjournal_thejournal_ID, 
 MTO.Func.INSTANCE_BRIEF_F(armjournal.thejournal) 
armjournal_thejournal 
, armjournal.InstanceID InstanceID 
, armjournal.armjournalID ID 
, 'armjournal' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from armjournal
 join INSTANCE on armjournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoarmjrnlrep as 
select   armjrnlrepID,armjournalID
, 
armjrnlrep.repname 
armjrnlrep_repname 
, 
 armjrnlrep.thereport  
armjrnlrep_thereport_ID, 
 MTO.Func.INSTANCE_BRIEF_F(armjrnlrep.thereport) 
armjrnlrep_thereport 
, armjournal.InstanceID InstanceID 
, armjrnlrep.armjrnlrepID ID 
, 'armjrnlrep' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from armjrnlrep
 join armjournal on armjournal.armjournalID=armjrnlrep.ParentStructRowID 
 join INSTANCE on armjournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoarmjrnlrun as 
select   armjrnlrunID,armjournalID
, 
 armjrnlrun.theextention  
armjrnlrun_theextention_ID, 
 MTO.Func.INSTANCE_BRIEF_F(armjrnlrun.theextention) 
armjrnlrun_theextention 
, 
armjrnlrun.name 
armjrnlrun_name 
, armjournal.InstanceID InstanceID 
, armjrnlrun.armjrnlrunID ID 
, 'armjrnlrun' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from armjrnlrun
 join armjournal on armjournal.armjournalID=armjrnlrun.ParentStructRowID 
 join INSTANCE on armjournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoarmjrnladd as 
select   armjrnladdID,armjournalID
, 
armjrnladd.name 
armjrnladd_name 
, 
 armjrnladd.theextention  
armjrnladd_theextention_ID, 
 MTO.Func.INSTANCE_BRIEF_F(armjrnladd.theextention) 
armjrnladd_theextention 
, armjournal.InstanceID InstanceID 
, armjrnladd.armjrnladdID ID 
, 'armjrnladd' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from armjrnladd
 join armjournal on armjournal.armjournalID=armjrnladd.ParentStructRowID 
 join INSTANCE on armjournal.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoentrypoints as 
select   entrypointsID
, 
 entrypoints.allowprint  
entrypoints_allowprint_VAL, 
 decode(entrypoints.allowprint 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
entrypoints_allowprint 
, 
 entrypoints.report  
entrypoints_report_ID, 
 MTO.Func.INSTANCE_BRIEF_F(entrypoints.report) 
entrypoints_report 
, 
 entrypoints.actiontype  
entrypoints_actiontype_VAL, 
 decode(entrypoints.actiontype 
, 4 ,'Запустить АРМ'
, 2 ,'Выполнить метод'
, 5 ,'Открыть отчет'
, 0 ,'Ничего не делать'
, 1 ,'Открыть документ'
, 3 ,'Открыть журнал'
, '???') 
entrypoints_actiontype 
, 
 entrypoints.document  
entrypoints_document_ID, 
 MTO.Func.INSTANCE_BRIEF_F(entrypoints.document) 
entrypoints_document 
, 
entrypoints.journalfixedquery 
entrypoints_journalfixedquery 
, 
entrypoints.name 
entrypoints_name 
, 
 entrypoints.thefilter  
entrypoints_thefilter_ID, 
 MTO.Func.INSTANCE_BRIEF_F(entrypoints.thefilter) 
entrypoints_thefilter 
, 
 entrypoints.allowdel  
entrypoints_allowdel_VAL, 
 decode(entrypoints.allowdel 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
entrypoints_allowdel 
, 
 entrypoints.allowadd  
entrypoints_allowadd_VAL, 
 decode(entrypoints.allowadd 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
entrypoints_allowadd 
, 
 entrypoints.astoolbaritem  
entrypoints_astoolbaritem_VAL, 
 decode(entrypoints.astoolbaritem 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
entrypoints_astoolbaritem 
, 
 entrypoints.allowedit  
entrypoints_allowedit_VAL, 
 decode(entrypoints.allowedit 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
entrypoints_allowedit 
, 
entrypoints.caption 
entrypoints_caption 
, 
entrypoints.thecomment 
entrypoints_thecomment 
, 
 entrypoints.journal  
entrypoints_journal_ID, 
 MTO.Func.INSTANCE_BRIEF_F(entrypoints.journal) 
entrypoints_journal 
, 
 entrypoints.objecttype  
entrypoints_objecttype_ID, 
 MTO.Func.objecttype_BRIEF_F(entrypoints.objecttype) 
entrypoints_objecttype 
, 
 entrypoints.allowfilter  
entrypoints_allowfilter_VAL, 
 decode(entrypoints.allowfilter 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
entrypoints_allowfilter 
, 
 entrypoints.method  
entrypoints_method_ID, 
 MTO.Func.sharedmethod_BRIEF_F(entrypoints.method) 
entrypoints_method 
, 
entrypoints.iconfile 
entrypoints_iconfile 
, 
entrypoints.sequence 
entrypoints_sequence 
, 
 entrypoints.arm  
entrypoints_arm_ID, 
 MTO.Func.INSTANCE_BRIEF_F(entrypoints.arm) 
entrypoints_arm 
, 
 entrypoints.theextention  
entrypoints_theextention_ID, 
 MTO.Func.INSTANCE_BRIEF_F(entrypoints.theextention) 
entrypoints_theextention 
, entrypoints.InstanceID InstanceID 
, entrypoints.entrypointsID ID 
, 'entrypoints' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from entrypoints
 join INSTANCE on entrypoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoepfilterlink as 
select   epfilterlinkID,entrypointsID
, 
epfilterlink.rowsource 
epfilterlink_rowsource 
, 
epfilterlink.theexpression 
epfilterlink_theexpression 
, 
epfilterlink.filterfield 
epfilterlink_filterfield 
, entrypoints.InstanceID InstanceID 
, epfilterlink.epfilterlinkID ID 
, 'epfilterlink' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from epfilterlink
 join entrypoints on entrypoints.entrypointsID=epfilterlink.ParentStructRowID 
 join INSTANCE on entrypoints.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoworkplace as 
select   workplaceID
, 
workplace.thecomment 
workplace_thecomment 
, 
 workplace.theplatform  
workplace_theplatform_VAL, 
 decode(workplace.theplatform 
, 3 ,'OTHER'
, 1 ,'DOTNET'
, 2 ,'JAVA'
, 0 ,'VB6'
, '???') 
workplace_theplatform 
, 
workplace.caption 
workplace_caption 
, 
workplace.name 
workplace_name 
, 
workplace.theversion 
workplace_theversion 
, workplace.InstanceID InstanceID 
, workplace.workplaceID ID 
, 'workplace' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from workplace
 join INSTANCE on workplace.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoarmtypes as 
select   armtypesID
, 
 armtypes.thedocumenttype  
armtypes_thedocumenttype_ID, 
 MTO.Func.objecttype_BRIEF_F(armtypes.thedocumenttype) 
armtypes_thedocumenttype 
, armtypes.InstanceID InstanceID 
, armtypes.armtypesID ID 
, 'armtypes' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from armtypes
 join INSTANCE on armtypes.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_operations as 
select   roles_operationsID
, 
roles_operations.info 
roles_operations_info 
, 
 roles_operations.allowaction  
roles_operations_allowaction_VAL, 
 decode(roles_operations.allowaction 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_operations_allowaction 
, 
roles_operations.name 
roles_operations_name 
, roles_operations.InstanceID InstanceID 
, roles_operations.roles_operationsID ID 
, 'roles_operations' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_operations
 join INSTANCE on roles_operations.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_wp as 
select   roles_wpID
, 
 roles_wp.wp  
roles_wp_wp_ID, 
 MTO.Func.workplace_BRIEF_F(roles_wp.wp) 
roles_wp_wp 
, roles_wp.InstanceID InstanceID 
, roles_wp.roles_wpID ID 
, 'roles_wp' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_wp
 join INSTANCE on roles_wp.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_act as 
select   roles_actID,roles_wpID
, 
roles_act.menuname 
roles_act_menuname 
, 
roles_act.menucode 
roles_act_menucode 
, 
 roles_act.accesible  
roles_act_accesible_VAL, 
 decode(roles_act.accesible 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_act_accesible 
, roles_wp.InstanceID InstanceID 
, roles_act.roles_actID ID 
, 'roles_act' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_act
 join roles_wp on roles_wp.roles_wpID=roles_act.ParentStructRowID 
 join INSTANCE on roles_wp.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles2_module as 
select   roles2_moduleID
, 
 roles2_module.moduleaccessible  
roles2_module_moduleaccessible_VAL, 
 decode(roles2_module.moduleaccessible 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles2_module_moduleaccessible 
, 
roles2_module.groupname 
roles2_module_groupname 
, 
 roles2_module.customizevisibility  
roles2_module_customizevisibility_VAL, 
 decode(roles2_module.customizevisibility 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles2_module_customizevisibility 
, 
 roles2_module.colegsobject  
roles2_module_colegsobject_VAL, 
 decode(roles2_module.colegsobject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles2_module_colegsobject 
, 
 roles2_module.substructobjects  
roles2_module_substructobjects_VAL, 
 decode(roles2_module.substructobjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles2_module_substructobjects 
, 
roles2_module.caption 
roles2_module_caption 
, 
roles2_module.name 
roles2_module_name 
, 
roles2_module.sequence 
roles2_module_sequence 
, 
 roles2_module.allobjects  
roles2_module_allobjects_VAL, 
 decode(roles2_module.allobjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles2_module_allobjects 
, 
roles2_module.thecomment 
roles2_module_thecomment 
, 
roles2_module.theicon 
roles2_module_theicon 
, roles2_module.InstanceID InstanceID 
, roles2_module.roles2_moduleID ID 
, 'roles2_module' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles2_module
 join INSTANCE on roles2_module.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles2_modreport as 
select   roles2_modreportID,roles2_moduleID
, 
roles2_modreport.selecttype 
roles2_modreport_selecttype 
, 
roles2_modreport.name 
roles2_modreport_name 
, 
 roles2_modreport.allowaction  
roles2_modreport_allowaction_VAL, 
 decode(roles2_modreport.allowaction 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles2_modreport_allowaction 
, 
roles2_modreport.sequence 
roles2_modreport_sequence 
, 
 roles2_modreport.isreport  
roles2_modreport_isreport_VAL, 
 decode(roles2_modreport.isreport 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles2_modreport_isreport 
, 
roles2_modreport.caption 
roles2_modreport_caption 
, 
roles2_modreport.theicon 
roles2_modreport_theicon 
, roles2_module.InstanceID InstanceID 
, roles2_modreport.roles2_modreportID ID 
, 'roles2_modreport' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles2_modreport
 join roles2_module on roles2_module.roles2_moduleID=roles2_modreport.ParentStructRowID 
 join INSTANCE on roles2_module.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_doc as 
select   roles_docID
, 
 roles_doc.allowdeletedoc  
roles_doc_allowdeletedoc_VAL, 
 decode(roles_doc.allowdeletedoc 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_doc_allowdeletedoc 
, 
 roles_doc.the_denied  
roles_doc_the_denied_VAL, 
 decode(roles_doc.the_denied 
, 1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_doc_the_denied 
, 
 roles_doc.the_document  
roles_doc_the_document_ID, 
 MTO.Func.objecttype_BRIEF_F(roles_doc.the_document) 
roles_doc_the_document 
, roles_doc.InstanceID InstanceID 
, roles_doc.roles_docID ID 
, 'roles_doc' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_doc
 join INSTANCE on roles_doc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_doc_state as 
select   roles_doc_stateID,roles_docID
, 
 roles_doc_state.the_mode  
roles_doc_state_the_mode_ID, 
 MTO.Func.objectmode_BRIEF_F(roles_doc_state.the_mode) 
roles_doc_state_the_mode 
, 
 roles_doc_state.allowdelete  
roles_doc_state_allowdelete_VAL, 
 decode(roles_doc_state.allowdelete 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_doc_state_allowdelete 
, 
 roles_doc_state.statechangedisabled  
roles_doc_state_statechangedisabled_VAL, 
 decode(roles_doc_state.statechangedisabled 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_doc_state_statechangedisabled 
, 
 roles_doc_state.the_state  
roles_doc_state_the_state_ID, 
 MTO.Func.objstatus_BRIEF_F(roles_doc_state.the_state) 
roles_doc_state_the_state 
, roles_doc.InstanceID InstanceID 
, roles_doc_state.roles_doc_stateID ID 
, 'roles_doc_state' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_doc_state
 join roles_doc on roles_doc.roles_docID=roles_doc_state.ParentStructRowID 
 join INSTANCE on roles_doc.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_reports as 
select   roles_reportsID
, 
 roles_reports.the_report  
roles_reports_the_report_ID, 
 MTO.Func.INSTANCE_BRIEF_F(roles_reports.the_report) 
roles_reports_the_report 
, roles_reports.InstanceID InstanceID 
, roles_reports.roles_reportsID ID 
, 'roles_reports' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_reports
 join INSTANCE on roles_reports.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_user as 
select   roles_userID
, 
 roles_user.theuser  
roles_user_theuser_ID, 
 MTO.Func.users_BRIEF_F(roles_user.theuser) 
roles_user_theuser 
, roles_user.InstanceID InstanceID 
, roles_user.roles_userID ID 
, 'roles_user' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_user
 join INSTANCE on roles_user.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_map as 
select   roles_mapID
, 
 roles_map.thegroup  
roles_map_thegroup_ID, 
 MTO.Func.groups_BRIEF_F(roles_map.thegroup) 
roles_map_thegroup 
, roles_map.InstanceID InstanceID 
, roles_map.roles_mapID ID 
, 'roles_map' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_map
 join INSTANCE on roles_map.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoroles_def as 
select   roles_defID
, 
roles_def.name 
roles_def_name 
, 
 roles_def.colegsobject  
roles_def_colegsobject_VAL, 
 decode(roles_def.colegsobject 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_def_colegsobject 
, 
 roles_def.allobjects  
roles_def_allobjects_VAL, 
 decode(roles_def.allobjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_def_allobjects 
, 
 roles_def.substructobjects  
roles_def_substructobjects_VAL, 
 decode(roles_def.substructobjects 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
roles_def_substructobjects 
, roles_def.InstanceID InstanceID 
, roles_def.roles_defID ID 
, 'roles_def' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from roles_def
 join INSTANCE on roles_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_scheditems as 
select   to_scheditemsID
, 
to_scheditems.finishdate 
to_scheditems_finishdate 
, 
 to_scheditems.oper  
to_scheditems_oper_ID, 
 MTO.Func.to_oper_BRIEF_F(to_scheditems.oper) 
to_scheditems_oper 
, 
to_scheditems.checkin 
to_scheditems_checkin 
, 
 to_scheditems.themachine  
to_scheditems_themachine_ID, 
 MTO.Func.tod_st_BRIEF_F(to_scheditems.themachine) 
to_scheditems_themachine 
, 
 to_scheditems.isdone  
to_scheditems_isdone_VAL, 
 decode(to_scheditems.isdone 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
to_scheditems_isdone 
, 
to_scheditems.todate 
to_scheditems_todate 
, to_scheditems.InstanceID InstanceID 
, to_scheditems.to_scheditemsID ID 
, 'to_scheditems' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_scheditems
 join INSTANCE on to_scheditems.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_schedinfo as 
select   to_schedinfoID
, 
to_schedinfo.dto 
to_schedinfo_dto 
, 
to_schedinfo.dfrom 
to_schedinfo_dfrom 
, to_schedinfo.InstanceID InstanceID 
, to_schedinfo.to_schedinfoID ID 
, 'to_schedinfo' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_schedinfo
 join INSTANCE on to_schedinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autototrn_data as 
select   totrn_dataID
, 
totrn_data.time_label 
totrn_data_time_label 
, 
totrn_data.thevalue 
totrn_data_thevalue 
, totrn_data.InstanceID InstanceID 
, totrn_data.totrn_dataID ID 
, 'totrn_data' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from totrn_data
 join INSTANCE on totrn_data.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autototrn_def as 
select   totrn_defID
, 
totrn_def.bottomval 
totrn_def_bottomval 
, 
 totrn_def.trandtype  
totrn_def_trandtype_ID, 
 MTO.Func.tod_trand_BRIEF_F(totrn_def.trandtype) 
totrn_def_trandtype 
, 
totrn_def.topvalue 
totrn_def_topvalue 
, 
 totrn_def.themachine  
totrn_def_themachine_ID, 
 MTO.Func.tod_st_BRIEF_F(totrn_def.themachine) 
totrn_def_themachine 
, totrn_def.InstanceID InstanceID 
, totrn_def.totrn_defID ID 
, 'totrn_def' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from totrn_def
 join INSTANCE on totrn_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_AUTOto_taskcomment as 
select   to_taskcommentID
, 
 to_taskcomment.codetocomment  
to_taskcomment_codetocomment_ID, 
 MTO.Func.tod_system_BRIEF_F(to_taskcomment.codetocomment) 
to_taskcomment_codetocomment 
, 
 to_taskcomment.the_operator  
to_taskcomment_the_operator_ID, 
 MTO.Func.to_oper_BRIEF_F(to_taskcomment.the_operator) 
to_taskcomment_the_operator 
, 
to_taskcomment.the_date 
to_taskcomment_the_date 
, 
to_taskcomment.thecomment 
to_taskcomment_thecomment 
, to_taskcomment.InstanceID InstanceID 
, to_taskcomment.to_taskcommentID ID 
, 'to_taskcomment' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskcomment
 join INSTANCE on to_taskcomment.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_taskcomment as 
select   to_taskcommentID
, 
to_taskcomment.the_date 
to_taskcomment_the_date 
, 
to_taskcomment.thecomment 
to_taskcomment_thecomment 
, 
 to_taskcomment.codetocomment  
to_taskcomment_codetocomment_ID, 
 MTO.Func.tod_system_BRIEF_F(to_taskcomment.codetocomment) 
to_taskcomment_codetocomment 
, 
 to_taskcomment.the_operator  
to_taskcomment_the_operator_ID, 
 MTO.Func.to_oper_BRIEF_F(to_taskcomment.the_operator) 
to_taskcomment_the_operator 
, to_taskcomment.InstanceID InstanceID 
, to_taskcomment.to_taskcommentID ID 
, 'to_taskcomment' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskcomment
 join INSTANCE on to_taskcomment.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_taskinfo as 
select   to_taskinfoID
, 
 to_taskinfo.oper  
to_taskinfo_oper_ID, 
 MTO.Func.to_oper_BRIEF_F(to_taskinfo.oper) 
to_taskinfo_oper 
, 
 to_taskinfo.thecard  
to_taskinfo_thecard_ID, 
 MTO.Func.to_cardinfo_BRIEF_F(to_taskinfo.thecard) 
to_taskinfo_thecard 
, 
to_taskinfo.crdate 
to_taskinfo_crdate 
, 
to_taskinfo.finishtime 
to_taskinfo_finishtime 
, 
 to_taskinfo.taskfinished  
to_taskinfo_taskfinished_VAL, 
 decode(to_taskinfo.taskfinished 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
to_taskinfo_taskfinished 
, 
 to_taskinfo.themachine  
to_taskinfo_themachine_ID, 
 MTO.Func.to_scheditems_BRIEF_F(to_taskinfo.themachine) 
to_taskinfo_themachine 
, to_taskinfo.InstanceID InstanceID 
, to_taskinfo.to_taskinfoID ID 
, 'to_taskinfo' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskinfo
 join INSTANCE on to_taskinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_taskinfo as 
select   to_taskinfoID
, 
to_taskinfo.finishtime 
to_taskinfo_finishtime 
, 
 to_taskinfo.thecard  
to_taskinfo_thecard_ID, 
 MTO.Func.to_cardinfo_BRIEF_F(to_taskinfo.thecard) 
to_taskinfo_thecard 
, 
to_taskinfo.crdate 
to_taskinfo_crdate 
, 
 to_taskinfo.themachine  
to_taskinfo_themachine_ID, 
 MTO.Func.to_scheditems_BRIEF_F(to_taskinfo.themachine) 
to_taskinfo_themachine 
, 
 to_taskinfo.taskfinished  
to_taskinfo_taskfinished_VAL, 
 decode(to_taskinfo.taskfinished 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
to_taskinfo_taskfinished 
, 
 to_taskinfo.oper  
to_taskinfo_oper_ID, 
 MTO.Func.to_oper_BRIEF_F(to_taskinfo.oper) 
to_taskinfo_oper 
, to_taskinfo.InstanceID InstanceID 
, to_taskinfo.to_taskinfoID ID 
, 'to_taskinfo' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskinfo
 join INSTANCE on to_taskinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_taskchecks as 
select   to_taskchecksID
, 
to_taskchecks.the_check 
to_taskchecks_the_check 
, 
 to_taskchecks.the_system  
to_taskchecks_the_system_ID, 
 MTO.Func.tod_system_BRIEF_F(to_taskchecks.the_system) 
to_taskchecks_the_system 
, 
to_taskchecks.tagtime 
to_taskchecks_tagtime 
, 
to_taskchecks.thevalue 
to_taskchecks_thevalue 
, 
to_taskchecks.tagid 
to_taskchecks_tagid 
, 
 to_taskchecks.checkref  
to_taskchecks_checkref_ID, 
 MTO.Func.to_cardchecks_BRIEF_F(to_taskchecks.checkref) 
to_taskchecks_checkref 
, 
to_taskchecks.normochas 
to_taskchecks_normochas 
, 
to_taskchecks.lowvalue 
to_taskchecks_lowvalue 
, 
to_taskchecks.the_comment 
to_taskchecks_the_comment 
, 
to_taskchecks.hivalue 
to_taskchecks_hivalue 
, 
 to_taskchecks.valuetype  
to_taskchecks_valuetype_ID, 
 MTO.Func.tod_valtype_BRIEF_F(to_taskchecks.valuetype) 
to_taskchecks_valuetype 
, 
to_taskchecks.the_doc 
to_taskchecks_the_doc 
, to_taskchecks.InstanceID InstanceID 
, to_taskchecks.to_taskchecksID ID 
, 'to_taskchecks' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskchecks
 join INSTANCE on to_taskchecks.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_taskchecks as 
select   to_taskchecksID
, 
to_taskchecks.tagtime 
to_taskchecks_tagtime 
, 
to_taskchecks.thesubsystem 
to_taskchecks_thesubsystem 
, 
to_taskchecks.hivalue 
to_taskchecks_hivalue 
, 
 to_taskchecks.valuetype  
to_taskchecks_valuetype_ID, 
 MTO.Func.tod_valtype_BRIEF_F(to_taskchecks.valuetype) 
to_taskchecks_valuetype 
, 
to_taskchecks.lowvalue 
to_taskchecks_lowvalue 
, 
to_taskchecks.the_check 
to_taskchecks_the_check 
, 
to_taskchecks.the_comment 
to_taskchecks_the_comment 
, 
to_taskchecks.normochas 
to_taskchecks_normochas 
, 
 to_taskchecks.checkref  
to_taskchecks_checkref_ID, 
 MTO.Func.to_cardchecks_BRIEF_F(to_taskchecks.checkref) 
to_taskchecks_checkref 
, 
to_taskchecks.tagid 
to_taskchecks_tagid 
, 
to_taskchecks.thevalue 
to_taskchecks_thevalue 
, 
 to_taskchecks.the_system  
to_taskchecks_the_system_ID, 
 MTO.Func.tod_system_BRIEF_F(to_taskchecks.the_system) 
to_taskchecks_the_system 
, 
to_taskchecks.the_doc 
to_taskchecks_the_doc 
, to_taskchecks.InstanceID InstanceID 
, to_taskchecks.to_taskchecksID ID 
, 'to_taskchecks' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskchecks
 join INSTANCE on to_taskchecks.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_taskcheckcomment as 
select   to_taskcheckcommentID,to_taskchecksID
, 
to_taskcheckcomment.info 
to_taskcheckcomment_info 
, 
to_taskcheckcomment.the_date 
to_taskcheckcomment_the_date 
, 
 to_taskcheckcomment.the_operator  
to_taskcheckcomment_the_operator_ID, 
 MTO.Func.to_oper_BRIEF_F(to_taskcheckcomment.the_operator) 
to_taskcheckcomment_the_operator 
, to_taskchecks.InstanceID InstanceID 
, to_taskcheckcomment.to_taskcheckcommentID ID 
, 'to_taskcheckcomment' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskcheckcomment
 join to_taskchecks on to_taskchecks.to_taskchecksID=to_taskcheckcomment.ParentStructRowID 
 join INSTANCE on to_taskchecks.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_taskcheckcomment as 
select   to_taskcheckcommentID,to_taskchecksID
, 
to_taskcheckcomment.info 
to_taskcheckcomment_info 
, 
to_taskcheckcomment.the_date 
to_taskcheckcomment_the_date 
, 
 to_taskcheckcomment.the_operator  
to_taskcheckcomment_the_operator_ID, 
 MTO.Func.to_oper_BRIEF_F(to_taskcheckcomment.the_operator) 
to_taskcheckcomment_the_operator 
, to_taskchecks.InstanceID InstanceID 
, to_taskcheckcomment.to_taskcheckcommentID ID 
, 'to_taskcheckcomment' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_taskcheckcomment
 join to_taskchecks on to_taskchecks.to_taskchecksID=to_taskcheckcomment.ParentStructRowID 
 join INSTANCE on to_taskchecks.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autousers as 
select   usersID
, 
users.phone 
users_phone 
, 
users.family 
users_family 
, 
users.name 
users_name 
, 
users.localphone 
users_localphone 
, 
users.login 
users_login 
, 
users.domainame 
users_domainame 
, 
users.email 
users_email 
, 
users.surname 
users_surname 
, users.InstanceID InstanceID 
, users.usersID ID 
, 'users' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from users
 join INSTANCE on users.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autogroups as 
select   groupsID
, 
groups.name 
groups_name 
, 
groups.adgroup 
groups_adgroup 
, groups.InstanceID InstanceID 
, groups.groupsID ID 
, 'groups' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from groups
 join INSTANCE on groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autogroupuser as 
select   groupuserID,groupsID
, 
 groupuser.theuser  
groupuser_theuser_ID, 
 MTO.Func.users_BRIEF_F(groupuser.theuser) 
groupuser_theuser 
, groups.InstanceID InstanceID 
, groupuser.groupuserID ID 
, 'groupuser' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from groupuser
 join groups on groups.groupsID=groupuser.ParentStructRowID 
 join INSTANCE on groups.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_oper as 
select   to_operID
, 
 to_oper.therole  
to_oper_therole_ID, 
 MTO.Func.tod_oprole_BRIEF_F(to_oper.therole) 
to_oper_therole 
, 
to_oper.tnum 
to_oper_tnum 
, 
to_oper.name 
to_oper_name 
, 
to_oper.login 
to_oper_login 
, 
to_oper.familyname 
to_oper_familyname 
, 
to_oper.surname 
to_oper_surname 
, to_oper.InstanceID InstanceID 
, to_oper.to_operID ID 
, 'to_oper' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_oper
 join INSTANCE on to_oper.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autonum_zones as 
select   num_zonesID
, 
num_zones.zonemask 
num_zones_zonemask 
, num_zones.InstanceID InstanceID 
, num_zones.num_zonesID ID 
, 'num_zones' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from num_zones
 join INSTANCE on num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autonum_values as 
select   num_valuesID,num_zonesID
, 
num_values.the_value 
num_values_the_value 
, 
num_values.ownerpartname 
num_values_ownerpartname 
, 
num_values.ownerrowid 
num_values_ownerrowid 
, num_zones.InstanceID InstanceID 
, num_values.num_valuesID ID 
, 'num_values' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from num_values
 join num_zones on num_zones.num_zonesID=num_values.ParentStructRowID 
 join INSTANCE on num_zones.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autonum_head as 
select   num_headID
, 
num_head.name 
num_head_name 
, 
 num_head.shema  
num_head_shema_VAL, 
 decode(num_head.shema 
, 2 ,'По кварталу'
, 3 ,'По месяцу'
, 0 ,'Единая зона'
, 4 ,'По дню'
, 1 ,'По году'
, 10 ,'Произвольные зоны'
, '???') 
num_head_shema 
, num_head.InstanceID InstanceID 
, num_head.num_headID ID 
, 'num_head' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from num_head
 join INSTANCE on num_head.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotor_info as 
select   tor_infoID
, 
tor_info.clientdata 
tor_info_clientdata 
, 
tor_info.serverdata 
tor_info_serverdata 
, 
tor_info.name 
tor_info_name 
, tor_info.InstanceID InstanceID 
, tor_info.tor_infoID ID 
, 'tor_info' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from tor_info
 join INSTANCE on tor_info.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_automtzext_def as 
select   mtzext_defID
, 
mtzext_def.name 
mtzext_def_name 
, 
 mtzext_def.exttype  
mtzext_def_exttype_VAL, 
 decode(mtzext_def.exttype 
, 6 ,'VerifyRowExt'
, 7 ,'CodeGenerator'
, 5 ,'DefaultExt'
, 0 ,'StatusExt'
, 4 ,'JrnlRunExt'
, 2 ,'CustomExt'
, 8 ,'ARMGenerator'
, 1 ,'OnFormExt'
, 3 ,'JrnlAddExt'
, '???') 
mtzext_def_exttype 
, 
mtzext_def.thedescription 
mtzext_def_thedescription 
, mtzext_def.InstanceID InstanceID 
, mtzext_def.mtzext_defID ID 
, 'mtzext_def' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from mtzext_def
 join INSTANCE on mtzext_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_automtzextrel as 
select   mtzextrelID
, 
mtzextrel.thelibraryname 
mtzextrel_thelibraryname 
, 
mtzextrel.theclassname 
mtzextrel_theclassname 
, 
 mtzextrel.theplatform  
mtzextrel_theplatform_VAL, 
 decode(mtzextrel.theplatform 
, 3 ,'OTHER'
, 1 ,'DOTNET'
, 2 ,'JAVA'
, 0 ,'VB6'
, '???') 
mtzextrel_theplatform 
, mtzextrel.InstanceID InstanceID 
, mtzextrel.mtzextrelID ID 
, 'mtzextrel' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from mtzextrel
 join INSTANCE on mtzextrel.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_cardinfo as 
select   to_cardinfoID
, 
 to_cardinfo.the_machine  
to_cardinfo_the_machine_ID, 
 MTO.Func.tod_st_BRIEF_F(to_cardinfo.the_machine) 
to_cardinfo_the_machine 
, 
to_cardinfo.card_date 
to_cardinfo_card_date 
, 
 to_cardinfo.card_archived  
to_cardinfo_card_archived_VAL, 
 decode(to_cardinfo.card_archived 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
to_cardinfo_card_archived 
, to_cardinfo.InstanceID InstanceID 
, to_cardinfo.to_cardinfoID ID 
, 'to_cardinfo' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_cardinfo
 join INSTANCE on to_cardinfo.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_cardchecks as 
select   to_cardchecksID
, 
to_cardchecks.hivalue 
to_cardchecks_hivalue 
, 
to_cardchecks.the_doc 
to_cardchecks_the_doc 
, 
 to_cardchecks.valuetype  
to_cardchecks_valuetype_ID, 
 MTO.Func.tod_valtype_BRIEF_F(to_cardchecks.valuetype) 
to_cardchecks_valuetype 
, 
to_cardchecks.the_check 
to_cardchecks_the_check 
, 
to_cardchecks.the_comment 
to_cardchecks_the_comment 
, 
to_cardchecks.thesubsystem 
to_cardchecks_thesubsystem 
, 
to_cardchecks.normochas 
to_cardchecks_normochas 
, 
to_cardchecks.tagid 
to_cardchecks_tagid 
, 
 to_cardchecks.the_system  
to_cardchecks_the_system_ID, 
 MTO.Func.tod_system_BRIEF_F(to_cardchecks.the_system) 
to_cardchecks_the_system 
, 
to_cardchecks.lowvalue 
to_cardchecks_lowvalue 
, to_cardchecks.InstanceID InstanceID 
, to_cardchecks.to_cardchecksID ID 
, 'to_cardchecks' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_cardchecks
 join INSTANCE on to_cardchecks.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoto_carddevices as 
select   to_carddevicesID,to_cardchecksID
, 
 to_carddevices.mat  
to_carddevices_mat_ID, 
 MTO.Func.tod_material_BRIEF_F(to_carddevices.mat) 
to_carddevices_mat 
, to_cardchecks.InstanceID InstanceID 
, to_carddevices.to_carddevicesID ID 
, 'to_carddevices' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from to_carddevices
 join to_cardchecks on to_cardchecks.to_cardchecksID=to_carddevices.ParentStructRowID 
 join INSTANCE on to_cardchecks.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotoimg_data as 
select   toimg_dataID
, 
 toimg_data.oper  
toimg_data_oper_ID, 
 MTO.Func.to_oper_BRIEF_F(toimg_data.oper) 
toimg_data_oper 
, 
toimg_data.fname 
toimg_data_fname 
, 
toimg_data.link1part 
toimg_data_link1part 
, 
toimg_data.filetype 
toimg_data_filetype 
, 
toimg_data.link2part 
toimg_data_link2part 
, 
toimg_data.link2id 
toimg_data_link2id 
, 
toimg_data.link1id 
toimg_data_link1id 
, toimg_data.InstanceID InstanceID 
, toimg_data.toimg_dataID ID 
, 'toimg_data' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from toimg_data
 join INSTANCE on toimg_data.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotoimg_data as 
select   toimg_dataID
, 
toimg_data.link2id 
toimg_data_link2id 
, 
toimg_data.link1part 
toimg_data_link1part 
, 
toimg_data.link1id 
toimg_data_link1id 
, 
toimg_data.link2part 
toimg_data_link2part 
, 
toimg_data.fname 
toimg_data_fname 
, 
toimg_data.filetype 
toimg_data_filetype 
, toimg_data.InstanceID InstanceID 
, toimg_data.toimg_dataID ID 
, 'toimg_data' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from toimg_data
 join INSTANCE on toimg_data.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotoimg_todelete as 
select   toimg_todeleteID
, 
toimg_todelete.filerowid 
toimg_todelete_filerowid 
, 
toimg_todelete.fname 
toimg_todelete_fname 
, toimg_todelete.InstanceID InstanceID 
, toimg_todelete.toimg_todeleteID ID 
, 'toimg_todelete' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from toimg_todelete
 join INSTANCE on toimg_todelete.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autotoimg_def as 
select   toimg_defID
, 
toimg_def.sharedfolder 
toimg_def_sharedfolder 
, 
toimg_def.computername 
toimg_def_computername 
, 
toimg_def.imagestore 
toimg_def_imagestore 
, toimg_def.InstanceID InstanceID 
, toimg_def.toimg_defID ID 
, 'toimg_def' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from toimg_def
 join INSTANCE on toimg_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_automtz2job_def as 
select   mtz2job_defID
, 
mtz2job_def.eventype 
mtz2job_def_eventype 
, 
 mtz2job_def.processed  
mtz2job_def_processed_VAL, 
 decode(mtz2job_def.processed 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
mtz2job_def_processed 
, 
mtz2job_def.processdate 
mtz2job_def_processdate 
, 
mtz2job_def.nextstate 
mtz2job_def_nextstate 
, 
mtz2job_def.thrustate 
mtz2job_def_thrustate 
, 
mtz2job_def.eventdate 
mtz2job_def_eventdate 
, 
 mtz2job_def.thruobject  
mtz2job_def_thruobject_ID, 
 MTO.Func.INSTANCE_BRIEF_F(mtz2job_def.thruobject) 
mtz2job_def_thruobject 
, mtz2job_def.InstanceID InstanceID 
, mtz2job_def.mtz2job_defID ID 
, 'mtz2job_def' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from mtz2job_def
 join INSTANCE on mtz2job_def.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofilterfieldgroup as 
select   filterfieldgroupID
, 
 filterfieldgroup.allowignore  
filterfieldgroup_allowignore_VAL, 
 decode(filterfieldgroup.allowignore 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
filterfieldgroup_allowignore 
, 
filterfieldgroup.name 
filterfieldgroup_name 
, 
filterfieldgroup.caption 
filterfieldgroup_caption 
, 
filterfieldgroup.sequence 
filterfieldgroup_sequence 
, filterfieldgroup.InstanceID InstanceID 
, filterfieldgroup.filterfieldgroupID ID 
, 'filterfieldgroup' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from filterfieldgroup
 join INSTANCE on filterfieldgroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofileterfield as 
select   fileterfieldID,filterfieldgroupID
, 
fileterfield.sequence 
fileterfield_sequence 
, 
 fileterfield.reftopart  
fileterfield_reftopart_ID, 
 MTO.Func.part_BRIEF_F(fileterfield.reftopart) 
fileterfield_reftopart 
, 
 fileterfield.reftotype  
fileterfield_reftotype_ID, 
 MTO.Func.objecttype_BRIEF_F(fileterfield.reftotype) 
fileterfield_reftotype 
, 
fileterfield.caption 
fileterfield_caption 
, 
fileterfield.fieldsize 
fileterfield_fieldsize 
, 
fileterfield.name 
fileterfield_name 
, 
 fileterfield.reftype  
fileterfield_reftype_VAL, 
 decode(fileterfield.reftype 
, 3 ,'На источник данных'
, 0 ,'Скалярное поле ( не ссылка)'
, 2 ,'На строку раздела'
, 1 ,'На объект '
, '???') 
fileterfield_reftype 
, 
 fileterfield.valuearray  
fileterfield_valuearray_VAL, 
 decode(fileterfield.valuearray 
, -1 ,'Да'
, 0 ,'Нет'
, '???') 
fileterfield_valuearray 
, 
 fileterfield.fieldtype  
fileterfield_fieldtype_ID, 
 MTO.Func.fieldtype_BRIEF_F(fileterfield.fieldtype) 
fileterfield_fieldtype 
, filterfieldgroup.InstanceID InstanceID 
, fileterfield.fileterfieldID ID 
, 'fileterfield' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from fileterfield
 join filterfieldgroup on filterfieldgroup.filterfieldgroupID=fileterfield.ParentStructRowID 
 join INSTANCE on filterfieldgroup.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autofilters as 
select   filtersID
, 
filters.thecaption 
filters_thecaption 
, 
filters.name 
filters_name 
, 
filters.thecomment 
filters_thecomment 
, filters.InstanceID InstanceID 
, filters.filtersID ID 
, 'filters' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from filters
 join INSTANCE on filters.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autorptstruct as 
select   rptstructID
, 
rptstruct.name 
rptstruct_name 
, 
rptstruct.caption 
rptstruct_caption 
, rptstruct.InstanceID InstanceID 
, rptstruct.rptstructID ID 
, 'rptstruct' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from rptstruct
 join INSTANCE on rptstruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autorptfields as 
select   rptfieldsID,rptstructID
, 
 rptfields.fieldtype  
rptfields_fieldtype_ID, 
 MTO.Func.fieldtype_BRIEF_F(rptfields.fieldtype) 
rptfields_fieldtype 
, 
rptfields.caption 
rptfields_caption 
, 
rptfields.name 
rptfields_name 
, 
rptfields.fieldsize 
rptfields_fieldsize 
, rptstruct.InstanceID InstanceID 
, rptfields.rptfieldsID ID 
, 'rptfields' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from rptfields
 join rptstruct on rptstruct.rptstructID=rptfields.ParentStructRowID 
 join INSTANCE on rptstruct.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autorptformula as 
select   rptformulaID
, 
rptformula.name 
rptformula_name 
, 
 rptformula.platform  
rptformula_platform_ID, 
 MTO.Func.generator_target_BRIEF_F(rptformula.platform) 
rptformula_platform 
, 
rptformula.code 
rptformula_code 
, rptformula.InstanceID InstanceID 
, rptformula.rptformulaID ID 
, 'rptformula' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from rptformula
 join INSTANCE on rptformula.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/
create or replace view V_autoreports as 
select   reportsID
, 
 reports.reporttype  
reports_reporttype_VAL, 
 decode(reports.reporttype 
, 4 ,'Экспорт по Excel шаблону'
, 0 ,'Таблица'
, 3 ,'Экспорт по WORD шаблону'
, 1 ,'Двумерная матрица'
, 2 ,'Только расчет'
, '???') 
reports_reporttype 
, 
reports.name 
reports_name 
, 
reports.caption 
reports_caption 
, 
 reports.preparemethod  
reports_preparemethod_ID, 
 MTO.Func.sharedmethod_BRIEF_F(reports.preparemethod) 
reports_preparemethod 
, 
reports.reportfile 
reports_reportfile 
, 
reports.reportview 
reports_reportview 
, 
reports.thecomment 
reports_thecomment 
, 
 reports.thereportext  
reports_thereportext_ID, 
 MTO.Func.INSTANCE_BRIEF_F(reports.thereportext) 
reports_thereportext 
, reports.InstanceID InstanceID 
, reports.reportsID ID 
, 'reports' VIEWBASE 
, XXXMYSTATUSXXX.Name StatusName 
, XXXMYSTATUSXXX.objstatusid INTSANCEStatusID  from reports
 join INSTANCE on reports.INSTANCEID=INSTANCE.INSTANCEID
 left join objstatus XXXMYSTATUSXXX on instance.status=XXXMYSTATUSXXX.objstatusid 
/">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Kernel.Header" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package Kernel as

procedure INSTANCE_OWNER   (
    acursession CHAR ,ainstanceid CHAR,
 aOwnerPartName varchar2, aOwnerRowID CHAR); 
procedure SYSOPTIONS_SAVE    (
 aSysOptionsid CHAR,
 aName varchar2,
 aValue varchar2 ,
 aOptionType varchar2);
procedure INSTANCE_SAVE      (
aCURSESSION CHAR,
aInstanceID CHAR,
aObjType varchar2,
aName varchar2
);
  procedure INSTANCE_DELETE    (
aCURSESSION CHAR,
aInstanceID Char
);
  procedure INSTANCE_HCL   (
aCURSESSION CHAR,
aRowID CHAR,
aIsLocked out NUMBER
);
  procedure INSTANCE_PROPAGATE   (
aCURSESSION CHAR,
aRowID Char
);
  procedure INSTANCE_ISLOCKED   (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
  procedure INSTANCE_SINIT    (
aCURSESSION CHAR,
aRowID CHAR ,
 aSecurityStyleID Char
);
  procedure INSTANCE_LOCK     (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer
) ;
  procedure INSTANCE_UNLOCK (
 aCURSESSION CHAR,
 aROWID Char
);
    procedure INSTANCE_BRIEF    (
 aCURSESSION CHAR,
 ainstanceid CHAR,
 aBRIEF out varchar2
) ;
    procedure QR_AND_QR  ( aid1 CHAR, aid2
    CHAR,aidout CHAR,acnt out integer );
    procedure QR_OR_QR  ( aid1 CHAR, aid2 
    CHAR,aidout CHAR,acnt out integer);
  procedure ROWPARENTS
(aQueryID   CHAR
,aRowID CHAR/* Row */
,aTable varchar2 /* Part Table Name */
,aCURSESSION CHAR/* the_session */
);
    procedure INSTANCE_STATUS    (
  acursession CHAR,
  ainstanceid CHAR,
  astatusid CHAR);
 end Kernel;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Type.Header" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzmetamodel" BlockCode=" create or replace package mtzmetamodel as

procedure mtzmetamodel_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzmetamodel_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzmetamodel_propagate(acursession CHAR, aROWID CHAR); 

procedure genpackage_BRIEF  (
 aCURSESSION CHAR,
 agenpackageid CHAR,
 aBRIEF out varchar2
);
procedure genpackage_DELETE  (
 aCURSESSION CHAR,
 agenpackageid CHAR,
 ainstanceid char
); 
procedure genpackage_SAVE (
 aCURSESSION CHAR,
 agenpackageid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
); 
procedure genpackage_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure genpackage_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure genpackage_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure genpackage_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure genpackage_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure genpackage_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure genpackage_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure generator_target_BRIEF  (
 aCURSESSION CHAR,
 agenerator_targetid CHAR,
 aBRIEF out varchar2
);
procedure generator_target_DELETE  (
 aCURSESSION CHAR,
 agenerator_targetid CHAR,
 ainstanceid char
); 
procedure generator_target_SAVE (
 aCURSESSION CHAR,
 agenerator_targetid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atargettype
 NUMBER/* Тип платформы *//* Тип платформы */
,aqueuename
 VARCHAR2 := null /* Очередь *//* Очередь */
,ageneratorprogid
 VARCHAR2 := null /* COM класс *//* COM класс */
,ageneratorstyle
 NUMBER := null /* Вариант *//* Вариант */
,athedevelopmentenv
 NUMBER := null /* Среда разработки *//* Среда разработки */
); 
procedure generator_target_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure generator_target_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure generator_target_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure generator_target_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure generator_target_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure generator_target_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure generator_target_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure genreference_BRIEF  (
 aCURSESSION CHAR,
 agenreferenceid CHAR,
 aBRIEF out varchar2
);
procedure genreference_DELETE  (
 aCURSESSION CHAR,
 agenreferenceid CHAR,
 ainstanceid char
); 
procedure genreference_SAVE (
 aCURSESSION CHAR,
 agenreferenceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,arefclassid
 VARCHAR2 := null /* Класс ссылки *//* Класс ссылки */
,aversionmajor
 NUMBER := null /* Номер версии *//* Номер версии */
,aversionminor
 NUMBER := null /* Подверсия *//* Подверсия */
); 
procedure genreference_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure genreference_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure genreference_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure genreference_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure genreference_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure genreference_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure genreference_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure genmanualcode_BRIEF  (
 aCURSESSION CHAR,
 agenmanualcodeid CHAR,
 aBRIEF out varchar2
);
procedure genmanualcode_DELETE  (
 aCURSESSION CHAR,
 agenmanualcodeid CHAR,
 ainstanceid char
); 
procedure genmanualcode_SAVE (
 aCURSESSION CHAR,
 agenmanualcodeid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,acode VARCHAR2/* Код *//* Код */
); 
procedure genmanualcode_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure genmanualcode_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure genmanualcode_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure genmanualcode_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure genmanualcode_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure genmanualcode_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure genmanualcode_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure gencontrols_BRIEF  (
 aCURSESSION CHAR,
 agencontrolsid CHAR,
 aBRIEF out varchar2
);
procedure gencontrols_DELETE  (
 aCURSESSION CHAR,
 agencontrolsid CHAR,
 ainstanceid char
); 
procedure gencontrols_SAVE (
 aCURSESSION CHAR,
 agencontrolsid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,acontrolprogid
 VARCHAR2/* ProgID контрольконо элемента *//* ProgID контрольконо элемента */
,acontrolclassid
 VARCHAR2 := null /* Класс контрольногоэлемента *//* Класс контрольногоэлемента */
,aversionmajor
 NUMBER := null /* Версия *//* Версия */
,aversionminor
 NUMBER := null /* Подверсия *//* Подверсия */
); 
procedure gencontrols_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure gencontrols_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure gencontrols_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure gencontrols_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure gencontrols_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure gencontrols_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure gencontrols_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure localizeinfo_BRIEF  (
 aCURSESSION CHAR,
 alocalizeinfoid CHAR,
 aBRIEF out varchar2
);
procedure localizeinfo_DELETE  (
 aCURSESSION CHAR,
 alocalizeinfoid CHAR,
 ainstanceid char
); 
procedure localizeinfo_SAVE (
 aCURSESSION CHAR,
 alocalizeinfoid CHAR,
aInstanceID CHAR 
,alangfull
 VARCHAR2/* Язык - название *//* Язык - название */
,alangshort
 VARCHAR2/* Код языка *//* Код языка */
); 
procedure localizeinfo_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure localizeinfo_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure localizeinfo_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure localizeinfo_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure localizeinfo_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure localizeinfo_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure localizeinfo_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldtype_BRIEF  (
 aCURSESSION CHAR,
 afieldtypeid CHAR,
 aBRIEF out varchar2
);
procedure fieldtype_DELETE  (
 aCURSESSION CHAR,
 afieldtypeid CHAR,
 ainstanceid char
); 
procedure fieldtype_SAVE (
 aCURSESSION CHAR,
 afieldtypeid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atypestyle
 NUMBER/* Трактовка *//* Трактовка */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
,aallowsize
 NUMBER/* Нужен размер *//* Нужен размер */
,aminimum
 VARCHAR2 := null /* Минимум *//* Минимум */
,amaximum
 VARCHAR2 := null /* Максимум *//* Максимум */
,aallowlikesearch
 NUMBER/* Поиск текста *//* Поиск текста */
,agridsorttype
 NUMBER := null /* Вариант сортировки в табличном представлении *//* Вариант сортировки в табличном представлении */
,adelayedsave
 NUMBER/* Отложенное сохранение *//* Отложенное сохранение */
); 
procedure fieldtype_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldtype_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldtype_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldtype_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldtype_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldtype_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldtype_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure enumitem_BRIEF  (
 aCURSESSION CHAR,
 aenumitemid CHAR,
 aBRIEF out varchar2
);
procedure enumitem_DELETE  (
 aCURSESSION CHAR,
 aenumitemid CHAR,
 ainstanceid char
); 
procedure enumitem_SAVE (
 aCURSESSION CHAR,
 aenumitemid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,anamevalue
 NUMBER/* Значение *//* Значение */
,anameincode
 VARCHAR2 := null /* Название в коде *//* Название в коде */
); 
procedure enumitem_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure enumitem_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure enumitem_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure enumitem_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure enumitem_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure enumitem_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure enumitem_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldtypemap_BRIEF  (
 aCURSESSION CHAR,
 afieldtypemapid CHAR,
 aBRIEF out varchar2
);
procedure fieldtypemap_DELETE  (
 aCURSESSION CHAR,
 afieldtypemapid CHAR,
 ainstanceid char
); 
procedure fieldtypemap_SAVE (
 aCURSESSION CHAR,
 afieldtypemapid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,astoagetype
 VARCHAR2/* Тип хранения *//* Тип хранения */
,afixedsize
 NUMBER := null /* Размер *//* Размер */
); 
procedure fieldtypemap_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldtypemap_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldtypemap_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldtypemap_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldtypemap_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldtypemap_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldtypemap_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure sharedmethod_BRIEF  (
 aCURSESSION CHAR,
 asharedmethodid CHAR,
 aBRIEF out varchar2
);
procedure sharedmethod_DELETE  (
 aCURSESSION CHAR,
 asharedmethodid CHAR,
 ainstanceid char
); 
procedure sharedmethod_SAVE (
 aCURSESSION CHAR,
 asharedmethodid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_comment VARCHAR2 := null /* Описание метода *//* Описание метода */
,areturntype CHAR := null /* Возвращаемый тип *//* Возвращаемый тип */
); 
procedure sharedmethod_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure sharedmethod_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure sharedmethod_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure sharedmethod_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure sharedmethod_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure sharedmethod_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure sharedmethod_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure script_BRIEF  (
 aCURSESSION CHAR,
 ascriptid CHAR,
 aBRIEF out varchar2
);
procedure script_DELETE  (
 aCURSESSION CHAR,
 ascriptid CHAR,
 ainstanceid char
); 
procedure script_SAVE (
 aCURSESSION CHAR,
 ascriptid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Целевая платформа *//* Целевая платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure script_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure script_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure script_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure script_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure script_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure script_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure script_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure parameters_BRIEF  (
 aCURSESSION CHAR,
 aparametersid CHAR,
 aBRIEF out varchar2
);
procedure parameters_DELETE  (
 aCURSESSION CHAR,
 aparametersid CHAR,
 ainstanceid char
); 
procedure parameters_SAVE (
 aCURSESSION CHAR,
 aparametersid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Имя *//* Имя */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,atypeofparm CHAR/* Тип данных *//* Тип данных */
,adatasize
 NUMBER := null /* Размер *//* Размер */
,aallownull
 NUMBER/* Можно не задавать *//* Можно не задавать */
,aoutparam
 NUMBER/* Возвращает значение *//* Возвращает значение */
,areferencetype
 NUMBER/* Тип ссылки *//* Тип ссылки */
,areftotype CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,areftopart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
); 
procedure parameters_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure parameters_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure parameters_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure parameters_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure parameters_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure parameters_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure parameters_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure objecttype_BRIEF  (
 aCURSESSION CHAR,
 aobjecttypeid CHAR,
 aBRIEF out varchar2
);
procedure objecttype_DELETE  (
 aCURSESSION CHAR,
 aobjecttypeid CHAR,
 ainstanceid char
); 
procedure objecttype_SAVE (
 aCURSESSION CHAR,
 aobjecttypeid CHAR,
aInstanceID CHAR 
,apackage CHAR/* Приложение *//* Приложение */
,athe_comment
 VARCHAR2/* Название *//* Название */
,aname
 VARCHAR2/* Код *//* Код */
,aissingleinstance
 NUMBER/* Допускается только один объект *//* Допускается только один объект */
,achooseview CHAR := null /* Представление для выбора *//* Представление для выбора */
,aonrun CHAR := null /* При запуске *//* При запуске */
,aoncreate CHAR := null /* При создании *//* При создании */
,aondelete CHAR := null /* При удалении *//* При удалении */
,aallowreftoobject
 NUMBER/* Отображать при выборе ссылки *//* Отображать при выборе ссылки */
,aallowsearch
 NUMBER/* Отображать при поиске *//* Отображать при поиске */
,areplicatype
 NUMBER := null /* Тип репликации *//* Тип репликации */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,auseownership
 NUMBER/* Видмость зависит от пользователя *//* Видмость зависит от пользователя */
,ausearchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,acommitfullobject
 NUMBER/* Сохранять объект целиком *//* Сохранять объект целиком */
,aobjiconcls
 VARCHAR2 := null /* Иконка объекта *//* Иконка объекта */
); 
procedure objecttype_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure objecttype_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure objecttype_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure objecttype_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure objecttype_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure objecttype_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure objecttype_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure objstatus_BRIEF  (
 aCURSESSION CHAR,
 aobjstatusid CHAR,
 aBRIEF out varchar2
);
procedure objstatus_DELETE  (
 aCURSESSION CHAR,
 aobjstatusid CHAR,
 ainstanceid char
); 
procedure objstatus_SAVE (
 aCURSESSION CHAR,
 aobjstatusid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aisstartup
 NUMBER/* Начальное *//* Начальное */
,aisarchive
 NUMBER/* Архивное *//* Архивное */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure objstatus_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure objstatus_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure objstatus_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure objstatus_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure objstatus_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure objstatus_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure objstatus_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure nextstate_BRIEF  (
 aCURSESSION CHAR,
 anextstateid CHAR,
 aBRIEF out varchar2
);
procedure nextstate_DELETE  (
 aCURSESSION CHAR,
 anextstateid CHAR,
 ainstanceid char
); 
procedure nextstate_SAVE (
 aCURSESSION CHAR,
 anextstateid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athestate CHAR/* Разрешенное состояние *//* Разрешенное состояние */
); 
procedure nextstate_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure nextstate_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure nextstate_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure nextstate_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure nextstate_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure nextstate_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure nextstate_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure objectmode_BRIEF  (
 aCURSESSION CHAR,
 aobjectmodeid CHAR,
 aBRIEF out varchar2
);
procedure objectmode_DELETE  (
 aCURSESSION CHAR,
 aobjectmodeid CHAR,
 ainstanceid char
); 
procedure objectmode_SAVE (
 aCURSESSION CHAR,
 aobjectmodeid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название режима *//* Название режима */
,adefaultmode
 NUMBER/* Этот режим является основным режимом работы объекта *//* Этот режим является основным режимом работы объекта */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure objectmode_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure objectmode_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure objectmode_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure objectmode_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure objectmode_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure objectmode_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure objectmode_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure structrestriction_BRIEF  (
 aCURSESSION CHAR,
 astructrestrictionid CHAR,
 aBRIEF out varchar2
);
procedure structrestriction_DELETE  (
 aCURSESSION CHAR,
 astructrestrictionid CHAR,
 ainstanceid char
); 
procedure structrestriction_SAVE (
 aCURSESSION CHAR,
 astructrestrictionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,astruct CHAR/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aallowread
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aallowadd
 NUMBER/* Разрешено добавлять *//* Разрешено добавлять */
,aallowedit
 NUMBER/* Разрешено изменять *//* Разрешено изменять */
,aallowdelete
 NUMBER/* Разрешено удалять *//* Разрешено удалять */
); 
procedure structrestriction_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure structrestriction_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure structrestriction_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure structrestriction_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure structrestriction_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure structrestriction_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure structrestriction_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure methodrestriction_BRIEF  (
 aCURSESSION CHAR,
 amethodrestrictionid CHAR,
 aBRIEF out varchar2
);
procedure methodrestriction_DELETE  (
 aCURSESSION CHAR,
 amethodrestrictionid CHAR,
 ainstanceid char
); 
procedure methodrestriction_SAVE (
 aCURSESSION CHAR,
 amethodrestrictionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,apart CHAR := null /* Структура, которой принадлежит метод *//* Структура, которой принадлежит метод */
,amethod CHAR/* Метод *//* Метод */
,aisrestricted
 NUMBER/* Запрещено использовать *//* Запрещено использовать */
); 
procedure methodrestriction_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure methodrestriction_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure methodrestriction_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure methodrestriction_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure methodrestriction_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure methodrestriction_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure methodrestriction_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldrestriction_BRIEF  (
 aCURSESSION CHAR,
 afieldrestrictionid CHAR,
 aBRIEF out varchar2
);
procedure fieldrestriction_DELETE  (
 aCURSESSION CHAR,
 afieldrestrictionid CHAR,
 ainstanceid char
); 
procedure fieldrestriction_SAVE (
 aCURSESSION CHAR,
 afieldrestrictionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athepart CHAR/* Структура, которой принадлежит поле *//* Структура, которой принадлежит поле */
,athefield CHAR/* Поле, на которое накладывается ограничение *//* Поле, на которое накладывается ограничение */
,aallowread
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aallowmodify
 NUMBER/* Разрешена модификация *//* Разрешена модификация */
,amandatoryfield
 NUMBER := null /* Обязательное поле *//* Обязательное поле */
); 
procedure fieldrestriction_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldrestriction_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldrestriction_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldrestriction_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldrestriction_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldrestriction_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldrestriction_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure typemenu_BRIEF  (
 aCURSESSION CHAR,
 atypemenuid CHAR,
 aBRIEF out varchar2
);
procedure typemenu_DELETE  (
 aCURSESSION CHAR,
 atypemenuid CHAR,
 ainstanceid char
); 
procedure typemenu_SAVE (
 aCURSESSION CHAR,
 atypemenuid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,atooltip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_action CHAR := null /* Метод *//* Метод */
,aismenuitem
 NUMBER/* Включать в меню *//* Включать в меню */
,aistoolbarbutton
 NUMBER/* Включать в тулбар *//* Включать в тулбар */
,ahotkey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
); 
procedure typemenu_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure typemenu_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure typemenu_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure typemenu_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure typemenu_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure typemenu_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure typemenu_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure instancevalidator_BRIEF  (
 aCURSESSION CHAR,
 ainstancevalidatorid CHAR,
 aBRIEF out varchar2
);
procedure instancevalidator_DELETE  (
 aCURSESSION CHAR,
 ainstancevalidatorid CHAR,
 ainstanceid char
); 
procedure instancevalidator_SAVE (
 aCURSESSION CHAR,
 ainstancevalidatorid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure instancevalidator_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure instancevalidator_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure instancevalidator_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure instancevalidator_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure instancevalidator_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure instancevalidator_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure instancevalidator_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure part_BRIEF  (
 aCURSESSION CHAR,
 apartid CHAR,
 aBRIEF out varchar2
);
procedure part_DELETE  (
 aCURSESSION CHAR,
 apartid CHAR,
 ainstanceid char
); 
procedure part_SAVE (
 aCURSESSION CHAR,
 apartid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
, aParentRowid CHAR :=null
,asequence
 NUMBER/* № п/п *//* № п/п */
,aparttype
 NUMBER/* Тип структры *//* Тип структры */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aname
 VARCHAR2/* Название *//* Название */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
,anolog
 NUMBER/* Не записывать в журнал *//* Не записывать в журнал */
,amanualregister
 NUMBER/* Исключить из индексирования *//* Исключить из индексирования */
,aoncreate CHAR := null /* При создании *//* При создании */
,aonsave CHAR := null /* При сохранении *//* При сохранении */
,aonrun CHAR := null /* При открытии *//* При открытии */
,aondelete CHAR := null /* При удалении *//* При удалении */
,aaddbehaivor
 NUMBER := null /* Поведение при добавлении *//* Поведение при добавлении */
,aextenderobject CHAR := null /* Объект расширения *//* Объект расширения */
,ashablonbrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,arulebrief
 VARCHAR2 := null /* Правило составления BRIEF поля *//* Правило составления BRIEF поля */
,aisjormalchange
 NUMBER/* Вести журнал изменений *//* Вести журнал изменений */
,ausearchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,aintegerpkey
 NUMBER/* Целочисленный ключ *//* Целочисленный ключ */
,aparticoncls
 VARCHAR2 := null /* Иконка раздела *//* Иконка раздела */
); 
procedure part_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure part_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure part_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure part_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure part_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure part_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure part_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure partmenu_BRIEF  (
 aCURSESSION CHAR,
 apartmenuid CHAR,
 aBRIEF out varchar2
);
procedure partmenu_DELETE  (
 aCURSESSION CHAR,
 apartmenuid CHAR,
 ainstanceid char
); 
procedure partmenu_SAVE (
 aCURSESSION CHAR,
 apartmenuid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,atooltip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_action CHAR := null /* Метод *//* Метод */
,aismenuitem
 NUMBER/* Включать в меню *//* Включать в меню */
,aistoolbarbutton
 NUMBER/* В тулбар *//* В тулбар */
,ahotkey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
); 
procedure partmenu_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure partmenu_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure partmenu_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure partmenu_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure partmenu_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure partmenu_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure partmenu_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure partparammap_BRIEF  (
 aCURSESSION CHAR,
 apartparammapid CHAR,
 aBRIEF out varchar2
);
procedure partparammap_DELETE  (
 aCURSESSION CHAR,
 apartparammapid CHAR,
 ainstanceid char
); 
procedure partparammap_SAVE (
 aCURSESSION CHAR,
 apartparammapid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,afieldname
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aparamname
 VARCHAR2/* Параметр *//* Параметр */
,anoedit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
); 
procedure partparammap_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure partparammap_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure partparammap_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure partparammap_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure partparammap_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure partparammap_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure partparammap_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure partview_BRIEF  (
 aCURSESSION CHAR,
 apartviewid CHAR,
 aBRIEF out varchar2
);
procedure partview_DELETE  (
 aCURSESSION CHAR,
 apartviewid CHAR,
 ainstanceid char
); 
procedure partview_SAVE (
 aCURSESSION CHAR,
 apartviewid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2/* Псевдоним *//* Псевдоним */
,aforchoose
 NUMBER/* Для поиска *//* Для поиска */
,afilterfield0
 VARCHAR2 := null /* Поле - фильтр 0 *//* Поле - фильтр 0 */
,afilterfield1
 VARCHAR2 := null /* Поле - фильтр 1 *//* Поле - фильтр 1 */
,afilterfield2
 VARCHAR2 := null /* Поле - фильтр 2 *//* Поле - фильтр 2 */
,afilterfield3
 VARCHAR2 := null /* Поле - фильтр 3 *//* Поле - фильтр 3 */
); 
procedure partview_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure partview_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure partview_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure partview_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure partview_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure partview_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure partview_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure viewcolumn_BRIEF  (
 aCURSESSION CHAR,
 aviewcolumnid CHAR,
 aBRIEF out varchar2
);
procedure viewcolumn_DELETE  (
 aCURSESSION CHAR,
 aviewcolumnid CHAR,
 ainstanceid char
); 
procedure viewcolumn_SAVE (
 aCURSESSION CHAR,
 aviewcolumnid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER := null /* № *//* № */
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2/* Псвдоним *//* Псвдоним */
,afrompart CHAR/* Раздел *//* Раздел */
,afield CHAR/* Поле *//* Поле */
,aaggregation
 NUMBER/* Агрегация *//* Агрегация */
,aexpression VARCHAR2 := null /* Формула *//* Формула */
,aforcombo
 NUMBER/* Для комбо *//* Для комбо */
); 
procedure viewcolumn_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure viewcolumn_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure viewcolumn_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure viewcolumn_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure viewcolumn_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure viewcolumn_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure viewcolumn_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure partview_lnk_BRIEF  (
 aCURSESSION CHAR,
 apartview_lnkid CHAR,
 aBRIEF out varchar2
);
procedure partview_lnk_DELETE  (
 aCURSESSION CHAR,
 apartview_lnkid CHAR,
 ainstanceid char
); 
procedure partview_lnk_SAVE (
 aCURSESSION CHAR,
 apartview_lnkid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atheview CHAR/* Представление *//* Представление */
,athejoinsource CHAR := null /* Связь: Поле для join источник *//* Связь: Поле для join источник */
,areftype
 NUMBER/* Связывать как *//* Связывать как */
,athejoindestination CHAR := null /* Свзяь: Поле для join приемник *//* Свзяь: Поле для join приемник */
,ahandjoin
 VARCHAR2 := null /* Ручной join *//* Ручной join */
,aseq
 NUMBER/* Порядок *//* Порядок */
); 
procedure partview_lnk_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure partview_lnk_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure partview_lnk_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure partview_lnk_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure partview_lnk_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure partview_lnk_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure partview_lnk_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure validator_BRIEF  (
 aCURSESSION CHAR,
 avalidatorid CHAR,
 aBRIEF out varchar2
);
procedure validator_DELETE  (
 aCURSESSION CHAR,
 avalidatorid CHAR,
 ainstanceid char
); 
procedure validator_SAVE (
 aCURSESSION CHAR,
 avalidatorid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Целевая платформа *//* Целевая платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure validator_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure validator_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure validator_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure validator_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure validator_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure validator_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure validator_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure uniqueconstraint_BRIEF  (
 aCURSESSION CHAR,
 auniqueconstraintid CHAR,
 aBRIEF out varchar2
);
procedure uniqueconstraint_DELETE  (
 aCURSESSION CHAR,
 auniqueconstraintid CHAR,
 ainstanceid char
); 
procedure uniqueconstraint_SAVE (
 aCURSESSION CHAR,
 auniqueconstraintid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aperparent
 NUMBER/* По родителю *//* По родителю */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure uniqueconstraint_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure uniqueconstraint_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure uniqueconstraint_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure uniqueconstraint_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure uniqueconstraint_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure uniqueconstraint_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure uniqueconstraint_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure constraintfield_BRIEF  (
 aCURSESSION CHAR,
 aconstraintfieldid CHAR,
 aBRIEF out varchar2
);
procedure constraintfield_DELETE  (
 aCURSESSION CHAR,
 aconstraintfieldid CHAR,
 ainstanceid char
); 
procedure constraintfield_SAVE (
 aCURSESSION CHAR,
 aconstraintfieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athefield CHAR/* Поле *//* Поле */
); 
procedure constraintfield_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure constraintfield_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure constraintfield_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure constraintfield_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure constraintfield_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure constraintfield_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure constraintfield_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure extenderinterface_BRIEF  (
 aCURSESSION CHAR,
 aextenderinterfaceid CHAR,
 aBRIEF out varchar2
);
procedure extenderinterface_DELETE  (
 aCURSESSION CHAR,
 aextenderinterfaceid CHAR,
 ainstanceid char
); 
procedure extenderinterface_SAVE (
 aCURSESSION CHAR,
 aextenderinterfaceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athename
 VARCHAR2/* Название *//* Название */
,atargetplatform CHAR/* Целевая платформа *//* Целевая платформа */
,atheobject
 VARCHAR2/* Объект *//* Объект */
,atheconfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
); 
procedure extenderinterface_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure extenderinterface_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure extenderinterface_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure extenderinterface_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure extenderinterface_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure extenderinterface_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure extenderinterface_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure field_BRIEF  (
 aCURSESSION CHAR,
 afieldid CHAR,
 aBRIEF out varchar2
);
procedure field_DELETE  (
 aCURSESSION CHAR,
 afieldid CHAR,
 ainstanceid char
); 
procedure field_SAVE (
 aCURSESSION CHAR,
 afieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atabname
 VARCHAR2 := null /* Имя вкладки *//* Имя вкладки */
,afieldgroupbox
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,asequence
 NUMBER/* № п/п *//* № п/п */
,acaption
 VARCHAR2/* Надпись *//* Надпись */
,aname
 VARCHAR2/* Имя поля *//* Имя поля */
,afieldtype CHAR/* Тип поля *//* Тип поля */
,aisbrief
 NUMBER/* Краткая информация *//* Краткая информация */
,aistabbrief
 NUMBER/* Для отображения в таблице *//* Для отображения в таблице */
,aallownull
 NUMBER/* Может быть пустым *//* Может быть пустым */
,adatasize
 NUMBER := null /* Размер поля *//* Размер поля */
,areferencetype
 NUMBER/* Тип ссылки *//* Тип ссылки */
,areftotype CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,areftopart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
,athestyle
 VARCHAR2 := null /* Стиль *//* Стиль */
,ainternalreference
 NUMBER/* Ссылка в пределах объекта *//* Ссылка в пределах объекта */
,acreaterefonly
 NUMBER/* Только создание объекта *//* Только создание объекта */
,aisautonumber
 NUMBER/* Автонумерация *//* Автонумерация */
,athenumerator CHAR := null /* Нумератор *//* Нумератор */
,azonetemplate
 VARCHAR2 := null /* Шаблон зоны нумерации *//* Шаблон зоны нумерации */
,anumberdatefield CHAR := null /* Поле для расчета даты *//* Поле для расчета даты */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,ashablonbrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,athenameclass
 VARCHAR2 := null /* Имя класса для мастера строк *//* Имя класса для мастера строк */
,athemask
 VARCHAR2 := null /* Маска *//* Маска */
); 
procedure field_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure field_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure field_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure field_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure field_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure field_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure field_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fldextenders_BRIEF  (
 aCURSESSION CHAR,
 afldextendersid CHAR,
 aBRIEF out varchar2
);
procedure fldextenders_DELETE  (
 aCURSESSION CHAR,
 afldextendersid CHAR,
 ainstanceid char
); 
procedure fldextenders_SAVE (
 aCURSESSION CHAR,
 afldextendersid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athename
 VARCHAR2/* Название *//* Название */
,atargetplatform CHAR/* Целевая платформа *//* Целевая платформа */
,atheobject
 VARCHAR2/* Объект *//* Объект */
,atheconfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
); 
procedure fldextenders_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fldextenders_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fldextenders_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fldextenders_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fldextenders_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fldextenders_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fldextenders_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldsrcdef_BRIEF  (
 aCURSESSION CHAR,
 afieldsrcdefid CHAR,
 aBRIEF out varchar2
);
procedure fieldsrcdef_DELETE  (
 aCURSESSION CHAR,
 afieldsrcdefid CHAR,
 ainstanceid char
); 
procedure fieldsrcdef_SAVE (
 aCURSESSION CHAR,
 afieldsrcdefid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aprovider
 VARCHAR2 := null /* Провайдер *//* Провайдер */
,aconnectionstring
 VARCHAR2 := null /* Строка соединения с источником *//* Строка соединения с источником */
,adatasource
 VARCHAR2/* Источник данных *//* Источник данных */
,aidfield
 VARCHAR2 := null /* ID *//* ID */
,abriefstring
 VARCHAR2 := null /* Источник краткой информации *//* Источник краткой информации */
,afilterstring
 VARCHAR2 := null /* Фильтр источника данных *//* Фильтр источника данных */
,asortfield
 VARCHAR2 := null /* Сортировка источника данных *//* Сортировка источника данных */
,adescriptionstring VARCHAR2 := null /* Примечания *//* Примечания */
,adontshowdialog
 NUMBER := null /* Не показывать форму выбора *//* Не показывать форму выбора */
); 
procedure fieldsrcdef_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldsrcdef_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldsrcdef_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldsrcdef_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldsrcdef_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldsrcdef_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldsrcdef_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure dinamicfilterscript_BRIEF  (
 aCURSESSION CHAR,
 adinamicfilterscriptid CHAR,
 aBRIEF out varchar2
);
procedure dinamicfilterscript_DELETE  (
 aCURSESSION CHAR,
 adinamicfilterscriptid CHAR,
 ainstanceid char
); 
procedure dinamicfilterscript_SAVE (
 aCURSESSION CHAR,
 adinamicfilterscriptid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Целевая платформа *//* Целевая платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure dinamicfilterscript_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure dinamicfilterscript_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure dinamicfilterscript_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure dinamicfilterscript_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure dinamicfilterscript_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure dinamicfilterscript_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure dinamicfilterscript_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldexpression_BRIEF  (
 aCURSESSION CHAR,
 afieldexpressionid CHAR,
 aBRIEF out varchar2
);
procedure fieldexpression_DELETE  (
 aCURSESSION CHAR,
 afieldexpressionid CHAR,
 ainstanceid char
); 
procedure fieldexpression_SAVE (
 aCURSESSION CHAR,
 afieldexpressionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure fieldexpression_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldexpression_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldexpression_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldexpression_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldexpression_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldexpression_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldexpression_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldvalidator_BRIEF  (
 aCURSESSION CHAR,
 afieldvalidatorid CHAR,
 aBRIEF out varchar2
);
procedure fieldvalidator_DELETE  (
 aCURSESSION CHAR,
 afieldvalidatorid CHAR,
 ainstanceid char
); 
procedure fieldvalidator_SAVE (
 aCURSESSION CHAR,
 afieldvalidatorid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
); 
procedure fieldvalidator_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldvalidator_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldvalidator_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldvalidator_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldvalidator_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldvalidator_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldvalidator_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldmenu_BRIEF  (
 aCURSESSION CHAR,
 afieldmenuid CHAR,
 aBRIEF out varchar2
);
procedure fieldmenu_DELETE  (
 aCURSESSION CHAR,
 afieldmenuid CHAR,
 ainstanceid char
); 
procedure fieldmenu_SAVE (
 aCURSESSION CHAR,
 afieldmenuid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,atooltip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,aactionid CHAR/* Идентификатор вызываемого метода *//* Идентификатор вызываемого метода */
,aismenuitem
 NUMBER/* В меню *//* В меню */
,aistoolbarbutton
 NUMBER/* В тулбар *//* В тулбар */
,ahotkey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
); 
procedure fieldmenu_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldmenu_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldmenu_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldmenu_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldmenu_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldmenu_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldmenu_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fieldparammap_BRIEF  (
 aCURSESSION CHAR,
 afieldparammapid CHAR,
 aBRIEF out varchar2
);
procedure fieldparammap_DELETE  (
 aCURSESSION CHAR,
 afieldparammapid CHAR,
 ainstanceid char
); 
procedure fieldparammap_SAVE (
 aCURSESSION CHAR,
 afieldparammapid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,afieldname
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aparamname
 VARCHAR2/* Параметр *//* Параметр */
,anoedit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
); 
procedure fieldparammap_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fieldparammap_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fieldparammap_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fieldparammap_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fieldparammap_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fieldparammap_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fieldparammap_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure mtzapp_BRIEF  (
 aCURSESSION CHAR,
 amtzappid CHAR,
 aBRIEF out varchar2
);
procedure mtzapp_DELETE  (
 aCURSESSION CHAR,
 amtzappid CHAR,
 ainstanceid char
); 
procedure mtzapp_SAVE (
 aCURSESSION CHAR,
 amtzappid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,adbname
 VARCHAR2 := null /* База данных *//* База данных */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure mtzapp_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure mtzapp_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure mtzapp_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure mtzapp_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure mtzapp_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure mtzapp_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure mtzapp_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure parentpackage_BRIEF  (
 aCURSESSION CHAR,
 aparentpackageid CHAR,
 aBRIEF out varchar2
);
procedure parentpackage_DELETE  (
 aCURSESSION CHAR,
 aparentpackageid CHAR,
 ainstanceid char
); 
procedure parentpackage_SAVE (
 aCURSESSION CHAR,
 aparentpackageid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,apackage CHAR/* Приложение *//* Приложение */
); 
procedure parentpackage_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure parentpackage_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure parentpackage_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure parentpackage_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure parentpackage_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure parentpackage_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure parentpackage_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzmetamodel;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzjrnl" BlockCode=" create or replace package mtzjrnl as

procedure mtzjrnl_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzjrnl_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzjrnl_propagate(acursession CHAR, aROWID CHAR); 

procedure journalcolumn_BRIEF  (
 aCURSESSION CHAR,
 ajournalcolumnid CHAR,
 aBRIEF out varchar2
);
procedure journalcolumn_DELETE  (
 aCURSESSION CHAR,
 ajournalcolumnid CHAR,
 ainstanceid char
); 
procedure journalcolumn_SAVE (
 aCURSESSION CHAR,
 ajournalcolumnid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER := null /* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acolumnalignment
 NUMBER/* Выравнивание *//* Выравнивание */
,acolsort
 NUMBER/* Сортировка колонки *//* Сортировка колонки */
,agroupaggregation
 NUMBER/* Аггрегация при группировке *//* Аггрегация при группировке */
); 
procedure journalcolumn_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure journalcolumn_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure journalcolumn_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure journalcolumn_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure journalcolumn_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure journalcolumn_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure journalcolumn_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure jcolumnsource_BRIEF  (
 aCURSESSION CHAR,
 ajcolumnsourceid CHAR,
 aBRIEF out varchar2
);
procedure jcolumnsource_DELETE  (
 aCURSESSION CHAR,
 ajcolumnsourceid CHAR,
 ainstanceid char
); 
procedure jcolumnsource_SAVE (
 aCURSESSION CHAR,
 ajcolumnsourceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asrcpartview CHAR/* Представление *//* Представление */
,aviewfield
 VARCHAR2/* Поле представления *//* Поле представления */
); 
procedure jcolumnsource_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure jcolumnsource_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure jcolumnsource_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure jcolumnsource_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure jcolumnsource_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure jcolumnsource_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure jcolumnsource_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure journalsrc_BRIEF  (
 aCURSESSION CHAR,
 ajournalsrcid CHAR,
 aBRIEF out varchar2
);
procedure journalsrc_DELETE  (
 aCURSESSION CHAR,
 ajournalsrcid CHAR,
 ainstanceid char
); 
procedure journalsrc_SAVE (
 aCURSESSION CHAR,
 ajournalsrcid CHAR,
aInstanceID CHAR 
,aspartview
 VARCHAR2/* Представление *//* Представление */
,aonrun
 NUMBER/* При открытии *//* При открытии */
,aopenmode
 VARCHAR2 := null /* Режим открытия *//* Режим открытия */
,aviewalias
 VARCHAR2 := null /* Псевдоним представления *//* Псевдоним представления */
); 
procedure journalsrc_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure journalsrc_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure journalsrc_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure journalsrc_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure journalsrc_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure journalsrc_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure journalsrc_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure journal_BRIEF  (
 aCURSESSION CHAR,
 ajournalid CHAR,
 aBRIEF out varchar2
);
procedure journal_DELETE  (
 aCURSESSION CHAR,
 ajournalid CHAR,
 ainstanceid char
); 
procedure journal_SAVE (
 aCURSESSION CHAR,
 ajournalid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,ajrnliconcls
 VARCHAR2 := null /* Иконка журнала *//* Иконка журнала */
,ausefavorites
 NUMBER/* Массовое выделение *//* Массовое выделение */
); 
procedure journal_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure journal_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure journal_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure journal_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure journal_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure journal_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure journal_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzjrnl;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tod" BlockCode=" create or replace package tod as

procedure tod_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure tod_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure tod_propagate(acursession CHAR, aROWID CHAR); 

procedure tod_factory_BRIEF  (
 aCURSESSION CHAR,
 atod_factoryid CHAR,
 aBRIEF out varchar2
);
procedure tod_factory_DELETE  (
 aCURSESSION CHAR,
 atod_factoryid CHAR,
 ainstanceid char
); 
procedure tod_factory_SAVE (
 aCURSESSION CHAR,
 atod_factoryid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Завод *//* Завод */
); 
procedure tod_factory_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_factory_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_factory_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_factory_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_factory_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_factory_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_factory_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_bug_BRIEF  (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 aBRIEF out varchar2
);
procedure tod_bug_DELETE  (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 ainstanceid char
); 
procedure tod_bug_SAVE (
 aCURSESSION CHAR,
 atod_bugid CHAR,
aInstanceID CHAR 
,athe_system CHAR := null /* Узел *//* Узел */
,aname
 VARCHAR2/* Название  *//* Название  */
,athe_comment VARCHAR2 := null /* Примечание *//* Примечание */
); 
procedure tod_bug_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_bug_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_bug_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_bug_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_bug_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_bug_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_bug_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_building_BRIEF  (
 aCURSESSION CHAR,
 atod_buildingid CHAR,
 aBRIEF out varchar2
);
procedure tod_building_DELETE  (
 aCURSESSION CHAR,
 atod_buildingid CHAR,
 ainstanceid char
); 
procedure tod_building_SAVE (
 aCURSESSION CHAR,
 atod_buildingid CHAR,
aInstanceID CHAR 
,athefactory CHAR/* Завод *//* Завод */
,aname
 VARCHAR2/* Цех *//* Цех */
); 
procedure tod_building_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_building_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_building_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_building_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_building_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_building_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_building_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_valtype_BRIEF  (
 aCURSESSION CHAR,
 atod_valtypeid CHAR,
 aBRIEF out varchar2
);
procedure tod_valtype_DELETE  (
 aCURSESSION CHAR,
 atod_valtypeid CHAR,
 ainstanceid char
); 
procedure tod_valtype_SAVE (
 aCURSESSION CHAR,
 atod_valtypeid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aedizm CHAR := null /* Ед. изм. *//* Ед. изм. */
,afieldtype CHAR := null /* Трактовка *//* Трактовка */
); 
procedure tod_valtype_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_valtype_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_valtype_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_valtype_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_valtype_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_valtype_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_valtype_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_model_BRIEF  (
 aCURSESSION CHAR,
 atod_modelid CHAR,
 aBRIEF out varchar2
);
procedure tod_model_DELETE  (
 aCURSESSION CHAR,
 atod_modelid CHAR,
 ainstanceid char
); 
procedure tod_model_SAVE (
 aCURSESSION CHAR,
 atod_modelid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
); 
procedure tod_model_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_model_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_model_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_model_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_model_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_model_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_model_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_system_BRIEF  (
 aCURSESSION CHAR,
 atod_systemid CHAR,
 aBRIEF out varchar2
);
procedure tod_system_DELETE  (
 aCURSESSION CHAR,
 atod_systemid CHAR,
 ainstanceid char
); 
procedure tod_system_SAVE (
 aCURSESSION CHAR,
 atod_systemid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
); 
procedure tod_system_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_system_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_system_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_system_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_system_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_system_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_system_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_oprole_BRIEF  (
 aCURSESSION CHAR,
 atod_oproleid CHAR,
 aBRIEF out varchar2
);
procedure tod_oprole_DELETE  (
 aCURSESSION CHAR,
 atod_oproleid CHAR,
 ainstanceid char
); 
procedure tod_oprole_SAVE (
 aCURSESSION CHAR,
 atod_oproleid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,adocmode
 VARCHAR2 := null /* Режим документов *//* Режим документов */
); 
procedure tod_oprole_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_oprole_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_oprole_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_oprole_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_oprole_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_oprole_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_oprole_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_trand_BRIEF  (
 aCURSESSION CHAR,
 atod_trandid CHAR,
 aBRIEF out varchar2
);
procedure tod_trand_DELETE  (
 aCURSESSION CHAR,
 atod_trandid CHAR,
 ainstanceid char
); 
procedure tod_trand_SAVE (
 aCURSESSION CHAR,
 atod_trandid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
); 
procedure tod_trand_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_trand_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_trand_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_trand_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_trand_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_trand_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_trand_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_st_BRIEF  (
 aCURSESSION CHAR,
 atod_stid CHAR,
 aBRIEF out varchar2
);
procedure tod_st_DELETE  (
 aCURSESSION CHAR,
 atod_stid CHAR,
 ainstanceid char
); 
procedure tod_st_SAVE (
 aCURSESSION CHAR,
 atod_stid CHAR,
aInstanceID CHAR 
,ainvn
 VARCHAR2/* Инвентарный номер *//* Инвентарный номер */
,aname
 VARCHAR2/* Название *//* Название */
,athe_model CHAR := null /* Модель станка *//* Модель станка */
,athebuilding CHAR := null /* Цех *//* Цех */
); 
procedure tod_st_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_st_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_st_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_st_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_st_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_st_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_st_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_material_BRIEF  (
 aCURSESSION CHAR,
 atod_materialid CHAR,
 aBRIEF out varchar2
);
procedure tod_material_DELETE  (
 aCURSESSION CHAR,
 atod_materialid CHAR,
 ainstanceid char
); 
procedure tod_material_SAVE (
 aCURSESSION CHAR,
 atod_materialid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
); 
procedure tod_material_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_material_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_material_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_material_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_material_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_material_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_material_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure tod_edizm_BRIEF  (
 aCURSESSION CHAR,
 atod_edizmid CHAR,
 aBRIEF out varchar2
);
procedure tod_edizm_DELETE  (
 aCURSESSION CHAR,
 atod_edizmid CHAR,
 ainstanceid char
); 
procedure tod_edizm_SAVE (
 aCURSESSION CHAR,
 atod_edizmid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,afullname
 VARCHAR2 := null /* Полное наименование *//* Полное наименование */
); 
procedure tod_edizm_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tod_edizm_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tod_edizm_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tod_edizm_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tod_edizm_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tod_edizm_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tod_edizm_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end tod;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--stdinfostore" BlockCode=" create or replace package stdinfostore as

procedure stdinfostore_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure stdinfostore_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure stdinfostore_propagate(acursession CHAR, aROWID CHAR); 

procedure folder_BRIEF  (
 aCURSESSION CHAR,
 afolderid CHAR,
 aBRIEF out varchar2
);
procedure folder_DELETE  (
 aCURSESSION CHAR,
 afolderid CHAR,
 ainstanceid char
); 
procedure folder_SAVE (
 aCURSESSION CHAR,
 afolderid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aname
 VARCHAR2/* Название *//* Название */
,afoldertype
 NUMBER/* Тип папки *//* Тип папки */
); 
procedure folder_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure folder_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure folder_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure folder_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure folder_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure folder_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure folder_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure shortcut_BRIEF  (
 aCURSESSION CHAR,
 ashortcutid CHAR,
 aBRIEF out varchar2
);
procedure shortcut_DELETE  (
 aCURSESSION CHAR,
 ashortcutid CHAR,
 ainstanceid char
); 
procedure shortcut_SAVE (
 aCURSESSION CHAR,
 ashortcutid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,adocitem CHAR/* Документ *//* Документ */
,astartmode
 VARCHAR2 := null /* Режим *//* Режим */
); 
procedure shortcut_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure shortcut_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure shortcut_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure shortcut_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure shortcut_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure shortcut_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure shortcut_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure infostoredef_BRIEF  (
 aCURSESSION CHAR,
 ainfostoredefid CHAR,
 aBRIEF out varchar2
);
procedure infostoredef_DELETE  (
 aCURSESSION CHAR,
 ainfostoredefid CHAR,
 ainstanceid char
); 
procedure infostoredef_SAVE (
 aCURSESSION CHAR,
 ainfostoredefid CHAR,
aInstanceID CHAR 
,athegroup CHAR := null /* Группа *//* Группа */
,aname
 VARCHAR2/* Название *//* Название */
,ainfostoretype
 NUMBER/* Тип каталога *//* Тип каталога */
,atheuser CHAR := null /* Пользователь *//* Пользователь */
); 
procedure infostoredef_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure infostoredef_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure infostoredef_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure infostoredef_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure infostoredef_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure infostoredef_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure infostoredef_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end stdinfostore;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzsystem" BlockCode=" create or replace package mtzsystem as

procedure mtzsystem_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzsystem_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzsystem_propagate(acursession CHAR, aROWID CHAR); 

procedure the_session_BRIEF  (
 aCURSESSION CHAR,
 athe_sessionid CHAR,
 aBRIEF out varchar2
);
procedure the_session_DELETE  (
 aCURSESSION CHAR,
 athe_sessionid CHAR,
 ainstanceid char
); 
procedure the_session_SAVE (
 aCURSESSION CHAR,
 athe_sessionid CHAR,
aInstanceID CHAR 
,aapplicationid CHAR := null /* Приложение *//* Приложение */
,auserrole CHAR/* Текущая роль пользователя *//* Текущая роль пользователя */
,aclosedat
 DATE := null /* Момент закрытия *//* Момент закрытия */
,aclosed
 NUMBER/* Закрыта *//* Закрыта */
,ausersid CHAR/* Пользователь *//* Пользователь */
,alastaccess
 DATE := null /* Последнее подтверждение *//* Последнее подтверждение */
,astartat
 DATE/* Момент открытия *//* Момент открытия */
,alang
 VARCHAR2 := null /* Локализация *//* Локализация */
,alogin
 VARCHAR2 := null /* Login *//* Login */
); 
procedure the_session_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure the_session_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure the_session_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure the_session_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure the_session_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure the_session_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure the_session_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure sysrefcache_BRIEF  (
 aCURSESSION CHAR,
 asysrefcacheid CHAR,
 aBRIEF out varchar2
);
procedure sysrefcache_DELETE  (
 aCURSESSION CHAR,
 asysrefcacheid CHAR,
 ainstanceid char
); 
procedure sysrefcache_SAVE (
 aCURSESSION CHAR,
 asysrefcacheid CHAR,
aInstanceID CHAR 
,acachetype
 NUMBER/* Тип кеширования *//* Тип кеширования */
,aobjectownerid CHAR/* Идентификатор владельца *//* Идентификатор владельца */
,asessionid CHAR/* Сессия *//* Сессия */
,amodulename
 VARCHAR2 := null /* модуль *//* модуль */
); 
procedure sysrefcache_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure sysrefcache_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure sysrefcache_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure sysrefcache_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure sysrefcache_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure sysrefcache_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure sysrefcache_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure syslog_BRIEF  (
 aCURSESSION CHAR,
 asyslogid CHAR,
 aBRIEF out varchar2
);
procedure syslog_DELETE  (
 aCURSESSION CHAR,
 asyslogid CHAR,
 ainstanceid char
); 
procedure syslog_SAVE (
 aCURSESSION CHAR,
 asyslogid CHAR,
aInstanceID CHAR 
,athesession CHAR/* Сессия *//* Сессия */
,athe_resource
 VARCHAR2/* Ресурс *//* Ресурс */
,alogstructid
 VARCHAR2/* Раздел с которым происхоит действие *//* Раздел с которым происхоит действие */
,averb
 VARCHAR2/* Действие *//* Действие */
,aloginstanceid CHAR := null /* Идентификатор документа *//* Идентификатор документа */
); 
procedure syslog_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure syslog_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure syslog_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure syslog_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure syslog_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure syslog_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure syslog_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzsystem;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzwp" BlockCode=" create or replace package mtzwp as

procedure mtzwp_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzwp_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzwp_propagate(acursession CHAR, aROWID CHAR); 

procedure armjournal_BRIEF  (
 aCURSESSION CHAR,
 aarmjournalid CHAR,
 aBRIEF out varchar2
);
procedure armjournal_DELETE  (
 aCURSESSION CHAR,
 aarmjournalid CHAR,
 ainstanceid char
); 
procedure armjournal_SAVE (
 aCURSESSION CHAR,
 aarmjournalid CHAR,
aInstanceID CHAR 
,athejournal CHAR/* Журнал *//* Журнал */
); 
procedure armjournal_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure armjournal_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure armjournal_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure armjournal_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure armjournal_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure armjournal_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure armjournal_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure armjrnlrep_BRIEF  (
 aCURSESSION CHAR,
 aarmjrnlrepid CHAR,
 aBRIEF out varchar2
);
procedure armjrnlrep_DELETE  (
 aCURSESSION CHAR,
 aarmjrnlrepid CHAR,
 ainstanceid char
); 
procedure armjrnlrep_SAVE (
 aCURSESSION CHAR,
 aarmjrnlrepid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,arepname
 VARCHAR2/* Название отчета *//* Название отчета */
,athereport CHAR/* Отчет *//* Отчет */
); 
procedure armjrnlrep_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure armjrnlrep_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure armjrnlrep_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure armjrnlrep_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure armjrnlrep_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure armjrnlrep_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure armjrnlrep_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure armjrnlrun_BRIEF  (
 aCURSESSION CHAR,
 aarmjrnlrunid CHAR,
 aBRIEF out varchar2
);
procedure armjrnlrun_DELETE  (
 aCURSESSION CHAR,
 aarmjrnlrunid CHAR,
 ainstanceid char
); 
procedure armjrnlrun_SAVE (
 aCURSESSION CHAR,
 aarmjrnlrunid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atheextention CHAR/* Расширение *//* Расширение */
); 
procedure armjrnlrun_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure armjrnlrun_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure armjrnlrun_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure armjrnlrun_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure armjrnlrun_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure armjrnlrun_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure armjrnlrun_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure armjrnladd_BRIEF  (
 aCURSESSION CHAR,
 aarmjrnladdid CHAR,
 aBRIEF out varchar2
);
procedure armjrnladd_DELETE  (
 aCURSESSION CHAR,
 aarmjrnladdid CHAR,
 ainstanceid char
); 
procedure armjrnladd_SAVE (
 aCURSESSION CHAR,
 aarmjrnladdid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atheextention CHAR/* Расширение *//* Расширение */
); 
procedure armjrnladd_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure armjrnladd_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure armjrnladd_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure armjrnladd_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure armjrnladd_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure armjrnladd_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure armjrnladd_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure entrypoints_BRIEF  (
 aCURSESSION CHAR,
 aentrypointsid CHAR,
 aBRIEF out varchar2
);
procedure entrypoints_DELETE  (
 aCURSESSION CHAR,
 aentrypointsid CHAR,
 ainstanceid char
); 
procedure entrypoints_SAVE (
 aCURSESSION CHAR,
 aentrypointsid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aastoolbaritem
 NUMBER/* Включить в тулбар *//* Включить в тулбар */
,aactiontype
 NUMBER/* Вариант действия *//* Вариант действия */
,athefilter CHAR := null /* Фильтр *//* Фильтр */
,ajournal CHAR := null /* Журнал *//* Журнал */
,areport CHAR := null /* Отчет *//* Отчет */
,adocument CHAR := null /* Документ *//* Документ */
,amethod CHAR := null /* Метод *//* Метод */
,aiconfile
 VARCHAR2 := null /* Файл картинки *//* Файл картинки */
,atheextention CHAR := null /* Расширение *//* Расширение */
,aarm CHAR := null /* АРМ *//* АРМ */
,athecomment VARCHAR2 := null /* Примечание *//* Примечание */
,aobjecttype CHAR := null /* Тип документа *//* Тип документа */
,ajournalfixedquery VARCHAR2 := null /* Ограничения к журналу *//* Ограничения к журналу */
,aallowadd
 NUMBER/* Разрешено добавление *//* Разрешено добавление */
,aallowedit
 NUMBER/* Разрешено редактирование *//* Разрешено редактирование */
,aallowdel
 NUMBER/* Рарешено удаление *//* Рарешено удаление */
,aallowfilter
 NUMBER/* Разрешен фильтр *//* Разрешен фильтр */
,aallowprint
 NUMBER/* Разрешена печать *//* Разрешена печать */
); 
procedure entrypoints_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure entrypoints_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure entrypoints_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure entrypoints_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure entrypoints_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure entrypoints_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure entrypoints_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure epfilterlink_BRIEF  (
 aCURSESSION CHAR,
 aepfilterlinkid CHAR,
 aBRIEF out varchar2
);
procedure epfilterlink_DELETE  (
 aCURSESSION CHAR,
 aepfilterlinkid CHAR,
 ainstanceid char
); 
procedure epfilterlink_SAVE (
 aCURSESSION CHAR,
 aepfilterlinkid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,arowsource
 VARCHAR2/* Источник *//* Источник */
,atheexpression VARCHAR2/* Выражение *//* Выражение */
,afilterfield
 VARCHAR2 := null /* Поле фильтра *//* Поле фильтра */
); 
procedure epfilterlink_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure epfilterlink_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure epfilterlink_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure epfilterlink_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure epfilterlink_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure epfilterlink_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure epfilterlink_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure workplace_BRIEF  (
 aCURSESSION CHAR,
 aworkplaceid CHAR,
 aBRIEF out varchar2
);
procedure workplace_DELETE  (
 aCURSESSION CHAR,
 aworkplaceid CHAR,
 ainstanceid char
); 
procedure workplace_SAVE (
 aCURSESSION CHAR,
 aworkplaceid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,atheversion
 VARCHAR2 := null /* Версия *//* Версия */
,atheplatform
 NUMBER := null /* Платформа реализации *//* Платформа реализации */
,athecomment VARCHAR2 := null /* Примечание *//* Примечание */
); 
procedure workplace_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure workplace_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure workplace_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure workplace_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure workplace_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure workplace_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure workplace_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure armtypes_BRIEF  (
 aCURSESSION CHAR,
 aarmtypesid CHAR,
 aBRIEF out varchar2
);
procedure armtypes_DELETE  (
 aCURSESSION CHAR,
 aarmtypesid CHAR,
 ainstanceid char
); 
procedure armtypes_SAVE (
 aCURSESSION CHAR,
 aarmtypesid CHAR,
aInstanceID CHAR 
,athedocumenttype CHAR/* Тип документа *//* Тип документа */
); 
procedure armtypes_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure armtypes_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure armtypes_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure armtypes_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure armtypes_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure armtypes_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure armtypes_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzwp;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--roles" BlockCode=" create or replace package roles as

procedure roles_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure roles_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure roles_propagate(acursession CHAR, aROWID CHAR); 

procedure roles_operations_BRIEF  (
 aCURSESSION CHAR,
 aroles_operationsid CHAR,
 aBRIEF out varchar2
);
procedure roles_operations_DELETE  (
 aCURSESSION CHAR,
 aroles_operationsid CHAR,
 ainstanceid char
); 
procedure roles_operations_SAVE (
 aCURSESSION CHAR,
 aroles_operationsid CHAR,
aInstanceID CHAR 
,ainfo
 VARCHAR2/* Описание *//* Описание */
,aallowaction
 NUMBER/* Разрешено *//* Разрешено */
,aname
 VARCHAR2/* Код *//* Код */
); 
procedure roles_operations_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_operations_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_operations_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_operations_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_operations_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_operations_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_operations_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_wp_BRIEF  (
 aCURSESSION CHAR,
 aroles_wpid CHAR,
 aBRIEF out varchar2
);
procedure roles_wp_DELETE  (
 aCURSESSION CHAR,
 aroles_wpid CHAR,
 ainstanceid char
); 
procedure roles_wp_SAVE (
 aCURSESSION CHAR,
 aroles_wpid CHAR,
aInstanceID CHAR 
,awp CHAR/* Приложение *//* Приложение */
); 
procedure roles_wp_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_wp_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_wp_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_wp_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_wp_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_wp_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_wp_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_act_BRIEF  (
 aCURSESSION CHAR,
 aroles_actid CHAR,
 aBRIEF out varchar2
);
procedure roles_act_DELETE  (
 aCURSESSION CHAR,
 aroles_actid CHAR,
 ainstanceid char
); 
procedure roles_act_SAVE (
 aCURSESSION CHAR,
 aroles_actid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aaccesible
 NUMBER := null /* Доступность *//* Доступность */
,amenuname
 VARCHAR2/* Меню *//* Меню */
,amenucode
 VARCHAR2/* Код пункта меню *//* Код пункта меню */
); 
procedure roles_act_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_act_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_act_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_act_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_act_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_act_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_act_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles2_module_BRIEF  (
 aCURSESSION CHAR,
 aroles2_moduleid CHAR,
 aBRIEF out varchar2
);
procedure roles2_module_DELETE  (
 aCURSESSION CHAR,
 aroles2_moduleid CHAR,
 ainstanceid char
); 
procedure roles2_module_SAVE (
 aCURSESSION CHAR,
 aroles2_moduleid CHAR,
aInstanceID CHAR 
,agroupname
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,acaption
 VARCHAR2/* Надпись *//* Надпись */
,asequence
 NUMBER/* № п/п *//* № п/п */
,amoduleaccessible
 NUMBER/* Разрешен *//* Разрешен */
,acustomizevisibility
 NUMBER/* Настраивать видимость *//* Настраивать видимость */
,atheicon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aname
 VARCHAR2/* Код модуля *//* Код модуля */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,aallobjects
 NUMBER/* Вся фирма *//* Вся фирма */
,acolegsobject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,asubstructobjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
); 
procedure roles2_module_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles2_module_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles2_module_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles2_module_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles2_module_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles2_module_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles2_module_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles2_modreport_BRIEF  (
 aCURSESSION CHAR,
 aroles2_modreportid CHAR,
 aBRIEF out varchar2
);
procedure roles2_modreport_DELETE  (
 aCURSESSION CHAR,
 aroles2_modreportid CHAR,
 ainstanceid char
); 
procedure roles2_modreport_SAVE (
 aCURSESSION CHAR,
 aroles2_modreportid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Код *//* Код */
,aallowaction
 NUMBER/* Разрешен *//* Разрешен */
,acaption
 VARCHAR2/* Надпись *//* Надпись */
,asequence
 NUMBER/* № п/п *//* № п/п */
,atheicon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aisreport
 NUMBER/* Это отчет *//* Это отчет */
,aselecttype
 NUMBER := null /* Вариант выбора *//* Вариант выбора */
); 
procedure roles2_modreport_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles2_modreport_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles2_modreport_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles2_modreport_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles2_modreport_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles2_modreport_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles2_modreport_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_doc_BRIEF  (
 aCURSESSION CHAR,
 aroles_docid CHAR,
 aBRIEF out varchar2
);
procedure roles_doc_DELETE  (
 aCURSESSION CHAR,
 aroles_docid CHAR,
 ainstanceid char
); 
procedure roles_doc_SAVE (
 aCURSESSION CHAR,
 aroles_docid CHAR,
aInstanceID CHAR 
,athe_document CHAR/* Тип документа *//* Тип документа */
,athe_denied
 NUMBER := null /* Запрещен *//* Запрещен */
,aallowdeletedoc
 NUMBER/* Разрешено удаление *//* Разрешено удаление */
); 
procedure roles_doc_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_doc_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_doc_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_doc_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_doc_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_doc_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_doc_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_doc_state_BRIEF  (
 aCURSESSION CHAR,
 aroles_doc_stateid CHAR,
 aBRIEF out varchar2
);
procedure roles_doc_state_DELETE  (
 aCURSESSION CHAR,
 aroles_doc_stateid CHAR,
 ainstanceid char
); 
procedure roles_doc_state_SAVE (
 aCURSESSION CHAR,
 aroles_doc_stateid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_state CHAR := null /* Состояние *//* Состояние */
,athe_mode CHAR := null /* Режим *//* Режим */
,aallowdelete
 NUMBER/* Можно удалять *//* Можно удалять */
,astatechangedisabled
 NUMBER/* Запрещена смена состояния *//* Запрещена смена состояния */
); 
procedure roles_doc_state_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_doc_state_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_doc_state_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_doc_state_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_doc_state_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_doc_state_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_doc_state_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_reports_BRIEF  (
 aCURSESSION CHAR,
 aroles_reportsid CHAR,
 aBRIEF out varchar2
);
procedure roles_reports_DELETE  (
 aCURSESSION CHAR,
 aroles_reportsid CHAR,
 ainstanceid char
); 
procedure roles_reports_SAVE (
 aCURSESSION CHAR,
 aroles_reportsid CHAR,
aInstanceID CHAR 
,athe_report CHAR/* Отчёт *//* Отчёт */
); 
procedure roles_reports_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_reports_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_reports_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_reports_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_reports_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_reports_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_reports_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_user_BRIEF  (
 aCURSESSION CHAR,
 aroles_userid CHAR,
 aBRIEF out varchar2
);
procedure roles_user_DELETE  (
 aCURSESSION CHAR,
 aroles_userid CHAR,
 ainstanceid char
); 
procedure roles_user_SAVE (
 aCURSESSION CHAR,
 aroles_userid CHAR,
aInstanceID CHAR 
,atheuser CHAR/* Пользователь *//* Пользователь */
); 
procedure roles_user_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_user_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_user_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_user_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_user_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_user_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_user_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_map_BRIEF  (
 aCURSESSION CHAR,
 aroles_mapid CHAR,
 aBRIEF out varchar2
);
procedure roles_map_DELETE  (
 aCURSESSION CHAR,
 aroles_mapid CHAR,
 ainstanceid char
); 
procedure roles_map_SAVE (
 aCURSESSION CHAR,
 aroles_mapid CHAR,
aInstanceID CHAR 
,athegroup CHAR/* Группа *//* Группа */
); 
procedure roles_map_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_map_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_map_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_map_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_map_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_map_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_map_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure roles_def_BRIEF  (
 aCURSESSION CHAR,
 aroles_defid CHAR,
 aBRIEF out varchar2
);
procedure roles_def_DELETE  (
 aCURSESSION CHAR,
 aroles_defid CHAR,
 ainstanceid char
); 
procedure roles_def_SAVE (
 aCURSESSION CHAR,
 aroles_defid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aallobjects
 NUMBER/* Вся фирма *//* Вся фирма */
,acolegsobject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,asubstructobjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
); 
procedure roles_def_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure roles_def_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure roles_def_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure roles_def_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure roles_def_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure roles_def_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure roles_def_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end roles;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tosched" BlockCode=" create or replace package tosched as

procedure tosched_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure tosched_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure tosched_propagate(acursession CHAR, aROWID CHAR); 

procedure to_scheditems_BRIEF  (
 aCURSESSION CHAR,
 ato_scheditemsid CHAR,
 aBRIEF out varchar2
);
procedure to_scheditems_DELETE  (
 aCURSESSION CHAR,
 ato_scheditemsid CHAR,
 ainstanceid char
); 
procedure to_scheditems_SAVE (
 aCURSESSION CHAR,
 ato_scheditemsid CHAR,
aInstanceID CHAR 
,athemachine CHAR/* Станок *//* Станок */
,atodate
 DATE/* Плановая дата ТО *//* Плановая дата ТО */
,acheckin
 DATE := null /* Взят в работу *//* Взят в работу */
,aoper CHAR := null /* Оператор *//* Оператор */
,aisdone
 NUMBER := null /* ТО проведено *//* ТО проведено */
,afinishdate
 DATE := null /* Дата завершения ТО *//* Дата завершения ТО */
); 
procedure to_scheditems_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_scheditems_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_scheditems_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_scheditems_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_scheditems_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_scheditems_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_scheditems_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure to_schedinfo_BRIEF  (
 aCURSESSION CHAR,
 ato_schedinfoid CHAR,
 aBRIEF out varchar2
);
procedure to_schedinfo_DELETE  (
 aCURSESSION CHAR,
 ato_schedinfoid CHAR,
 ainstanceid char
); 
procedure to_schedinfo_SAVE (
 aCURSESSION CHAR,
 ato_schedinfoid CHAR,
aInstanceID CHAR 
,adfrom
 DATE/* С *//* С */
,adto
 DATE := null /* По *//* По */
); 
procedure to_schedinfo_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_schedinfo_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_schedinfo_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_schedinfo_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_schedinfo_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_schedinfo_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_schedinfo_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end tosched;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--totrn" BlockCode=" create or replace package totrn as

procedure totrn_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure totrn_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure totrn_propagate(acursession CHAR, aROWID CHAR); 

procedure totrn_data_BRIEF  (
 aCURSESSION CHAR,
 atotrn_dataid CHAR,
 aBRIEF out varchar2
);
procedure totrn_data_DELETE  (
 aCURSESSION CHAR,
 atotrn_dataid CHAR,
 ainstanceid char
); 
procedure totrn_data_SAVE (
 aCURSESSION CHAR,
 atotrn_dataid CHAR,
aInstanceID CHAR 
,atime_label
 DATE/* Временная метка *//* Временная метка */
,athevalue
 NUMBER/* Значение *//* Значение */
); 
procedure totrn_data_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure totrn_data_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure totrn_data_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure totrn_data_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure totrn_data_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure totrn_data_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure totrn_data_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure totrn_def_BRIEF  (
 aCURSESSION CHAR,
 atotrn_defid CHAR,
 aBRIEF out varchar2
);
procedure totrn_def_DELETE  (
 aCURSESSION CHAR,
 atotrn_defid CHAR,
 ainstanceid char
); 
procedure totrn_def_SAVE (
 aCURSESSION CHAR,
 atotrn_defid CHAR,
aInstanceID CHAR 
,athemachine CHAR/* Станок *//* Станок */
,atrandtype CHAR/* Тип тренда *//* Тип тренда */
,atopvalue
 NUMBER := null /* Верхняя граница *//* Верхняя граница */
,abottomval
 NUMBER := null /* Нижняя граница *//* Нижняя граница */
); 
procedure totrn_def_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure totrn_def_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure totrn_def_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure totrn_def_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure totrn_def_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure totrn_def_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure totrn_def_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end totrn;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--totask" BlockCode=" create or replace package totask as

procedure totask_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure totask_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure totask_propagate(acursession CHAR, aROWID CHAR); 

procedure to_taskcomment_BRIEF  (
 aCURSESSION CHAR,
 ato_taskcommentid CHAR,
 aBRIEF out varchar2
);
procedure to_taskcomment_DELETE  (
 aCURSESSION CHAR,
 ato_taskcommentid CHAR,
 ainstanceid char
); 
procedure to_taskcomment_SAVE (
 aCURSESSION CHAR,
 ato_taskcommentid CHAR,
aInstanceID CHAR 
,acodetocomment CHAR := null /* Узел *//* Узел */
,athecomment VARCHAR2/* Примечание *//* Примечание */
,athe_operator CHAR/* Оператор *//* Оператор */
,athe_date
 DATE/* Дата комментария *//* Дата комментария */
); 
procedure to_taskcomment_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_taskcomment_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_taskcomment_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_taskcomment_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_taskcomment_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_taskcomment_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_taskcomment_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure to_taskinfo_BRIEF  (
 aCURSESSION CHAR,
 ato_taskinfoid CHAR,
 aBRIEF out varchar2
);
procedure to_taskinfo_DELETE  (
 aCURSESSION CHAR,
 ato_taskinfoid CHAR,
 ainstanceid char
); 
procedure to_taskinfo_SAVE (
 aCURSESSION CHAR,
 ato_taskinfoid CHAR,
aInstanceID CHAR 
,athemachine CHAR/* Пункт расписания *//* Пункт расписания */
,aoper CHAR/* Оператор *//* Оператор */
,athecard CHAR := null /* Диагностическая карта *//* Диагностическая карта */
,acrdate
 DATE/* Дата создания *//* Дата создания */
,ataskfinished
 NUMBER := null /* Задача завершена *//* Задача завершена */
,afinishtime
 DATE := null /* Время завершения задачи *//* Время завершения задачи */
); 
procedure to_taskinfo_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_taskinfo_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_taskinfo_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_taskinfo_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_taskinfo_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_taskinfo_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_taskinfo_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure to_taskchecks_BRIEF  (
 aCURSESSION CHAR,
 ato_taskchecksid CHAR,
 aBRIEF out varchar2
);
procedure to_taskchecks_DELETE  (
 aCURSESSION CHAR,
 ato_taskchecksid CHAR,
 ainstanceid char
); 
procedure to_taskchecks_SAVE (
 aCURSESSION CHAR,
 ato_taskchecksid CHAR,
aInstanceID CHAR 
,athe_system CHAR/* Группа узлов *//* Группа узлов */
,athesubsystem
 VARCHAR2/* Узел *//* Узел */
,athe_check
 VARCHAR2/* Показатель *//* Показатель */
,anormochas
 NUMBER := null /* Нормочас *//* Нормочас */
,avaluetype CHAR/* Измерение *//* Измерение */
,alowvalue
 VARCHAR2 := null /* Нижняя граница (&gt;=) *//* Нижняя граница (&gt;=) */
,ahivalue
 VARCHAR2 := null /* Верхняя граница (&lt;=) *//* Верхняя граница (&lt;=) */
,athe_comment VARCHAR2 := null /* Примечание *//* Примечание */
,athevalue
 VARCHAR2 := null /* Значение *//* Значение */
,athe_doc VARCHAR2 := null /* Документация *//* Документация */
,acheckref CHAR/* Основание для проверки *//* Основание для проверки */
,atagid
 VARCHAR2 := null /* Метка *//* Метка */
,atagtime
 DATE := null /* Дата регистрации метки *//* Дата регистрации метки */
); 
procedure to_taskchecks_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_taskchecks_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_taskchecks_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_taskchecks_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_taskchecks_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_taskchecks_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_taskchecks_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure to_taskcheckcomment_BRIEF  (
 aCURSESSION CHAR,
 ato_taskcheckcommentid CHAR,
 aBRIEF out varchar2
);
procedure to_taskcheckcomment_DELETE  (
 aCURSESSION CHAR,
 ato_taskcheckcommentid CHAR,
 ainstanceid char
); 
procedure to_taskcheckcomment_SAVE (
 aCURSESSION CHAR,
 ato_taskcheckcommentid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_operator CHAR/* Оператор *//* Оператор */
,athe_date
 DATE/* Дата комментария *//* Дата комментария */
,ainfo VARCHAR2/* Суть комментария *//* Суть комментария */
); 
procedure to_taskcheckcomment_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_taskcheckcomment_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_taskcheckcomment_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_taskcheckcomment_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_taskcheckcomment_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_taskcheckcomment_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_taskcheckcomment_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end totask;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzusers" BlockCode=" create or replace package mtzusers as

procedure mtzusers_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzusers_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzusers_propagate(acursession CHAR, aROWID CHAR); 

procedure users_BRIEF  (
 aCURSESSION CHAR,
 ausersid CHAR,
 aBRIEF out varchar2
);
procedure users_DELETE  (
 aCURSESSION CHAR,
 ausersid CHAR,
 ainstanceid char
); 
procedure users_SAVE (
 aCURSESSION CHAR,
 ausersid CHAR,
aInstanceID CHAR 
,afamily
 VARCHAR2/* Фамилия *//* Фамилия */
,aname
 VARCHAR2/* Имя *//* Имя */
,asurname
 VARCHAR2/* Отчество *//* Отчество */
,alogin
 VARCHAR2/* Имя для входа *//* Имя для входа */
,apassword VARCHAR2 := null /* Пароль *//* Пароль */
,adomainame
 VARCHAR2 := null /* Доменное имя *//* Доменное имя */
,aemail VARCHAR2 := null /* e-mail *//* e-mail */
,aphone
 VARCHAR2 := null /* Телефон *//* Телефон */
,alocalphone
 VARCHAR2 := null /* Местный телефон *//* Местный телефон */
); 
procedure users_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure users_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure users_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure users_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure users_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure users_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure users_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure groups_BRIEF  (
 aCURSESSION CHAR,
 agroupsid CHAR,
 aBRIEF out varchar2
);
procedure groups_DELETE  (
 aCURSESSION CHAR,
 agroupsid CHAR,
 ainstanceid char
); 
procedure groups_SAVE (
 aCURSESSION CHAR,
 agroupsid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aadgroup
 VARCHAR2 := null /* Группа AD *//* Группа AD */
); 
procedure groups_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure groups_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure groups_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure groups_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure groups_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure groups_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure groups_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure groupuser_BRIEF  (
 aCURSESSION CHAR,
 agroupuserid CHAR,
 aBRIEF out varchar2
);
procedure groupuser_DELETE  (
 aCURSESSION CHAR,
 agroupuserid CHAR,
 ainstanceid char
); 
procedure groupuser_SAVE (
 aCURSESSION CHAR,
 agroupuserid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atheuser CHAR/* Пользователь *//* Пользователь */
); 
procedure groupuser_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure groupuser_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure groupuser_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure groupuser_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure groupuser_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure groupuser_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure groupuser_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzusers;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--toop" BlockCode=" create or replace package toop as

procedure toop_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure toop_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure toop_propagate(acursession CHAR, aROWID CHAR); 

procedure to_oper_BRIEF  (
 aCURSESSION CHAR,
 ato_operid CHAR,
 aBRIEF out varchar2
);
procedure to_oper_DELETE  (
 aCURSESSION CHAR,
 ato_operid CHAR,
 ainstanceid char
); 
procedure to_oper_SAVE (
 aCURSESSION CHAR,
 ato_operid CHAR,
aInstanceID CHAR 
,afamilyname
 VARCHAR2/* Фамилия *//* Фамилия */
,aname
 VARCHAR2/* Имя *//* Имя */
,asurname
 VARCHAR2/* Отчество *//* Отчество */
,atnum
 VARCHAR2 := null /* Табельный номер *//* Табельный номер */
,atherole CHAR := null /* Роль *//* Роль */
,alogin
 VARCHAR2 := null /* Логин *//* Логин */
); 
procedure to_oper_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_oper_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_oper_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_oper_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_oper_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_oper_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_oper_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end toop;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--stdnumerator" BlockCode=" create or replace package stdnumerator as

procedure stdnumerator_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure stdnumerator_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure stdnumerator_propagate(acursession CHAR, aROWID CHAR); 

procedure num_zones_BRIEF  (
 aCURSESSION CHAR,
 anum_zonesid CHAR,
 aBRIEF out varchar2
);
procedure num_zones_DELETE  (
 aCURSESSION CHAR,
 anum_zonesid CHAR,
 ainstanceid char
); 
procedure num_zones_SAVE (
 aCURSESSION CHAR,
 anum_zonesid CHAR,
aInstanceID CHAR 
,azonemask
 VARCHAR2/* Маска зоны *//* Маска зоны */
); 
procedure num_zones_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure num_zones_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure num_zones_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure num_zones_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure num_zones_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure num_zones_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure num_zones_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure num_values_BRIEF  (
 aCURSESSION CHAR,
 anum_valuesid CHAR,
 aBRIEF out varchar2
);
procedure num_values_DELETE  (
 aCURSESSION CHAR,
 anum_valuesid CHAR,
 ainstanceid char
); 
procedure num_values_SAVE (
 aCURSESSION CHAR,
 anum_valuesid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_value
 NUMBER/* Значение *//* Значение */
,aownerpartname
 VARCHAR2 := null /* Раздел *//* Раздел */
,aownerrowid CHAR := null /* Идентификатор строки *//* Идентификатор строки */
); 
procedure num_values_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure num_values_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure num_values_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure num_values_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure num_values_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure num_values_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure num_values_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure num_head_BRIEF  (
 aCURSESSION CHAR,
 anum_headid CHAR,
 aBRIEF out varchar2
);
procedure num_head_DELETE  (
 aCURSESSION CHAR,
 anum_headid CHAR,
 ainstanceid char
); 
procedure num_head_SAVE (
 aCURSESSION CHAR,
 anum_headid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,ashema
 NUMBER/* Схема нумерации *//* Схема нумерации */
); 
procedure num_head_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure num_head_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure num_head_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure num_head_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure num_head_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure num_head_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure num_head_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end stdnumerator;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tor" BlockCode=" create or replace package tor as

procedure tor_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure tor_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure tor_propagate(acursession CHAR, aROWID CHAR); 

procedure tor_info_BRIEF  (
 aCURSESSION CHAR,
 ator_infoid CHAR,
 aBRIEF out varchar2
);
procedure tor_info_DELETE  (
 aCURSESSION CHAR,
 ator_infoid CHAR,
 ainstanceid char
); 
procedure tor_info_SAVE (
 aCURSESSION CHAR,
 ator_infoid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название станции *//* Название станции */
,aserverdata
 DATE := null /* Дата сервер *//* Дата сервер */
,aclientdata
 DATE := null /* Дата клиент *//* Дата клиент */
); 
procedure tor_info_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure tor_info_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure tor_info_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure tor_info_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure tor_info_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure tor_info_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure tor_info_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end tor;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzext" BlockCode=" create or replace package mtzext as

procedure mtzext_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzext_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzext_propagate(acursession CHAR, aROWID CHAR); 

procedure mtzext_def_BRIEF  (
 aCURSESSION CHAR,
 amtzext_defid CHAR,
 aBRIEF out varchar2
);
procedure mtzext_def_DELETE  (
 aCURSESSION CHAR,
 amtzext_defid CHAR,
 ainstanceid char
); 
procedure mtzext_def_SAVE (
 aCURSESSION CHAR,
 amtzext_defid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aexttype
 NUMBER/* Тип расширения *//* Тип расширения */
,athedescription VARCHAR2 := null /* Описание *//* Описание */
); 
procedure mtzext_def_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure mtzext_def_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure mtzext_def_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure mtzext_def_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure mtzext_def_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure mtzext_def_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure mtzext_def_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure mtzextrel_BRIEF  (
 aCURSESSION CHAR,
 amtzextrelid CHAR,
 aBRIEF out varchar2
);
procedure mtzextrel_DELETE  (
 aCURSESSION CHAR,
 amtzextrelid CHAR,
 ainstanceid char
); 
procedure mtzextrel_SAVE (
 aCURSESSION CHAR,
 amtzextrelid CHAR,
aInstanceID CHAR 
,atheplatform
 NUMBER/* Реализация *//* Реализация */
,atheclassname
 VARCHAR2/* Название класса *//* Название класса */
,athelibraryname
 VARCHAR2 := null /* Название библиотеки *//* Название библиотеки */
); 
procedure mtzextrel_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure mtzextrel_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure mtzextrel_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure mtzextrel_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure mtzextrel_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure mtzextrel_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure mtzextrel_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzext;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tocard" BlockCode=" create or replace package tocard as

procedure tocard_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure tocard_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure tocard_propagate(acursession CHAR, aROWID CHAR); 

procedure to_cardinfo_BRIEF  (
 aCURSESSION CHAR,
 ato_cardinfoid CHAR,
 aBRIEF out varchar2
);
procedure to_cardinfo_DELETE  (
 aCURSESSION CHAR,
 ato_cardinfoid CHAR,
 ainstanceid char
); 
procedure to_cardinfo_SAVE (
 aCURSESSION CHAR,
 ato_cardinfoid CHAR,
aInstanceID CHAR 
,athe_machine CHAR/* Станок *//* Станок */
,acard_date
 DATE := null /* Дата составления карты *//* Дата составления карты */
,acard_archived
 NUMBER := null /* Архивная карта *//* Архивная карта */
); 
procedure to_cardinfo_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_cardinfo_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_cardinfo_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_cardinfo_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_cardinfo_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_cardinfo_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_cardinfo_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure to_cardchecks_BRIEF  (
 aCURSESSION CHAR,
 ato_cardchecksid CHAR,
 aBRIEF out varchar2
);
procedure to_cardchecks_DELETE  (
 aCURSESSION CHAR,
 ato_cardchecksid CHAR,
 ainstanceid char
); 
procedure to_cardchecks_SAVE (
 aCURSESSION CHAR,
 ato_cardchecksid CHAR,
aInstanceID CHAR 
,athe_system CHAR/* Группа узлов *//* Группа узлов */
,athesubsystem
 VARCHAR2 := null /* Узел *//* Узел */
,athe_check
 VARCHAR2/* Показатель *//* Показатель */
,anormochas
 NUMBER/* Нормочас *//* Нормочас */
,avaluetype CHAR/* Измерение *//* Измерение */
,alowvalue
 VARCHAR2 := null /* Нижняя граница (&gt;=) *//* Нижняя граница (&gt;=) */
,ahivalue
 VARCHAR2 := null /* Верхняя граница (&lt;=) *//* Верхняя граница (&lt;=) */
,athe_comment VARCHAR2 := null /* Примечание *//* Примечание */
,atagid
 VARCHAR2 := null /* Метка *//* Метка */
,athe_doc VARCHAR2 := null /* Документация *//* Документация */
); 
procedure to_cardchecks_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_cardchecks_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_cardchecks_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_cardchecks_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_cardchecks_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_cardchecks_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_cardchecks_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure to_carddevices_BRIEF  (
 aCURSESSION CHAR,
 ato_carddevicesid CHAR,
 aBRIEF out varchar2
);
procedure to_carddevices_DELETE  (
 aCURSESSION CHAR,
 ato_carddevicesid CHAR,
 ainstanceid char
); 
procedure to_carddevices_SAVE (
 aCURSESSION CHAR,
 ato_carddevicesid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,amat CHAR/* Требуется *//* Требуется */
); 
procedure to_carddevices_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure to_carddevices_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure to_carddevices_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure to_carddevices_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure to_carddevices_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure to_carddevices_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure to_carddevices_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end tocard;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--toimg" BlockCode=" create or replace package toimg as

procedure toimg_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure toimg_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure toimg_propagate(acursession CHAR, aROWID CHAR); 

procedure toimg_data_BRIEF  (
 aCURSESSION CHAR,
 atoimg_dataid CHAR,
 aBRIEF out varchar2
);
procedure toimg_data_DELETE  (
 aCURSESSION CHAR,
 atoimg_dataid CHAR,
 ainstanceid char
); 
procedure toimg_data_SAVE (
 aCURSESSION CHAR,
 atoimg_dataid CHAR,
aInstanceID CHAR 
,afname
 VARCHAR2/* Имя файла *//* Имя файла */
,alink2part
 VARCHAR2/* Раздел привязки *//* Раздел привязки */
,alink2id
 VARCHAR2/* Идентификатор привязки *//* Идентификатор привязки */
,afiletype
 VARCHAR2 := null /* Тип файла *//* Тип файла */
,alink1part
 VARCHAR2 := null /* Раздел2 *//* Раздел2 */
,alink1id
 VARCHAR2 := null /* Идентификатор2 *//* Идентификатор2 */
,aoper CHAR := null /* Оператор *//* Оператор */
); 
procedure toimg_data_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure toimg_data_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure toimg_data_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure toimg_data_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure toimg_data_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure toimg_data_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure toimg_data_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure toimg_todelete_BRIEF  (
 aCURSESSION CHAR,
 atoimg_todeleteid CHAR,
 aBRIEF out varchar2
);
procedure toimg_todelete_DELETE  (
 aCURSESSION CHAR,
 atoimg_todeleteid CHAR,
 ainstanceid char
); 
procedure toimg_todelete_SAVE (
 aCURSESSION CHAR,
 atoimg_todeleteid CHAR,
aInstanceID CHAR 
,afname
 VARCHAR2/* Имя файла *//* Имя файла */
,afilerowid
 VARCHAR2 := null /* ид строки дя удаления *//* ид строки дя удаления */
); 
procedure toimg_todelete_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure toimg_todelete_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure toimg_todelete_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure toimg_todelete_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure toimg_todelete_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure toimg_todelete_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure toimg_todelete_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure toimg_def_BRIEF  (
 aCURSESSION CHAR,
 atoimg_defid CHAR,
 aBRIEF out varchar2
);
procedure toimg_def_DELETE  (
 aCURSESSION CHAR,
 atoimg_defid CHAR,
 ainstanceid char
); 
procedure toimg_def_SAVE (
 aCURSESSION CHAR,
 atoimg_defid CHAR,
aInstanceID CHAR 
,acomputername
 VARCHAR2 := null /* Имя  станции *//* Имя  станции */
,aimagestore
 VARCHAR2 := null /* Папка с фотографиями *//* Папка с фотографиями */
,asharedfolder
 VARCHAR2 := null /* Имя общей директории *//* Имя общей директории */
); 
procedure toimg_def_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure toimg_def_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure toimg_def_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure toimg_def_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure toimg_def_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure toimg_def_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure toimg_def_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end toimg;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtz2job" BlockCode=" create or replace package mtz2job as

procedure mtz2job_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtz2job_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtz2job_propagate(acursession CHAR, aROWID CHAR); 

procedure mtz2job_def_BRIEF  (
 aCURSESSION CHAR,
 amtz2job_defid CHAR,
 aBRIEF out varchar2
);
procedure mtz2job_def_DELETE  (
 aCURSESSION CHAR,
 amtz2job_defid CHAR,
 ainstanceid char
); 
procedure mtz2job_def_SAVE (
 aCURSESSION CHAR,
 amtz2job_defid CHAR,
aInstanceID CHAR 
,aeventdate
 DATE/* Отложено до *//* Отложено до */
,aeventype
 VARCHAR2/* Тип события *//* Тип события */
,athruobject CHAR/* Объект - причина события *//* Объект - причина события */
,athrustate CHAR := null /* Состояние - причина *//* Состояние - причина */
,anextstate CHAR := null /* Состояние после обработки *//* Состояние после обработки */
,aprocessdate
 DATE := null /* Момент обработки *//* Момент обработки */
,aprocessed
 NUMBER/* Обработан *//* Обработан */
); 
procedure mtz2job_def_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure mtz2job_def_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure mtz2job_def_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure mtz2job_def_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure mtz2job_def_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure mtz2job_def_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure mtz2job_def_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtz2job;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzfltr" BlockCode=" create or replace package mtzfltr as

procedure mtzfltr_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzfltr_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzfltr_propagate(acursession CHAR, aROWID CHAR); 

procedure filterfieldgroup_BRIEF  (
 aCURSESSION CHAR,
 afilterfieldgroupid CHAR,
 aBRIEF out varchar2
);
procedure filterfieldgroup_DELETE  (
 aCURSESSION CHAR,
 afilterfieldgroupid CHAR,
 ainstanceid char
); 
procedure filterfieldgroup_SAVE (
 aCURSESSION CHAR,
 afilterfieldgroupid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aallowignore
 NUMBER/* Можно отключать *//* Можно отключать */
); 
procedure filterfieldgroup_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure filterfieldgroup_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure filterfieldgroup_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure filterfieldgroup_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure filterfieldgroup_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure filterfieldgroup_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure filterfieldgroup_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure fileterfield_BRIEF  (
 aCURSESSION CHAR,
 afileterfieldid CHAR,
 aBRIEF out varchar2
);
procedure fileterfield_DELETE  (
 aCURSESSION CHAR,
 afileterfieldid CHAR,
 ainstanceid char
); 
procedure fileterfield_SAVE (
 aCURSESSION CHAR,
 afileterfieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,afieldtype CHAR/* Тип поля *//* Тип поля */
,afieldsize
 NUMBER := null /* Размер *//* Размер */
,areftype
 NUMBER := null /* Тип ссылки *//* Тип ссылки */
,areftotype CHAR := null /* Тип, куда ссылаемся *//* Тип, куда ссылаемся */
,areftopart CHAR := null /* Раздел, куда ссылаемся *//* Раздел, куда ссылаемся */
,avaluearray
 NUMBER/* Массив значений *//* Массив значений */
); 
procedure fileterfield_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure fileterfield_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure fileterfield_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure fileterfield_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure fileterfield_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure fileterfield_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure fileterfield_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure filters_BRIEF  (
 aCURSESSION CHAR,
 afiltersid CHAR,
 aBRIEF out varchar2
);
procedure filters_DELETE  (
 aCURSESSION CHAR,
 afiltersid CHAR,
 ainstanceid char
); 
procedure filters_SAVE (
 aCURSESSION CHAR,
 afiltersid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athecaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure filters_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure filters_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure filters_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure filters_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure filters_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure filters_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure filters_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzfltr;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzrprt" BlockCode=" create or replace package mtzrprt as

procedure mtzrprt_DELETE(acursession CHAR, aInstanceID CHAR);  
procedure mtzrprt_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer);
procedure mtzrprt_propagate(acursession CHAR, aROWID CHAR); 

procedure rptstruct_BRIEF  (
 aCURSESSION CHAR,
 arptstructid CHAR,
 aBRIEF out varchar2
);
procedure rptstruct_DELETE  (
 aCURSESSION CHAR,
 arptstructid CHAR,
 ainstanceid char
); 
procedure rptstruct_SAVE (
 aCURSESSION CHAR,
 arptstructid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
); 
procedure rptstruct_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure rptstruct_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure rptstruct_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure rptstruct_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure rptstruct_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure rptstruct_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure rptstruct_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure rptfields_BRIEF  (
 aCURSESSION CHAR,
 arptfieldsid CHAR,
 aBRIEF out varchar2
);
procedure rptfields_DELETE  (
 aCURSESSION CHAR,
 arptfieldsid CHAR,
 ainstanceid char
); 
procedure rptfields_SAVE (
 aCURSESSION CHAR,
 arptfieldsid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,afieldtype CHAR/* Тип поля *//* Тип поля */
,afieldsize
 NUMBER := null /* Размер *//* Размер */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
); 
procedure rptfields_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure rptfields_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure rptfields_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure rptfields_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure rptfields_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure rptfields_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure rptfields_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure rptformula_BRIEF  (
 aCURSESSION CHAR,
 arptformulaid CHAR,
 aBRIEF out varchar2
);
procedure rptformula_DELETE  (
 aCURSESSION CHAR,
 arptformulaid CHAR,
 ainstanceid char
); 
procedure rptformula_SAVE (
 aCURSESSION CHAR,
 arptformulaid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acode VARCHAR2 := null /* Выражение *//* Выражение */
,aplatform CHAR := null /* Платформа *//* Платформа */
); 
procedure rptformula_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure rptformula_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure rptformula_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure rptformula_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure rptformula_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure rptformula_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure rptformula_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);

procedure reports_BRIEF  (
 aCURSESSION CHAR,
 areportsid CHAR,
 aBRIEF out varchar2
);
procedure reports_DELETE  (
 aCURSESSION CHAR,
 areportsid CHAR,
 ainstanceid char
); 
procedure reports_SAVE (
 aCURSESSION CHAR,
 areportsid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,areportfile VARCHAR2 := null /* Файл отчета */
,areportfile_EXT varchar2 /* Файл отчета */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,apreparemethod CHAR := null /* Метод для формирования *//* Метод для формирования */
,areporttype
 NUMBER/* Тип отчета *//* Тип отчета */
,athereportext CHAR := null /* Расширение для создания отчета *//* Расширение для создания отчета */
,areportview
 VARCHAR2 := null /* Базовый запрос *//* Базовый запрос */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
); 
procedure reports_PARENT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR,
 aParentTable out varchar2
) ;
procedure reports_ISLOCKED  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) ;
procedure reports_LOCK  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
);
procedure reports_HCL(
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
);
procedure reports_UNLOCK (
 aCURSESSION CHAR,
 aRowID CHAR 
);
procedure reports_SINIT  (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
);
procedure reports_propagate(
 aCURSESSION CHAR,
 aRowID CHAR
);
end mtzrprt;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Methods" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Custom" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
/* GetFreeNumber  Свободный номер из нумератора*/
create or replace procedure GetFreeNumber

(athe_zone VARCHAR2/* Зона */

,anumeratorid CHAR/* нумератор */

,anum out  NUMBER/* номер */

)
 as 
an integer;
aid1 char(38);
aid2 char(38);
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=aNumeratorID;
if existsCnt=0 then
  insert into instance(instanceid,name,objtype) values(aNumeratorID,'Numerator','STDNumerator');
end if;

select count(*) into existsCnt from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    an :=1;
    aID1 := newid();
    aID2 := newid();
    insert into num_zones(num_zonesid,instanceid, zonemask) values(aid1,aNumeratorID, athe_zone);
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
   anum:=an;
    return;
else
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt from num_values where parentStructRowID=aID1;
  if existsCnt=0 then
      an :=1;
      anum:=1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      return;
  else

     begin
      select  min(the_value) into an from num_values where parentStructRowID=aID1 and the_value+1
      not in (select the_value from num_values where parentStructRowID=aID1);
     exception when others then
       an:=null;
     end;
      if an is null then
        select  max(the_value)+1 into an from num_values where parentStructRowID=aID1;
      else
        an := an + 1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      anum := an;
    end if;
  end if;
end if;
end;

/
/* AutoCloseSession  Автоматическое закрытие протухщих сессий*/
create or replace procedure AutoCloseSession

 as 
asid char(38);
begin
declare cursor closer is
select the_sessionid id from the_session where lastaccess &lt; (sysdate()-0.008) and closed =0;
closer_rec  closer%ROWTYPE;
begin
 --open closer;
 for closer_rec in closer loop
   Logout (closer_rec.id);
 end loop;
close closer;
end;
end;



/
/* GetNewNumber  Следующий номер из нумератора 
*/
create or replace procedure GetNewNumber

(anum out  NUMBER/* номер */

,athe_zone VARCHAR2/* Зона */

,anumeratorid CHAR/* нумератор */

)
 as 

/**********************************
declare @n integer
declare @id1 uniqueidentifier
declare @id2 uniqueidentifier
begin
if not exists(select 1 from instance where instanceid=@NumeratorID)
insert into instance(instanceid,name,objtype) values(@NumeratorID,'Numerator','STDNumerator')

if not exists(select 1 from num_zones where zonemask=@zone and instanceid=@NumeratorID)
  begin
    set @num =1
    set @ID1 = newid()
    set @ID2 = newid()
    insert into num_zones(num_zonesid,instanceid, zonemask) values(@id1,@NumeratorID, @zone)
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(@id2,@ID1, @num)
    return
  end
else
  begin
  select @ID1=num_zonesid from num_zones where zonemask=@zone and instanceid=@NumeratorID
  if not exists(select 1 from num_values where parentStructRowID=@ID1 )
    begin
      set @num =1
      set @ID2 = newid()
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(@id2,@ID1, @num)
      return
    end
  else
    begin
      select @n = max(the_value)+1 from num_values where parentStructRowID=@ID1
      set @ID2 = newid()
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(@id2,@ID1, @n)
      set @num = @n
    end
  end
end
************************************************************/

an integer;
aid1 char(38);
aid2 char(38);
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=aNumeratorID;
if existsCnt=0 then
  insert into instance(instanceid,name,objtype) values(aNumeratorID,'Numerator','STDNumerator');
end if;

select count(*) into existsCnt from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    an :=1;
    aID1 := newid();
    aID2 := newid();
    insert into num_zones(num_zonesid,instanceid, zonemask) values(aid1,aNumeratorID, athe_zone);
    insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
   anum:=an;
    return;
else
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt from num_values where parentStructRowID=aID1;
  if existsCnt=0 then
      an :=1;
      anum:=1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      return;
  else

     begin
      select  min(the_value) into an from num_values where parentStructRowID=aID1 and the_value+1
      not in (select the_value from num_values where parentStructRowID=aID1);
     exception when others then
       an:=null;
     end;
      if an is null then
        select  max(the_value)+1 into an from num_values where parentStructRowID=aID1;
      else
        an := an + 1;
      aID2 := newid();
      insert into num_Values(num_valuesid,parentstructrowid, the_Value) values(aid2,aID1, an);
      anum := an;
    end if;
  end if;
end if;
end;

/
/* EraseNumber  Удалить номер из нумератора*/
create or replace procedure EraseNumber

(anumeratorid CHAR/* нумератор */

,athe_zone VARCHAR2/* Зона */

,anum NUMBER/* номер */

)
 as 
aid1 char(38);
existsCnt integer;
begin
select count(*) into existsCnt  from instance where instanceid=aNumeratorID;
if existsCnt=0 then
return;
end if;
select count(*) into existsCnt  from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
if existsCnt=0 then
    return ;
else
  select num_zonesid into aID1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID;
  select count(*) into existsCnt  from num_values where parentStructRowID=aID1 ;
  if  existsCnt=0 then
      return;
  else
     delete from num_values where parentStructRowID=aID1 and the_value=anum;
  end if;
end if;
end;

/
/* SessionCheckPoint  Автоматическое закрытие &quot;Подвисших&quot; сессий*/
create or replace procedure SessionCheckPoint

(acursession CHAR/* Текущая сессия */

)
 as 
cursor s is select the_sessionid id from the_session
where lastAccess &lt;sysdate()-1;
s_rec s%rowtype;
begin
--open s;
for s_rec in s loop
  logout(s_rec.id);
End loop;
Close s;
end;





/
/* CheckVerbRight  Проверка прав на действие*/
create or replace procedure CheckVerbRight

(acursession CHAR/* Сессия */

,athe_resource CHAR/* идентификатор стиля прав */

,averb VARCHAR2/* Действие */

,aaccess out  NUMBER/* Разрешение */

)
 as 
apr integer;
aallow integer;
begin
if athe_resource is null 
then
	aaccess :=1;
	return;
end if;
/*
declare  cursor tst is
SELECT     
  MTZSEC_RIGHT.Allow,  
  MTZSEC_RIGHT.Piority
FROM MTZSEC_RIGHT JOIN
     GroupUser ON MTZSEC_RIGHT.TheGroup = GroupUser.ParentStructRowID  JOIN
     the_Session ON GroupUser.TheUser = the_Session.Usersid
where the_Session.the_Sessionid = acursession and the_Session.closed=0 
and MTZSEC_RIGHT.InstanceID =athe_resource
and MTZSEC_RIGHT.ProtectedItem =averb
order by MTZSEC_RIGHT.Piority;
tst_rec tst%ROWTYPE;
begin
--open tst;

for tst_rec in tst loop
	aaccess :=tst_rec.allow;
	CLOSE tst;
	return;
END loop;

aaccess :=0;
CLOSE tst;
end;
*/
aaccess :=1;
end;

/
/* MTZLogin  Открытие сессии*/
create or replace procedure MTZLogin

(athe_session out  CHAR/* Идентификатор новой сессии */

,apwd VARCHAR2/* Пароль */

,ausr VARCHAR2/* Имя пользователя */

)
 as 
aID char(38); 
aUSERSID char(38); 
asysid char(38); 
existsCnt integer;  
begin 
asysid := null; 
select instanceid into asysid from instance where objtype = lower('MTZSYSTEM'); 
athe_session:=null  ; 
if aPWD is null 
then 
 select count(*) into existsCnt from users where Login=ausr and Password is null; 
  if existsCNt =1 
  then 
    select USERSID into ausersid from users where Login=ausr and Password is null; 
    select  MTO.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  End if; 
else 
 
  select count(*) into existsCnt from users where Login=ausr and Password =aPWD; 
  if existsCNt =1 
  then 
   select USERSID into ausersid from users where Login=ausr and Password =aPWD; 
   select  MTO.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  else 
    select count(*) into existsCnt from users where DomaiName=ausr and aPWD='INTEGRATED'; 
    if existsCNt =1 
    then 
     select USERSID into ausersid from users where DomaiName =ausr ; 
     select  MTO.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
    End if; 
  end if; 
end if; -- password is null 
end; 


/
/* AdminUnlockAll  Административная функция для 
разблокировки документов*/
create or replace procedure AdminUnlockAll

 as 
begin
update instance set LockUserID = null, LockSessionID=null 
end;

/
/* RowToInstance  Поиск объекта для некоторой строки*/
create or replace procedure RowToInstance

(athe_instanceid out  CHAR/* Object */

,athe_rowid CHAR/* Row */

,athe_table VARCHAR2/* Part Table Name */

,acursession CHAR/* Session */

)
 as 
aparent varchar2(255);
aprev varchar2(255);
atmpID  char(38);
atmpRowID  char(38);
astr varchar2(4000);
existsCnt integer;
begin
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
 -- checking session  --
if  existsCnt =0
  then
    raise_application_error(-20000,'Session expired');

    return;
  end if;

aparent :=athe_table;
atmpID := athe_ROWID;

&lt;&lt;again&gt;&gt;

aprev := aparent;
begin 

select thevalue into aparent from sysoptions where optiontype = 'PARENT' and  name=aprev;
exception
when others then
aparent := null;
end;
if aparent is null then
    astr := 'select InstanceID from ' || aprev || ' where ' || aprev || 'id=:1';
    begin
        execute immediate astr into atmpRowID using atmpid;
        athe_InstanceID:=atmpRowID	    	;
    exception when others then
        athe_InstanceID:=null;
    end;
    
else
    astr :='select ParentStructRowID from ' || aprev || ' where ' || aprev || 'id=:1';
    begin
        execute immediate astr into atmpRowID using atmpid;
        atmpID := atmpROWID;
            exception when others then
              atmpID := null;
    end;
    goto again;
end if;
end
;

/
/* SessionTouch  Поддержание сессии*/
create or replace procedure SessionTouch

(acursession CHAR/* Идентификатор сессии */

)
 as 
begin
update the_session set lastaccess=sysdate() where the_sessionid=acursession and closed=0;
end;


/
/* GetServerTime  текущее время сервера*/
create or replace procedure GetServerTime

(aservertime out  DATE/* Текущее время */

)
 as 
begin
select sysdate() into aServerTime from sys.dual;
end;

/
/* TestNumber  Проверить наличие номера в нумераторе*/
create or replace procedure TestNumber

(athe_zone VARCHAR2/* Зона */

,aresult out  NUMBER/* результат */

,anumeratorid CHAR/* нумератор */

,anum NUMBER/* номер */

)
 as 
aid1 char(38); 
existsCnt  integer; 
begin 
aresult:=0; 
 
select count(*) into existsCnt from instance where instanceid=aNumeratorID; 
if existsCnt =0 then 
  return; 
end if; 
 
select count(*) into existsCnt  from num_zones where zonemask=athe_zone and instanceid=aNumeratorID; 
 
if existsCnt=0 then 
    return; 
else 
  select num_zonesid into aid1 from num_zones where zonemask=athe_zone and instanceid=aNumeratorID; 
  select count(*) into existsCnt from num_values where parentStructRowID=aID1 and the_value=anum; 
 
  if existsCnt=0 then 
      return; 
  else 
     aresult:=1; 
  end if; 
end if; 
end; 

/
/* Logout  Завершение сессии*/
create or replace procedure Logout

(acursession CHAR/* Идентификатор сессии */

)
 as 
existsCnt integer;

begin
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt &gt;0 then
   begin
    declare cursor dl  is
    select 'update '|| thevalue || ' set LockSessionID =null where LockSessionID=:1' str from sysoptions where optiontype='MAP' and theValue not like 'v[_]%';
    dl_rec dl%rowtype;
    begin
    --open dl;
    for dl_rec in dl loop
	      execute immediate dl_rec.str using acursession;
    end loop;
    --close dl;
    update INSTANCE set LockSessionID =null where LockSessionID=acursession ;
    update the_session set closed=1,closedAt=sysdate(), changeStamp=sysdate() where     the_sessionid=acursession;
    end;
  end;  
 End if;
end;


/
/* Login  Открытие сессии*/
create or replace procedure Login

(athe_session out  CHAR/* Идентификатор новой сессии */

,apwd VARCHAR2/* Пароль */

,ausr VARCHAR2/* Имя пользователя */

)
 as 
aID char(38); 
aUSERSID char(38); 
asysid char(38); 
existsCnt integer;  
begin 
asysid := null; 
select instanceid into asysid from instance where objtype = lower('MTZSYSTEM'); 
athe_session:=null  ; 
if aPWD is null 
then 
 select count(*) into existsCnt from users where Login=ausr and Password is null; 
  if existsCNt =1 
  then 
    select USERSID into ausersid from users where Login=ausr and Password is null; 
    select  MTO.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  End if; 
else 
 
  select count(*) into existsCnt from users where Login=ausr and Password =aPWD; 
  if existsCNt =1 
  then 
   select USERSID into ausersid from users where Login=ausr and Password =aPWD; 
   select  MTO.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
  else 
    select count(*) into existsCnt from users where DomaiName=ausr and aPWD='INTEGRATED'; 
    if existsCNt =1 
    then 
     select USERSID into ausersid from users where DomaiName =ausr ; 
     select  MTO.newid() into aID from sys.dual; 
       if asysid is null then 
        insert into the_session(the_sessionid,lastaccess,usersid,closed,startAt) 
        values(aid,sysdate,ausersid,0,sysdate); 
 
       else 
        insert into the_session(instanceid,the_sessionid,lastaccess,usersid,closed,startAt) 
        values(asysid,aid,sysdate,ausersid,0,sysdate); 
       end if; 
     athe_session:=aid; 
    End if; 
  end if; 
end if; -- password is null 
end; 


/
/* AdminUnlock  Административная функция для 
разблокировки документов*/
create or replace procedure AdminUnlock

(athe_id CHAR/* Идентификатор документа */

)
 as 
begin
update instance set LockUserID = null, LockSessionID=null where instanceID=athe_ID;
end;

/
/* SessionVerify  Проверка состояния сессии*/
create or replace procedure SessionVerify

(acursession CHAR/* Сессия */

,aok out  NUMBER/* Активна */

)
 as 
existsCnt integer;
begin
select Count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;

if  existsCnt&gt;0 then
aOK:=1;
else
aOK :=0;
end if;
end;

/
/*NEWID (NEWID)*/
create or replace function NEWID return varchar2 as
  Result varchar2(40);
  lguid raw(128);
  sTempString varchar2(40);
begin
  
  
  
  select sys_guid() into lguid from dual;
  
  sTempString:=to_char(lguid);
 
  Result:='{' || 
              Substr(sTempString, 1, 8) 
              || '-' ||
              Substr(sTempString, 9, 4) 
              || '-' ||
              Substr(sTempString, 13, 4) 
              || '-' ||
              Substr(sTempString, 17, 4) 
              || '-' ||
              Substr(sTempString, 21, 12) 
              || '}';
  return(Result);
end NEWID;
/
/*V_LOG (V_LOG)*/
create or replace view V_LOG as 

select syslog.syslogid

,syslog.changestamp

,the_session.StartAt

,the_session.Closed

,syslog.the_Resource

,syslog.LogStructID

,syslog.LogInstanceID

,syslog.VERB

,NVL(users.login,the_Resource || '|' || NVL(logstructid,'null')) login

,users.Family

,users.Name

,users.Surname

,instance.name instname

,instance.objtype

,part.caption

,objecttype.the_comment

 from  syslog

left join the_session on syslog.thesession=the_session.the_sessionid

left join users on the_session.usersid=users.usersid

left join instance on syslog.loginstanceid = instance.instanceid

left join part on syslog.logstructid = part.name

left join objecttype on instance.objtype =objecttype.name
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Functions.Body" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package body Func as

  function instance_BRIEF_F  (
 ainstanceid CHAR
)return varchar2 as  
 aBRIEF varchar2(4000);
 atmpCnt numeric;
 begin
if ainstanceid is null then aBRIEF:=''; return (aBRIEF); end if;
 -- Brief body --
select count(*) into aTmpCnt from instance where instanceID=ainstanceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select aBRIEF
  ||  nvl(Name,' ')||'; ' into aBrief
  from instance where  instanceID = ainstanceID;
else 
  aBRIEF:= 'неверный идентификатор';
End if;
 aBRIEF:=substr(aBRIEF,1,255);
  return (aBRIEF);
End;

function genpackage_BRIEF_F  (
 agenpackageid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if agenpackageid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from genpackage where genpackageID=agenpackageID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from genpackage  where  genpackageID = agenpackageID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function generator_target_BRIEF_F  (
 agenerator_targetid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if agenerator_targetid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from generator_target where generator_targetID=agenerator_targetID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from generator_target  where  generator_targetID = agenerator_targetID; 
  select  aBRIEF ||
  Decode( targettype
 ,0
 ,'СУБД'
 ,3
 ,'Документация'
 ,1
 ,'МОДЕЛЬ'
 ,2
 ,'Приложение'
 ,4
 ,'АРМ'
,'.') into aBrief from generator_target where generator_targetID=agenerator_targetID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function genreference_BRIEF_F  (
 agenreferenceid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if agenreferenceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from genreference where genreferenceID=agenreferenceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from genreference  where  genreferenceID = agenreferenceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function genmanualcode_BRIEF_F  (
 agenmanualcodeid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if agenmanualcodeid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from genmanualcode where genmanualcodeID=agenmanualcodeID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from genmanualcode  where  genmanualcodeID = agenmanualcodeID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function gencontrols_BRIEF_F  (
 agencontrolsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if agencontrolsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from gencontrols where gencontrolsID=agencontrolsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(controlprogid),' ') ||'; '
  into aBrief from gencontrols  where  gencontrolsID = agencontrolsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function localizeinfo_BRIEF_F  (
 alocalizeinfoid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if alocalizeinfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from localizeinfo where localizeinfoID=alocalizeinfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(langfull),' ') ||'; '
  into aBrief from localizeinfo  where  localizeinfoID = alocalizeinfoID; 
 select aBRIEF 
  ||  nvl(to_char(langshort),' ') ||'; '
  into aBrief from localizeinfo  where  localizeinfoID = alocalizeinfoID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldtype_BRIEF_F  (
 afieldtypeid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldtypeid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldtype where fieldtypeID=afieldtypeID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from fieldtype  where  fieldtypeID = afieldtypeID; 
  select  aBRIEF ||
  Decode( typestyle
 ,4
 ,'Ссылка'
 ,1
 ,'Выражение'
 ,5
 ,'Элемент оформления'
 ,3
 ,'Интервал'
 ,2
 ,'Перечисление'
 ,0
 ,'Скалярный тип'
,'.') into aBrief from fieldtype where fieldtypeID=afieldtypeID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function enumitem_BRIEF_F  (
 aenumitemid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aenumitemid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from enumitem where enumitemID=aenumitemID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from enumitem  where  enumitemID = aenumitemID; 
 select aBRIEF 
  ||  nvl(to_char(namevalue),' ') ||'; '
  into aBrief from enumitem  where  enumitemID = aenumitemID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldtypemap_BRIEF_F  (
 afieldtypemapid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldtypemapid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldtypemap where fieldtypemapID=afieldtypemapID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select target
 into atmpID  from fieldtypemap  where  fieldtypemapID = afieldtypemapID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(stoagetype),' ') ||'; '
  into aBrief from fieldtypemap  where  fieldtypemapID = afieldtypemapID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function sharedmethod_BRIEF_F  (
 asharedmethodid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if asharedmethodid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from sharedmethod where sharedmethodID=asharedmethodID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from sharedmethod  where  sharedmethodID = asharedmethodID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function script_BRIEF_F  (
 ascriptid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ascriptid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from script where scriptID=ascriptID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select target
 into atmpID  from script  where  scriptID = ascriptID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function parameters_BRIEF_F  (
 aparametersid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aparametersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from parameters where parametersID=aparametersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from parameters  where  parametersID = aparametersID; 
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from parameters  where  parametersID = aparametersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function objecttype_BRIEF_F  (
 aobjecttypeid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aobjecttypeid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from objecttype where objecttypeID=aobjecttypeID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select package
 into atmpID  from objecttype  where  objecttypeID = aobjecttypeID ;
 atmpBrief := func.mtzapp_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(the_comment),' ') ||'; '
  into aBrief from objecttype  where  objecttypeID = aobjecttypeID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function objstatus_BRIEF_F  (
 aobjstatusid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aobjstatusid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from objstatus where objstatusID=aobjstatusID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from objstatus  where  objstatusID = aobjstatusID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function nextstate_BRIEF_F  (
 anextstateid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if anextstateid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from nextstate where nextstateID=anextstateID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thestate
 into atmpID  from nextstate  where  nextstateID = anextstateID ;
 atmpBrief := func.objstatus_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function objectmode_BRIEF_F  (
 aobjectmodeid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aobjectmodeid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from objectmode where objectmodeID=aobjectmodeID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from objectmode  where  objectmodeID = aobjectmodeID; 
  select  aBRIEF ||
  Decode( defaultmode
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from objectmode where objectmodeID=aobjectmodeID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function structrestriction_BRIEF_F  (
 astructrestrictionid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if astructrestrictionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from structrestriction where structrestrictionID=astructrestrictionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select struct
 into atmpID  from structrestriction  where  structrestrictionID = astructrestrictionID ;
 atmpBrief := func.part_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( allowread
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from structrestriction where structrestrictionID=astructrestrictionID;
  select  aBRIEF ||
  Decode( allowadd
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from structrestriction where structrestrictionID=astructrestrictionID;
  select  aBRIEF ||
  Decode( allowedit
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from structrestriction where structrestrictionID=astructrestrictionID;
  select  aBRIEF ||
  Decode( allowdelete
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from structrestriction where structrestrictionID=astructrestrictionID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function methodrestriction_BRIEF_F  (
 amethodrestrictionid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if amethodrestrictionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from methodrestriction where methodrestrictionID=amethodrestrictionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select method
 into atmpID  from methodrestriction  where  methodrestrictionID = amethodrestrictionID ;
 atmpBrief := func.sharedmethod_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( isrestricted
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from methodrestriction where methodrestrictionID=amethodrestrictionID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldrestriction_BRIEF_F  (
 afieldrestrictionid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldrestrictionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldrestriction where fieldrestrictionID=afieldrestrictionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thepart
 into atmpID  from fieldrestriction  where  fieldrestrictionID = afieldrestrictionID ;
 atmpBrief := func.part_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
select thefield
 into atmpID  from fieldrestriction  where  fieldrestrictionID = afieldrestrictionID ;
 atmpBrief := func.field_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( allowread
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from fieldrestriction where fieldrestrictionID=afieldrestrictionID;
  select  aBRIEF ||
  Decode( allowmodify
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from fieldrestriction where fieldrestrictionID=afieldrestrictionID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function typemenu_BRIEF_F  (
 atypemenuid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atypemenuid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from typemenu where typemenuID=atypemenuID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from typemenu  where  typemenuID = atypemenuID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function instancevalidator_BRIEF_F  (
 ainstancevalidatorid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ainstancevalidatorid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from instancevalidator where instancevalidatorID=ainstancevalidatorID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select target
 into atmpID  from instancevalidator  where  instancevalidatorID = ainstancevalidatorID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function part_BRIEF_F  (
 apartid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if apartid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from part where partID=apartID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from part  where  partID = apartID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from part  where  partID = apartID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function partmenu_BRIEF_F  (
 apartmenuid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if apartmenuid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from partmenu where partmenuID=apartmenuID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from partmenu  where  partmenuID = apartmenuID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function partparammap_BRIEF_F  (
 apartparammapid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if apartparammapid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from partparammap where partparammapID=apartparammapID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(fieldname),' ') ||'; '
  into aBrief from partparammap  where  partparammapID = apartparammapID; 
 select aBRIEF 
  ||  nvl(to_char(paramname),' ') ||'; '
  into aBrief from partparammap  where  partparammapID = apartparammapID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function partview_BRIEF_F  (
 apartviewid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if apartviewid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from partview where partviewID=apartviewID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from partview  where  partviewID = apartviewID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function viewcolumn_BRIEF_F  (
 aviewcolumnid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aviewcolumnid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from viewcolumn where viewcolumnID=aviewcolumnID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from viewcolumn  where  viewcolumnID = aviewcolumnID; 
select frompart
 into atmpID  from viewcolumn  where  viewcolumnID = aviewcolumnID ;
 atmpBrief := func.part_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( aggregation
 ,3
 ,'SUM'
 ,1
 ,'AVG'
 ,6
 ,'CUSTOM'
 ,0
 ,'none'
 ,2
 ,'COUNT'
 ,5
 ,'MAX'
 ,4
 ,'MIN'
,'.') into aBrief from viewcolumn where viewcolumnID=aviewcolumnID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function partview_lnk_BRIEF_F  (
 apartview_lnkid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if apartview_lnkid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from partview_lnk where partview_lnkID=apartview_lnkID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select theview
 into atmpID  from partview_lnk  where  partview_lnkID = apartview_lnkID ;
 atmpBrief := func.partview_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function validator_BRIEF_F  (
 avalidatorid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if avalidatorid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from validator where validatorID=avalidatorID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select target
 into atmpID  from validator  where  validatorID = avalidatorID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function uniqueconstraint_BRIEF_F  (
 auniqueconstraintid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if auniqueconstraintid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from uniqueconstraint where uniqueconstraintID=auniqueconstraintID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from uniqueconstraint  where  uniqueconstraintID = auniqueconstraintID; 
  select  aBRIEF ||
  Decode( perparent
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from uniqueconstraint where uniqueconstraintID=auniqueconstraintID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function constraintfield_BRIEF_F  (
 aconstraintfieldid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aconstraintfieldid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from constraintfield where constraintfieldID=aconstraintfieldID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thefield
 into atmpID  from constraintfield  where  constraintfieldID = aconstraintfieldID ;
 atmpBrief := func.field_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function extenderinterface_BRIEF_F  (
 aextenderinterfaceid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aextenderinterfaceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from extenderinterface where extenderinterfaceID=aextenderinterfaceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(thename),' ') ||'; '
  into aBrief from extenderinterface  where  extenderinterfaceID = aextenderinterfaceID; 
select targetplatform
 into atmpID  from extenderinterface  where  extenderinterfaceID = aextenderinterfaceID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(theobject),' ') ||'; '
  into aBrief from extenderinterface  where  extenderinterfaceID = aextenderinterfaceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function field_BRIEF_F  (
 afieldid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from field where fieldID=afieldID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from field  where  fieldID = afieldID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from field  where  fieldID = afieldID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fldextenders_BRIEF_F  (
 afldextendersid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afldextendersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fldextenders where fldextendersID=afldextendersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(thename),' ') ||'; '
  into aBrief from fldextenders  where  fldextendersID = afldextendersID; 
select targetplatform
 into atmpID  from fldextenders  where  fldextendersID = afldextendersID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(theobject),' ') ||'; '
  into aBrief from fldextenders  where  fldextendersID = afldextendersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldsrcdef_BRIEF_F  (
 afieldsrcdefid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldsrcdefid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldsrcdef where fieldsrcdefID=afieldsrcdefID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(datasource),' ') ||'; '
  into aBrief from fieldsrcdef  where  fieldsrcdefID = afieldsrcdefID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function dinamicfilterscript_BRIEF_F  (
 adinamicfilterscriptid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if adinamicfilterscriptid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from dinamicfilterscript where dinamicfilterscriptID=adinamicfilterscriptID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select target
 into atmpID  from dinamicfilterscript  where  dinamicfilterscriptID = adinamicfilterscriptID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldexpression_BRIEF_F  (
 afieldexpressionid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldexpressionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldexpression where fieldexpressionID=afieldexpressionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select target
 into atmpID  from fieldexpression  where  fieldexpressionID = afieldexpressionID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldvalidator_BRIEF_F  (
 afieldvalidatorid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldvalidatorid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldvalidator where fieldvalidatorID=afieldvalidatorID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select target
 into atmpID  from fieldvalidator  where  fieldvalidatorID = afieldvalidatorID ;
 atmpBrief := func.generator_target_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldmenu_BRIEF_F  (
 afieldmenuid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldmenuid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldmenu where fieldmenuID=afieldmenuID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from fieldmenu  where  fieldmenuID = afieldmenuID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fieldparammap_BRIEF_F  (
 afieldparammapid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afieldparammapid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fieldparammap where fieldparammapID=afieldparammapID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(fieldname),' ') ||'; '
  into aBrief from fieldparammap  where  fieldparammapID = afieldparammapID; 
 select aBRIEF 
  ||  nvl(to_char(paramname),' ') ||'; '
  into aBrief from fieldparammap  where  fieldparammapID = afieldparammapID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function mtzapp_BRIEF_F  (
 amtzappid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if amtzappid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from mtzapp where mtzappID=amtzappID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from mtzapp  where  mtzappID = amtzappID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function parentpackage_BRIEF_F  (
 aparentpackageid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aparentpackageid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from parentpackage where parentpackageID=aparentpackageID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select package
 into atmpID  from parentpackage  where  parentpackageID = aparentpackageID ;
 atmpBrief := func.mtzapp_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function journalcolumn_BRIEF_F  (
 ajournalcolumnid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ajournalcolumnid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from journalcolumn where journalcolumnID=ajournalcolumnID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from journalcolumn  where  journalcolumnID = ajournalcolumnID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function jcolumnsource_BRIEF_F  (
 ajcolumnsourceid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ajcolumnsourceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from jcolumnsource where jcolumnsourceID=ajcolumnsourceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(viewfield),' ') ||'; '
  into aBrief from jcolumnsource  where  jcolumnsourceID = ajcolumnsourceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function journalsrc_BRIEF_F  (
 ajournalsrcid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ajournalsrcid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from journalsrc where journalsrcID=ajournalsrcID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(spartview),' ') ||'; '
  into aBrief from journalsrc  where  journalsrcID = ajournalsrcID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function journal_BRIEF_F  (
 ajournalid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ajournalid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from journal where journalID=ajournalID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from journal  where  journalID = ajournalID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_factory_BRIEF_F  (
 atod_factoryid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_factoryid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_factory where tod_factoryID=atod_factoryID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_factory  where  tod_factoryID = atod_factoryID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_bug_BRIEF_F  (
 atod_bugid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_bugid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_bug where tod_bugID=atod_bugID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_system
 into atmpID  from tod_bug  where  tod_bugID = atod_bugID ;
 atmpBrief := func.tod_system_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_bug  where  tod_bugID = atod_bugID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_building_BRIEF_F  (
 atod_buildingid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_buildingid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_building where tod_buildingID=atod_buildingID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thefactory
 into atmpID  from tod_building  where  tod_buildingID = atod_buildingID ;
 atmpBrief := func.tod_factory_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_building  where  tod_buildingID = atod_buildingID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_valtype_BRIEF_F  (
 atod_valtypeid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_valtypeid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_valtype where tod_valtypeID=atod_valtypeID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_valtype  where  tod_valtypeID = atod_valtypeID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_model_BRIEF_F  (
 atod_modelid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_modelid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_model where tod_modelID=atod_modelID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_model  where  tod_modelID = atod_modelID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_system_BRIEF_F  (
 atod_systemid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_systemid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_system where tod_systemID=atod_systemID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_system  where  tod_systemID = atod_systemID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_oprole_BRIEF_F  (
 atod_oproleid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_oproleid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_oprole where tod_oproleID=atod_oproleID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_oprole  where  tod_oproleID = atod_oproleID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_trand_BRIEF_F  (
 atod_trandid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_trandid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_trand where tod_trandID=atod_trandID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_trand  where  tod_trandID = atod_trandID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_st_BRIEF_F  (
 atod_stid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_stid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_st where tod_stID=atod_stID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(invn),' ') ||'; '
  into aBrief from tod_st  where  tod_stID = atod_stID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_st  where  tod_stID = atod_stID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_material_BRIEF_F  (
 atod_materialid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_materialid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_material where tod_materialID=atod_materialID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_material  where  tod_materialID = atod_materialID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tod_edizm_BRIEF_F  (
 atod_edizmid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atod_edizmid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tod_edizm where tod_edizmID=atod_edizmID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tod_edizm  where  tod_edizmID = atod_edizmID; 
 select aBRIEF 
  ||  nvl(to_char(fullname),' ') ||'; '
  into aBrief from tod_edizm  where  tod_edizmID = atod_edizmID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function folder_BRIEF_F  (
 afolderid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afolderid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from folder where folderID=afolderID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from folder  where  folderID = afolderID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function shortcut_BRIEF_F  (
 ashortcutid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ashortcutid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from shortcut where shortcutID=ashortcutID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select docitem
 into atmpID  from shortcut  where  shortcutID = ashortcutID ;
 atmpBrief:= Func.Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function infostoredef_BRIEF_F  (
 ainfostoredefid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ainfostoredefid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from infostoredef where infostoredefID=ainfostoredefID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from infostoredef  where  infostoredefID = ainfostoredefID; 
  select  aBRIEF ||
  Decode( infostoretype
 ,2
 ,'Групповой'
 ,0
 ,' Общий'
 ,1
 ,'Персональный'
,'.') into aBrief from infostoredef where infostoredefID=ainfostoredefID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function the_session_BRIEF_F  (
 athe_sessionid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if athe_sessionid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from the_session where the_sessionID=athe_sessionID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select userrole
 into atmpID  from the_session  where  the_sessionID = athe_sessionID ;
 atmpBrief := func.groups_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
  select  aBRIEF ||
  Decode( closed
 ,1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from the_session where the_sessionID=athe_sessionID;
select usersid
 into atmpID  from the_session  where  the_sessionID = athe_sessionID ;
 atmpBrief := func.users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function sysrefcache_BRIEF_F  (
 asysrefcacheid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if asysrefcacheid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from sysrefcache where sysrefcacheID=asysrefcacheID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select sessionid
 into atmpID  from sysrefcache  where  sysrefcacheID = asysrefcacheID ;
 atmpBrief := func.the_session_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function syslog_BRIEF_F  (
 asyslogid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if asyslogid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from syslog where syslogID=asyslogID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thesession
 into atmpID  from syslog  where  syslogID = asyslogID ;
 atmpBrief := func.the_session_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(logstructid),' ') ||'; '
  into aBrief from syslog  where  syslogID = asyslogID; 
 select aBRIEF 
  ||  nvl(to_char(verb),' ') ||'; '
  into aBrief from syslog  where  syslogID = asyslogID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function armjournal_BRIEF_F  (
 aarmjournalid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aarmjournalid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from armjournal where armjournalID=aarmjournalID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thejournal
 into atmpID  from armjournal  where  armjournalID = aarmjournalID ;
 atmpBrief:= Func.Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function armjrnlrep_BRIEF_F  (
 aarmjrnlrepid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aarmjrnlrepid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from armjrnlrep where armjrnlrepID=aarmjrnlrepID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(repname),' ') ||'; '
  into aBrief from armjrnlrep  where  armjrnlrepID = aarmjrnlrepID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function armjrnlrun_BRIEF_F  (
 aarmjrnlrunid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aarmjrnlrunid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from armjrnlrun where armjrnlrunID=aarmjrnlrunID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from armjrnlrun  where  armjrnlrunID = aarmjrnlrunID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function armjrnladd_BRIEF_F  (
 aarmjrnladdid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aarmjrnladdid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from armjrnladd where armjrnladdID=aarmjrnladdID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from armjrnladd  where  armjrnladdID = aarmjrnladdID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function entrypoints_BRIEF_F  (
 aentrypointsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aentrypointsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from entrypoints where entrypointsID=aentrypointsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from entrypoints  where  entrypointsID = aentrypointsID; 
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from entrypoints  where  entrypointsID = aentrypointsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function epfilterlink_BRIEF_F  (
 aepfilterlinkid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aepfilterlinkid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from epfilterlink where epfilterlinkID=aepfilterlinkID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(rowsource),' ') ||'; '
  into aBrief from epfilterlink  where  epfilterlinkID = aepfilterlinkID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function workplace_BRIEF_F  (
 aworkplaceid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aworkplaceid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from workplace where workplaceID=aworkplaceID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from workplace  where  workplaceID = aworkplaceID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function armtypes_BRIEF_F  (
 aarmtypesid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aarmtypesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from armtypes where armtypesID=aarmtypesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thedocumenttype
 into atmpID  from armtypes  where  armtypesID = aarmtypesID ;
 atmpBrief := func.objecttype_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_operations_BRIEF_F  (
 aroles_operationsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_operationsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_operations where roles_operationsID=aroles_operationsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(info),' ') ||'; '
  into aBrief from roles_operations  where  roles_operationsID = aroles_operationsID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from roles_operations  where  roles_operationsID = aroles_operationsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_wp_BRIEF_F  (
 aroles_wpid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_wpid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_wp where roles_wpID=aroles_wpID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select wp
 into atmpID  from roles_wp  where  roles_wpID = aroles_wpID ;
 atmpBrief := func.workplace_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_act_BRIEF_F  (
 aroles_actid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_actid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_act where roles_actID=aroles_actID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select  aBRIEF ||
  Decode( accesible
 ,1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from roles_act where roles_actID=aroles_actID;
 select aBRIEF 
  ||  nvl(to_char(menuname),' ') ||'; '
  into aBrief from roles_act  where  roles_actID = aroles_actID; 
 select aBRIEF 
  ||  nvl(to_char(menucode),' ') ||'; '
  into aBrief from roles_act  where  roles_actID = aroles_actID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles2_module_BRIEF_F  (
 aroles2_moduleid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles2_moduleid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles2_module where roles2_moduleID=aroles2_moduleID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from roles2_module  where  roles2_moduleID = aroles2_moduleID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from roles2_module  where  roles2_moduleID = aroles2_moduleID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles2_modreport_BRIEF_F  (
 aroles2_modreportid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles2_modreportid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles2_modreport where roles2_modreportID=aroles2_modreportID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from roles2_modreport  where  roles2_modreportID = aroles2_modreportID; 
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from roles2_modreport  where  roles2_modreportID = aroles2_modreportID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_doc_BRIEF_F  (
 aroles_docid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_docid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_doc where roles_docID=aroles_docID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_document
 into atmpID  from roles_doc  where  roles_docID = aroles_docID ;
 atmpBrief := func.objecttype_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_doc_state_BRIEF_F  (
 aroles_doc_stateid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_doc_stateid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_doc_state where roles_doc_stateID=aroles_doc_stateID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_state
 into atmpID  from roles_doc_state  where  roles_doc_stateID = aroles_doc_stateID ;
 atmpBrief := func.objstatus_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
select the_mode
 into atmpID  from roles_doc_state  where  roles_doc_stateID = aroles_doc_stateID ;
 atmpBrief := func.objectmode_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_reports_BRIEF_F  (
 aroles_reportsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_reportsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_reports where roles_reportsID=aroles_reportsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_report
 into atmpID  from roles_reports  where  roles_reportsID = aroles_reportsID ;
 atmpBrief:= Func.Instance_BRIEF_F( atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_user_BRIEF_F  (
 aroles_userid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_userid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_user where roles_userID=aroles_userID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select theuser
 into atmpID  from roles_user  where  roles_userID = aroles_userID ;
 atmpBrief := func.users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_map_BRIEF_F  (
 aroles_mapid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_mapid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_map where roles_mapID=aroles_mapID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select thegroup
 into atmpID  from roles_map  where  roles_mapID = aroles_mapID ;
 atmpBrief := func.groups_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function roles_def_BRIEF_F  (
 aroles_defid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if aroles_defid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from roles_def where roles_defID=aroles_defID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from roles_def  where  roles_defID = aroles_defID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_scheditems_BRIEF_F  (
 ato_scheditemsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_scheditemsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_scheditems where to_scheditemsID=ato_scheditemsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select themachine
 into atmpID  from to_scheditems  where  to_scheditemsID = ato_scheditemsID ;
 atmpBrief := func.tod_st_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(todate),' ') ||'; '
  into aBrief from to_scheditems  where  to_scheditemsID = ato_scheditemsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_schedinfo_BRIEF_F  (
 ato_schedinfoid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_schedinfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_schedinfo where to_schedinfoID=ato_schedinfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(dfrom),' ') ||'; '
  into aBrief from to_schedinfo  where  to_schedinfoID = ato_schedinfoID; 
 select aBRIEF 
  ||  nvl(to_char(dto),' ') ||'; '
  into aBrief from to_schedinfo  where  to_schedinfoID = ato_schedinfoID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function totrn_data_BRIEF_F  (
 atotrn_dataid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atotrn_dataid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from totrn_data where totrn_dataID=atotrn_dataID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(time_label),' ') ||'; '
  into aBrief from totrn_data  where  totrn_dataID = atotrn_dataID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function totrn_def_BRIEF_F  (
 atotrn_defid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atotrn_defid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from totrn_def where totrn_defID=atotrn_defID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select themachine
 into atmpID  from totrn_def  where  totrn_defID = atotrn_defID ;
 atmpBrief := func.tod_st_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
select trandtype
 into atmpID  from totrn_def  where  totrn_defID = atotrn_defID ;
 atmpBrief := func.tod_trand_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_taskcomment_BRIEF_F  (
 ato_taskcommentid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_taskcommentid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_taskcomment where to_taskcommentID=ato_taskcommentID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select codetocomment
 into atmpID  from to_taskcomment  where  to_taskcommentID = ato_taskcommentID ;
 atmpBrief := func.tod_system_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
select the_operator
 into atmpID  from to_taskcomment  where  to_taskcommentID = ato_taskcommentID ;
 atmpBrief := func.to_oper_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(the_date),' ') ||'; '
  into aBrief from to_taskcomment  where  to_taskcommentID = ato_taskcommentID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_taskinfo_BRIEF_F  (
 ato_taskinfoid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_taskinfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_taskinfo where to_taskinfoID=ato_taskinfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select themachine
 into atmpID  from to_taskinfo  where  to_taskinfoID = ato_taskinfoID ;
 atmpBrief := func.to_scheditems_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
select oper
 into atmpID  from to_taskinfo  where  to_taskinfoID = ato_taskinfoID ;
 atmpBrief := func.to_oper_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_taskchecks_BRIEF_F  (
 ato_taskchecksid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_taskchecksid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_taskchecks where to_taskchecksID=ato_taskchecksID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_system
 into atmpID  from to_taskchecks  where  to_taskchecksID = ato_taskchecksID ;
 atmpBrief := func.tod_system_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(thesubsystem),' ') ||'; '
  into aBrief from to_taskchecks  where  to_taskchecksID = ato_taskchecksID; 
 select aBRIEF 
  ||  nvl(to_char(the_check),' ') ||'; '
  into aBrief from to_taskchecks  where  to_taskchecksID = ato_taskchecksID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_taskcheckcomment_BRIEF_F  (
 ato_taskcheckcommentid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_taskcheckcommentid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_taskcheckcomment where to_taskcheckcommentID=ato_taskcheckcommentID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_operator
 into atmpID  from to_taskcheckcomment  where  to_taskcheckcommentID = ato_taskcheckcommentID ;
 atmpBrief := func.to_oper_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(the_date),' ') ||'; '
  into aBrief from to_taskcheckcomment  where  to_taskcheckcommentID = ato_taskcheckcommentID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function users_BRIEF_F  (
 ausersid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ausersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from users where usersID=ausersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(family),' ') ||'; '
  into aBrief from users  where  usersID = ausersID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from users  where  usersID = ausersID; 
 select aBRIEF 
  ||  nvl(to_char(surname),' ') ||'; '
  into aBrief from users  where  usersID = ausersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function groups_BRIEF_F  (
 agroupsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if agroupsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from groups where groupsID=agroupsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from groups  where  groupsID = agroupsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function groupuser_BRIEF_F  (
 agroupuserid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if agroupuserid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from groupuser where groupuserID=agroupuserID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select theuser
 into atmpID  from groupuser  where  groupuserID = agroupuserID ;
 atmpBrief := func.users_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_oper_BRIEF_F  (
 ato_operid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_operid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_oper where to_operID=ato_operID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(familyname),' ') ||'; '
  into aBrief from to_oper  where  to_operID = ato_operID; 
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from to_oper  where  to_operID = ato_operID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function num_zones_BRIEF_F  (
 anum_zonesid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if anum_zonesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from num_zones where num_zonesID=anum_zonesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(zonemask),' ') ||'; '
  into aBrief from num_zones  where  num_zonesID = anum_zonesID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function num_values_BRIEF_F  (
 anum_valuesid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if anum_valuesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from num_values where num_valuesID=anum_valuesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(the_value),' ') ||'; '
  into aBrief from num_values  where  num_valuesID = anum_valuesID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function num_head_BRIEF_F  (
 anum_headid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if anum_headid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from num_head where num_headID=anum_headID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from num_head  where  num_headID = anum_headID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function tor_info_BRIEF_F  (
 ator_infoid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ator_infoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from tor_info where tor_infoID=ator_infoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from tor_info  where  tor_infoID = ator_infoID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function mtzext_def_BRIEF_F  (
 amtzext_defid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if amtzext_defid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from mtzext_def where mtzext_defID=amtzext_defID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from mtzext_def  where  mtzext_defID = amtzext_defID; 
  select  aBRIEF ||
  Decode( exttype
 ,6
 ,'VerifyRowExt'
 ,7
 ,'CodeGenerator'
 ,5
 ,'DefaultExt'
 ,0
 ,'StatusExt'
 ,4
 ,'JrnlRunExt'
 ,2
 ,'CustomExt'
 ,8
 ,'ARMGenerator'
 ,1
 ,'OnFormExt'
 ,3
 ,'JrnlAddExt'
,'.') into aBrief from mtzext_def where mtzext_defID=amtzext_defID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function mtzextrel_BRIEF_F  (
 amtzextrelid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if amtzextrelid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from mtzextrel where mtzextrelID=amtzextrelID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
  select  aBRIEF ||
  Decode( theplatform
 ,3
 ,'OTHER'
 ,1
 ,'DOTNET'
 ,2
 ,'JAVA'
 ,0
 ,'VB6'
,'.') into aBrief from mtzextrel where mtzextrelID=amtzextrelID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_cardinfo_BRIEF_F  (
 ato_cardinfoid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_cardinfoid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_cardinfo where to_cardinfoID=ato_cardinfoID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_machine
 into atmpID  from to_cardinfo  where  to_cardinfoID = ato_cardinfoID ;
 atmpBrief := func.tod_st_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_cardchecks_BRIEF_F  (
 ato_cardchecksid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_cardchecksid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_cardchecks where to_cardchecksID=ato_cardchecksID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select the_system
 into atmpID  from to_cardchecks  where  to_cardchecksID = ato_cardchecksID ;
 atmpBrief := func.tod_system_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 select aBRIEF 
  ||  nvl(to_char(the_check),' ') ||'; '
  into aBrief from to_cardchecks  where  to_cardchecksID = ato_cardchecksID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function to_carddevices_BRIEF_F  (
 ato_carddevicesid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if ato_carddevicesid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from to_carddevices where to_carddevicesID=ato_carddevicesID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
select mat
 into atmpID  from to_carddevices  where  to_carddevicesID = ato_carddevicesID ;
 atmpBrief := func.tod_material_BRIEF_F(atmpID);
  aBRIEF:= aBRIEF || '{' || nvl(atmpbrief,' ') || '}; ';
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function toimg_data_BRIEF_F  (
 atoimg_dataid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atoimg_dataid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from toimg_data where toimg_dataID=atoimg_dataID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(fname),' ') ||'; '
  into aBrief from toimg_data  where  toimg_dataID = atoimg_dataID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function toimg_todelete_BRIEF_F  (
 atoimg_todeleteid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atoimg_todeleteid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from toimg_todelete where toimg_todeleteID=atoimg_todeleteID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(fname),' ') ||'; '
  into aBrief from toimg_todelete  where  toimg_todeleteID = atoimg_todeleteID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function toimg_def_BRIEF_F  (
 atoimg_defid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if atoimg_defid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from toimg_def where toimg_defID=atoimg_defID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(computername),' ') ||'; '
  into aBrief from toimg_def  where  toimg_defID = atoimg_defID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function mtz2job_def_BRIEF_F  (
 amtz2job_defid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if amtz2job_defid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from mtz2job_def where mtz2job_defID=amtz2job_defID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(eventdate),' ') ||'; '
  into aBrief from mtz2job_def  where  mtz2job_defID = amtz2job_defID; 
 select aBRIEF 
  ||  nvl(to_char(eventype),' ') ||'; '
  into aBrief from mtz2job_def  where  mtz2job_defID = amtz2job_defID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function filterfieldgroup_BRIEF_F  (
 afilterfieldgroupid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afilterfieldgroupid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from filterfieldgroup where filterfieldgroupID=afilterfieldgroupID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from filterfieldgroup  where  filterfieldgroupID = afilterfieldgroupID; 
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from filterfieldgroup  where  filterfieldgroupID = afilterfieldgroupID; 
  select  aBRIEF ||
  Decode( allowignore
 ,-1
 ,'Да'
 ,0
 ,'Нет'
,'.') into aBrief from filterfieldgroup where filterfieldgroupID=afilterfieldgroupID;
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function fileterfield_BRIEF_F  (
 afileterfieldid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afileterfieldid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from fileterfield where fileterfieldID=afileterfieldID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from fileterfield  where  fileterfieldID = afileterfieldID; 
 select aBRIEF 
  ||  nvl(to_char(caption),' ') ||'; '
  into aBrief from fileterfield  where  fileterfieldID = afileterfieldID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function filters_BRIEF_F  (
 afiltersid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if afiltersid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from filters where filtersID=afiltersID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from filters  where  filtersID = afiltersID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function rptstruct_BRIEF_F  (
 arptstructid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if arptstructid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from rptstruct where rptstructID=arptstructID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from rptstruct  where  rptstructID = arptstructID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function rptfields_BRIEF_F  (
 arptfieldsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if arptfieldsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from rptfields where rptfieldsID=arptfieldsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from rptfields  where  rptfieldsID = arptfieldsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function rptformula_BRIEF_F  (
 arptformulaid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if arptformulaid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from rptformula where rptformulaID=arptformulaID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from rptformula  where  rptformulaID = arptformulaID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;


function reports_BRIEF_F  (
 areportsid CHAR
) return varchar2 as 
 aBRIEF varchar2(255);
 atmpStr varchar2(255);
 atmpBrief varchar2(2000);
 atmpID CHAR(38);
 atmpCnt Numeric;
 begin  
if areportsid is null  then  aBRIEF:=' '; return (aBRIEF); end if;
 -- Brief body -- 
select count(*) into aTmpCnt from reports where reportsID=areportsID;
if aTmpCnt &gt;0 then
  aBRIEF:='';
 select aBRIEF 
  ||  nvl(to_char(name),' ') ||'; '
  into aBrief from reports  where  reportsID = areportsID; 
 else 
  aBRIEF:= '-';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
return (aBRIEF);
end;
 end Func;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Kernel.Body" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
 create or replace package body Kernel as

procedure INSTANCE_OWNER   (
    acursession Char ,ainstanceid Char,
 aOwnerPartName varchar2, aOwnerRowID Char) As
 existsCnt Integer;
begin
Select count(*)into existscnt from instance
where instanceid=ainstanceid;
If existsCnt &gt; 0 Then
  If aOwnerPartName Is null Or aownerRowID Is null
  Then
     update instance Set OwnerPartName=null, OwnerRowid = null where instanceid=ainstanceid ;
  Else
     update instance Set OwnerPartName=aOwnerPartName, OwnerRowid = aOwnerRowID where instanceid=ainstanceid ;
  End If;
End If;
End;
procedure SYSOPTIONS_SAVE    (
   aSysOptionsid Char,
aName varchar2,
aValue varchar2 ,
aOptionType varchar2) As
existsCnt numeric;
begin
 Select count(*) into existsCnt from sysoptions where sysoptionsid=asysoptionsid;
 If existsCnt &gt; 0 Then
  update sysoptions Set Name=aName, theValue=aValue, OptionType=aOptionType where sysoptionsid=asysoptionsid ;
 Else
  insert into sysoptions (sysoptionsid, Name, theValue, OptionType)values(asysoptionsid,aName,aValue,aOptionType) ;
 End If;
End;
procedure INSTANCE_SAVE      (
aCURSESSION Char,
aInstanceID Char,
aObjType varchar2,
aName varchar2
) As
 atmpStr varchar2(255) ;
 aSSID Char(38) ;
 atmpID Char(38) ;
 aSysLogID Char(38) ;
 aaccess numeric ;
 aSysInstID Char(38) ;
 aStatusID Char(38) ;
 existsCnt numeric;
 theObjType varchar2(255);
begin
 Select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select  count(*) into existsCnt  from instance where instanceid=ainstanceid;
 If existsCnt &gt; 0 Then
   select  SecurityStyleID into atmpID from INSTANCE where INSTANCEid=aINSTANCEid ;
   CheckVerbRight (acursession=&gt;acursession,athe_resource=&gt;atmpID,averb=&gt;'EDIT',aaccess=&gt;aaccess  );
   If aaccess = 0 Then
     raise_application_error(-20000,'Нет прав на изменение объекта.') ;
     return ;
   end if;
   MTO.Kernel.instance_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;ainstanceid,aIsLocked=&gt;aaccess  );
   If aaccess &gt; 2 Then
     raise_application_error(-20000,'Объект заблокирован другим пользователем.') ;
     return;
   end if;
   select objtype into TheObjType from instance  where  instanceid=ainstanceid ;
   update instance set name = aname where  instanceid=ainstanceid;
   select newid() into aSysLogID from sys.DUAL ;
   MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid,
   aLogStructID =&gt; TheOBJTYPE ,
   aVERB=&gt;'EDIT',  aThe_Resource=&gt;aInstanceID, aLogInstanceID=&gt;aInstanceID );
 Else
    select count(*) into existsCnt from typelist where name = aobjtype;
    If existsCnt &gt; 0 Then
      select SecurityStyleid,RegisterProc into aSSID,atmpstr  from typelist where name = aobjtype;
      CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;aSSID,averb=&gt;'CREATE',aaccess=&gt;aaccess  );
      If aaccess = 0 Then
         raise_application_error(-20000,'Нет прав на создание объекта.') ;
         return;
      end if;
    end if;
   begin
   select objstatusid into astatusid from objstatus join objecttype on
         objecttype.objecttypeid=objstatus.parentstructrowid and objecttype.name=aobjtype and isStartup&lt;&gt;0;
   exception when others then
      astatusid:=null ;
    end;
   If astatusid Is Null Then
     insert into instance(instanceid,name,objtype,SecurityStyleID) values(ainstanceid,aname,aobjtype,aSSID)         ;
   Else
     insert into instance(instanceid,name,objtype,SecurityStyleID,STATUS) values(ainstanceid,aname,aobjtype,aSSID,aSTATUSID) ;
   end if;
   If Not atmpstr Is Null Then
      execute immediate atmpstr using  acursession, ainstanceid;
   end if;
   select newid() into aSysLogid from sys.dual ;
   
   MTZSystem.SysLog_SAVE (
     aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession,
     aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aOBJTYPE ,
     aVERB=&gt;'CREATE',  aThe_Resource=&gt;aInstanceID , aLogInstanceID=&gt;aInstanceID);
 End  if;
End;
  procedure INSTANCE_DELETE    (
aCURSESSION CHAR,
aInstanceID Char
) as
 atmpStr varchar2(255) ;
  aStr varchar2(4000) ;
  aObjType varchar2(255) ;
 aSysInstID CHAR(38) ;
    atmpID CHAR(38) ;
   aaccess integer;
   aOwnerPartName varchar2(255) ;
   aOwnerRowID CHAR(38) ;
   aSysLogid CHAR(38) ;
    existsCnt integer;
begin
  select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM') ;
  select count(*) into existsCnt from instance where instanceid=ainstanceid;
  If existsCnt &gt; 0 Then
   select  SecurityStyleID, OwnerPartName,OWnerRowID
        Into atmpid, aOwnerpartname, aownerrowid
        from INSTANCE where INSTANCEid=aINSTANCEid ;
   CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETE',aaccess=&gt;aaccess);
   If aaccess = 0 Then
       raise_application_error(-20000,'Нет прав на удаление.');
       Return ;
   End if;
   If aOwnerpartname Is Null Or aownerrowid Is Null Then
        select  objtype into aobjtype from instance where instanceid=ainstanceid;
        select 'begin MTO.' || aobjtype || '.' || DeleteProc ||'(:1,:2); end;' into atmpstr from typelist where name = aobjtype;
        If Not atmpstr Is Null Then
            EXECUTE IMMEDIATE atmpstr USING acursession,ainstanceid;
        end if;
        delete from instance where instanceid=ainstanceid ;
        select newid() into aSysLogID from SYS.DUAL;
        MTZSystem.SysLog_SAVE( aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aobjtype ,
        aVERB=&gt;'DELETE',  aThe_Resource=&gt;aInstanceID, aLogInstanceID=&gt;aInstanceID);
        Else
        -- Owner exists
         astr :='select '|| aownerpartname || 'id  from ' || aownerpartname || ' where ' || aownerpartname ||'id=:1';
         execute immediate  astr into atmpid using aownerrowid;
         If atmpid = aownerrowid Then
           raise_application_error(-20000,'Этот документ принадлежит другому документу и не может быть удален отдельно.');
           return;
         End if;
         select  objtype into aObjType from instance where instanceid=ainstanceid;
         select 'begin MTO.' || aobjtype || '.' || DeleteProc ||'(:1,:2); end;' into atmpstr from typelist where name = aobjtype ;
         If Not atmpstr Is Null Then
           execute immediate atmpstr using acursession, ainstanceid ;
           delete from instance where instanceid=ainstanceid ;
         select newid() into aSysLogID from SYS.DUAL;
         MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession,
                      aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aobjtype ,
                      aVERB=&gt;'DELETE',  aThe_Resource=&gt;aInstanceID, aLogInstanceID=&gt;aInstanceID );
        End if;
     End if;
End if;
end;
  procedure INSTANCE_HCL   (
aCURSESSION CHAR,
aRowID CHAR,
aIsLocked out NUMBER
) as
atmpStr varchar2(255) ;
aObjType varchar2(255) ;
existscnt integer;
begin
select count(*) into existsCnt from instance where instanceid=arowid ;
if existscnt=1
    then
      select objtype into aobjtype  from instance where instanceid=arowid ;
      select 'begin MTO.' || aobjtype || '.' || HCLProc || '(:1,:2,:3); end;' into atmpstr from typelist where name = aobjtype;
      If Not atmpstr Is Null Then
        execute immediate atmpstr using acursession, arowid,out aIsLocked ;
      End if;
end if;
End;
  procedure INSTANCE_PROPAGATE   (
aCURSESSION CHAR,
aRowID Char
) as
atmpStr varchar2(255) ;
aObjType varchar2(255);
existsCnt integer;
begin
select count(*) into existsCnt from instance where instanceid=arowid ;
if existsCnt=1
    then
      select  objtype into aobjtype from instance where instanceid=arowid ;
      select  'begin MTO.' || aobjtype || '.' || propagateProc || '(:1,:2); end;' into atmpstr from typelist where name = aobjtype;
      If Not atmpstr Is Null Then
        execute immediate atmpstr using  acursession, arowid ;
    End if;
End if;
End;
  procedure INSTANCE_ISLOCKED   (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as
 aUserID CHAR(38) ;
 aLockUserID CHAR(38) ;
 aLockSessionID CHAR(38) ;
 existsCnt integer;
 begin
 aisLocked := 0 ;
 -- checking the_session  --
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 If existsCnt = 0 Then
   raise_APPLICATION_Error(-20000,'Сессия уже завершена');
   Return ;
 End if;
 select  usersid into auserID from  the_session where the_sessionid=acursession ;
 select LockUserID, LockSessionID
 Into aLockUserID, aLockSessionID
 from INSTANCE where INSTANCEid=aRowID ;
 If Not aLockUserID Is Null Then
   If aLockUserID &lt;&gt; auserID Then
     aisLocked := 4; /* CheckOut by another user */
     Return ;
   Else
     aisLocked := 2; /* CheckOut by caller */
     Return;
   end if;
 End if;
 If Not aLockSessionID Is Null Then
   If aLockSessionID &lt;&gt; aCURSESSION Then
     aisLocked := 3 ;/* Lockes by another user */
     Return ;
   Else
     aisLocked := 1; /* Locked by caller */
     Return ;
   end if;
 End if;
 aisLocked := 0 ;
 End;
  procedure INSTANCE_SINIT    (
aCURSESSION CHAR,
aRowID CHAR ,
 aSecurityStyleID Char
)as
aParentTable varchar2(255) ;
 aStyleID CHAR(38) ;
 atmpID CHAR(38) ;
 aaccess integer ;
 begin
  select  SecurityStyleID into atmpID from INSTANCE where INSTANCEid=aROWID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess);
 if aaccess=0
  then
    raise_application_error(-20000,'Нет прав на управление защитой.');
    return ;
  end if;
  If aSecurityStyleID Is Null Then
    select  objtype into aParentTable from instance where instanceid=aRowID ;
    select SecurityStyleID  into aStyleID from typelist where name =aParentTable ;
    update Instance set securitystyleid =aStyleID where Instanceid = aRowID;
  Else
    update Instance set securitystyleid =aSecurityStyleID where Instanceid = aRowID ;
  End if;
End;
  procedure INSTANCE_LOCK     (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer
) as
aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer ;
 aIsLocked integer ;
 existsCnt integer;
  begin
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
If existsCnt = 0 Then
    raise_application_error(-20000,'Сессия уже завершена.') ;
    Return ;
End if;
 select  usersid into auserID from  the_session where the_sessionid=acursession;
 MTO.Kernel.Instance_ISLOCKED (aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3
  then
    raise_application_error(-20000,'Объект заблокирован другим пользователем');
    Return ;
  End if;
 if aIsLocked =0
 then
  MTO.Kernel.Instance_HCL( acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3
  then
     raise_application_error(-20000,'У данного объекта имеются дочерние строки, которые заблокированы другим пользователем');
     Return ;
  End if;
 End if;
 select  SecurityStyleID into atmpid from INSTANCE where INSTANCEid=aROWID ;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKINSTANCE',aaccess=&gt;aaccess);
 if aaccess=0
  then
    raise_application_error(-20000,'Нет прав на блокировку объекта.');
    return ;
  end if;
   if  aLockMode =2
   then
    update INSTANCE  set LockUserID =auserID ,LockSessionID =null where Instanceid=aRowID ;
     Return ;
   End if ;
   if  aLockMode =1
   then
    update INSTANCE  set LockUserID =null,LockSessionID =aCURSESSION  where Instanceid=aRowID ;
     Return ;
   End if;
 End;
  procedure INSTANCE_UNLOCK (
 aCURSESSION CHAR,
 aROWID Char
) as
 aParentID CHAR(38);
 aUserID CHAR(38) ;
 aIsLocked integer ;
 aParentTable varchar2(255);
 existsCnt integer;
 begin
 -- checking the_session  --
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
if  existsCnt =0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    Return ;
  End if;
  MTO.Kernel.Instance_ISLOCKED( aCURSESSION,aROWID,aISLocked  );
 if aIsLocked &gt;=3
  then
    raise_application_error(-20000,'Объект заблокирован другим пользователем');
    Return ;
  End if;
   if  aIsLocked =2
   then
    update INSTANCE set LockUserID =null  where Instanceid=aRowID ;
     Return ;
   End if;
   if  aIsLocked =1
   then
    update INSTANCE set LockSessionID =null  where Instanceid=aRowID;
     Return ;
   End if;
 End; 
    procedure INSTANCE_BRIEF    (
 aCURSESSION CHAR,
 ainstanceid CHAR,
 aBRIEF out varchar2
) as
 atmpStr varchar2(255);
 aaccess int ;
 atmpBrief varchar2(4000) ;
 atmpID CHAR(38) ;
 existsCnt integer;
 begin
 -- checking the_session  --
 select count(*) into existsCnt  from  the_session where the_sessionid=acursession and closed=0;
If existsCnt = 0 Then
    raise_application_error(-20000,'Сессия уже завершена.') ;
    Return ;
  End if;
If ainstanceid Is Null Then
     aBRIEF:='';
    return;
end if;
 -- Brief body --
  select count(*) into existsCnt  from instance where instanceID=ainstanceID;
If existsCnt = 1 Then
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceID ;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,
     averb=&gt;'BRIEF',aaccess=&gt;aaccess);
 If aaccess = 0 Then
    raise_application_error(-20000,'Нет прав на получение краткого наименования. Раздел=instance') ;
    Return ;
 End  if;
  select func.instance_brief_F(instanceid) into aBrief from instance where instanceid=ainstanceid;
 Else
   aBRIEF:= 'неверный идентификатор';
End if;
    aBRIEF:=substr(aBRIEF,1,255);
End;
    procedure QR_AND_QR  ( aid1 CHAR, aid2
    CHAR,aidout CHAR,acnt out integer )
as
begin
delete from QueryResult where QueryResultid=aidout ;
insert into QueryResult(QueryResultid,result)
select distinct aidout, a.result
from QueryResult a
join QueryResult b on b.QueryResultid=aid2 and a.result=b.result
where a.QueryResultid=aid1 ;
select count(*) into acnt from QueryResult where QueryResultid=aidout;
end;
    procedure QR_OR_QR  ( aid1 CHAR, aid2 
    CHAR,aidout CHAR,acnt out integer)
as
begin
delete from QueryResult where QueryResultid=aidout ;
insert into QueryResult(QueryResultid,result)
select distinct aidout, result from QueryResult where QueryResultid in (aid1,aid2);
select count(*) into acnt from QueryResult where QueryResultid=aidout;
End;
  procedure ROWPARENTS
(aQueryID   CHAR
,aRowID CHAR/* Row */
,aTable varchar2 /* Part Table Name */
,aCURSESSION CHAR/* the_session */
) as
astr varchar(4000);
aplevel integer ;
aparent varchar2(255) ;
aprev varchar2(255) ;
atmpID  CHAR(38) ;
atmpRowID  CHAR(38) ;
existsCnt integer;
begin
 select count(*) into existsCnt from  the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'the_session expired') ;
    Return ;
  End if;
aparent :=atable ;
atmpID := aROWID ;
aplevel :=0 ;
delete from RPRESULT where RPRESULTID
  =aQUERYID;
insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,atable,aRowID) ;
&lt;&lt;again&gt;&gt;
 aplevel :=aplevel + 1 ;
 aprev := aparent ;
 begin
   select thevalue into aparent from sysoptions where optiontype ='PARENT' and  name=aprev ;
 exception when others then
   aparent := null ;
 end;
 if aparent is null
 then
     astr := 'select InstanceID  from ' || aprev || ' where ' || aprev || 'id=:1' ;
    execute immediate astr into atmpRowID using atmpid ;
   insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,'INSTANCE',atmpRowID);
 Else
    astr := 'select ParentStructRowID  from ' || aprev || ' where '  || aprev || 'id=:1' ;
    execute immediate astr into atmpRowID using atmpid ;
    atmpID := atmpROWID ;
   insert into RPRESULT(RPRESULTID,PARENTLEVEL,PARTNAME,theROWID)
   values(aQUERYID,aPLEVEL,aparent,atmpRowID) ;
    GoTo again ;
 End if;
End;
    procedure INSTANCE_STATUS    (
  acursession CHAR,
  ainstanceid CHAR,
  astatusid CHAR)
as
   aSSID CHAR(38);
   atmpID CHAR(38);
   aSysLogID CHAR(38) ;
   aaccess integer;
   aSysInstID CHAR(38) ;
   aObjType varchar2(255) ;
   existsCnt integer;
  begin
   select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM') ;
   select count(*) into existsCnt from instance where instanceid=ainstanceid;
 If existsCnt = 1 Then
   select  SecurityStyleID into atmpID from INSTANCE where INSTANCEid=aINSTANCEid ;
   CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'STATUS',aaccess=&gt;aaccess );
   If aaccess = 0 Then
    raise_application_error(-20000,'Нет прав на изменение состояния объекта.');
    Return ;
   End if;
    MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ainstanceid,aIsLocked=&gt;aaccess);
   If aaccess &gt; 2 Then
     raise_application_error(-20000,'Документ заблокирован другим пльзователем.') ;
     Return ;
   End if;
   select objtype into aObjType from instance  where  instanceid=ainstanceid ;
   select count(*) into existsCnt from objstatus
  join objecttype on objstatus.parentstructrowid=objecttype.objecttypeid
  where objecttype.name=aobjtype and objstatusid=astatusid ;
   If existsCnt = 1 Then
     update instance set status = astatusid where  instanceid=ainstanceid ;
     select newid() into aSysLogid from sys.dual;
     MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; aSTATUSID ,
     aVERB=&gt;'STATUS',  aThe_Resource=&gt;aInstanceID , aLogInstanceID=&gt;aInstanceID); 
   End if;
 End if;
End;
 end Kernel;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Procedures.Type.Body" File="">
    <BlockHolder BlockName="--body" BlockCode=" 
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzmetamodel" BlockCode=" create or replace package body mtzmetamodel as

procedure mtzmetamodel_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzmetamodel'
then
declare cursor child_genpackage is select genpackage.genpackageid ID from genpackage where  genpackage.InstanceID = ainstanceid;
row_genpackage  child_genpackage%ROWTYPE;
begin
--open child_genpackage;
for row_genpackage in child_genpackage loop
 genpackage_DELETE (acursession,row_genpackage.id,aInstanceID);
end loop;
--close child_genpackage;
end;
declare cursor child_localizeinfo is select localizeinfo.localizeinfoid ID from localizeinfo where  localizeinfo.InstanceID = ainstanceid;
row_localizeinfo  child_localizeinfo%ROWTYPE;
begin
--open child_localizeinfo;
for row_localizeinfo in child_localizeinfo loop
 localizeinfo_DELETE (acursession,row_localizeinfo.id,aInstanceID);
end loop;
--close child_localizeinfo;
end;
declare cursor child_fieldtype is select fieldtype.fieldtypeid ID from fieldtype where  fieldtype.InstanceID = ainstanceid;
row_fieldtype  child_fieldtype%ROWTYPE;
begin
--open child_fieldtype;
for row_fieldtype in child_fieldtype loop
 fieldtype_DELETE (acursession,row_fieldtype.id,aInstanceID);
end loop;
--close child_fieldtype;
end;
declare cursor child_sharedmethod is select sharedmethod.sharedmethodid ID from sharedmethod where  sharedmethod.InstanceID = ainstanceid;
row_sharedmethod  child_sharedmethod%ROWTYPE;
begin
--open child_sharedmethod;
for row_sharedmethod in child_sharedmethod loop
 sharedmethod_DELETE (acursession,row_sharedmethod.id,aInstanceID);
end loop;
--close child_sharedmethod;
end;
declare cursor child_objecttype is select objecttype.objecttypeid ID from objecttype where  objecttype.InstanceID = ainstanceid;
row_objecttype  child_objecttype%ROWTYPE;
begin
--open child_objecttype;
for row_objecttype in child_objecttype loop
 objecttype_DELETE (acursession,row_objecttype.id,aInstanceID);
end loop;
--close child_objecttype;
end;
declare cursor child_mtzapp is select mtzapp.mtzappid ID from mtzapp where  mtzapp.InstanceID = ainstanceid;
row_mtzapp  child_mtzapp%ROWTYPE;
begin
--open child_mtzapp;
for row_mtzapp in child_mtzapp loop
 mtzapp_DELETE (acursession,row_mtzapp.id,aInstanceID);
end loop;
--close child_mtzapp;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzmetamodel_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzmetamodel'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_genpackage is select genpackage.genpackageid ID from genpackage where  genpackage.InstanceID = arowid;
ROW_genpackage  lch_genpackage%ROWTYPE;
begin
--open lch_genpackage;
for row_genpackage in lch_genpackage loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from genpackage where genpackageid=row_genpackage.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_genpackage;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_genpackage;
     return;
   end if; 
 end if; 
 genpackage_HCL (acursession,ROW_genpackage.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_genpackage;
   return;
 end if;
 end loop;
--close lch_genpackage;
end;
declare cursor lch_localizeinfo is select localizeinfo.localizeinfoid ID from localizeinfo where  localizeinfo.InstanceID = arowid;
ROW_localizeinfo  lch_localizeinfo%ROWTYPE;
begin
--open lch_localizeinfo;
for row_localizeinfo in lch_localizeinfo loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from localizeinfo where localizeinfoid=row_localizeinfo.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_localizeinfo;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_localizeinfo;
     return;
   end if; 
 end if; 
 localizeinfo_HCL (acursession,ROW_localizeinfo.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_localizeinfo;
   return;
 end if;
 end loop;
--close lch_localizeinfo;
end;
declare cursor lch_fieldtype is select fieldtype.fieldtypeid ID from fieldtype where  fieldtype.InstanceID = arowid;
ROW_fieldtype  lch_fieldtype%ROWTYPE;
begin
--open lch_fieldtype;
for row_fieldtype in lch_fieldtype loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from fieldtype where fieldtypeid=row_fieldtype.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldtype;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_fieldtype;
     return;
   end if; 
 end if; 
 fieldtype_HCL (acursession,ROW_fieldtype.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldtype;
   return;
 end if;
 end loop;
--close lch_fieldtype;
end;
declare cursor lch_sharedmethod is select sharedmethod.sharedmethodid ID from sharedmethod where  sharedmethod.InstanceID = arowid;
ROW_sharedmethod  lch_sharedmethod%ROWTYPE;
begin
--open lch_sharedmethod;
for row_sharedmethod in lch_sharedmethod loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from sharedmethod where sharedmethodid=row_sharedmethod.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_sharedmethod;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_sharedmethod;
     return;
   end if; 
 end if; 
 sharedmethod_HCL (acursession,ROW_sharedmethod.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_sharedmethod;
   return;
 end if;
 end loop;
--close lch_sharedmethod;
end;
declare cursor lch_objecttype is select objecttype.objecttypeid ID from objecttype where  objecttype.InstanceID = arowid;
ROW_objecttype  lch_objecttype%ROWTYPE;
begin
--open lch_objecttype;
for row_objecttype in lch_objecttype loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from objecttype where objecttypeid=row_objecttype.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_objecttype;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_objecttype;
     return;
   end if; 
 end if; 
 objecttype_HCL (acursession,ROW_objecttype.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_objecttype;
   return;
 end if;
 end loop;
--close lch_objecttype;
end;
declare cursor lch_mtzapp is select mtzapp.mtzappid ID from mtzapp where  mtzapp.InstanceID = arowid;
ROW_mtzapp  lch_mtzapp%ROWTYPE;
begin
--open lch_mtzapp;
for row_mtzapp in lch_mtzapp loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from mtzapp where mtzappid=row_mtzapp.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_mtzapp;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_mtzapp;
     return;
   end if; 
 end if; 
 mtzapp_HCL (acursession,ROW_mtzapp.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_mtzapp;
   return;
 end if;
 end loop;
--close lch_mtzapp;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzmetamodel_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzmetamodel'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_genpackage is select genpackage.genpackageid id from genpackage where  genpackage.InstanceID = arowid;
row_genpackage  pch_genpackage%ROWTYPE;
begin
--open pch_genpackage;
for row_genpackage in  pch_genpackage loop
 genpackage_SINIT( acursession,row_genpackage.id,assid);
 genpackage_propagate( acursession,row_genpackage.id);
end loop;
--close pch_genpackage;
end;
declare cursor pch_localizeinfo is select localizeinfo.localizeinfoid id from localizeinfo where  localizeinfo.InstanceID = arowid;
row_localizeinfo  pch_localizeinfo%ROWTYPE;
begin
--open pch_localizeinfo;
for row_localizeinfo in  pch_localizeinfo loop
 localizeinfo_SINIT( acursession,row_localizeinfo.id,assid);
 localizeinfo_propagate( acursession,row_localizeinfo.id);
end loop;
--close pch_localizeinfo;
end;
declare cursor pch_fieldtype is select fieldtype.fieldtypeid id from fieldtype where  fieldtype.InstanceID = arowid;
row_fieldtype  pch_fieldtype%ROWTYPE;
begin
--open pch_fieldtype;
for row_fieldtype in  pch_fieldtype loop
 fieldtype_SINIT( acursession,row_fieldtype.id,assid);
 fieldtype_propagate( acursession,row_fieldtype.id);
end loop;
--close pch_fieldtype;
end;
declare cursor pch_sharedmethod is select sharedmethod.sharedmethodid id from sharedmethod where  sharedmethod.InstanceID = arowid;
row_sharedmethod  pch_sharedmethod%ROWTYPE;
begin
--open pch_sharedmethod;
for row_sharedmethod in  pch_sharedmethod loop
 sharedmethod_SINIT( acursession,row_sharedmethod.id,assid);
 sharedmethod_propagate( acursession,row_sharedmethod.id);
end loop;
--close pch_sharedmethod;
end;
declare cursor pch_objecttype is select objecttype.objecttypeid id from objecttype where  objecttype.InstanceID = arowid;
row_objecttype  pch_objecttype%ROWTYPE;
begin
--open pch_objecttype;
for row_objecttype in  pch_objecttype loop
 objecttype_SINIT( acursession,row_objecttype.id,assid);
 objecttype_propagate( acursession,row_objecttype.id);
end loop;
--close pch_objecttype;
end;
declare cursor pch_mtzapp is select mtzapp.mtzappid id from mtzapp where  mtzapp.InstanceID = arowid;
row_mtzapp  pch_mtzapp%ROWTYPE;
begin
--open pch_mtzapp;
for row_mtzapp in  pch_mtzapp loop
 mtzapp_SINIT( acursession,row_mtzapp.id,assid);
 mtzapp_propagate( acursession,row_mtzapp.id);
end loop;
--close pch_mtzapp;
end;
 end if; 
end;


procedure genpackage_BRIEF  (
 aCURSESSION CHAR,
 agenpackageid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if agenpackageid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from genpackage where genpackageID=agenpackageID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from genpackage where genpackageid=agenpackageID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=genpackage');
    return;
  end if;
  aBRIEF:=func.genpackage_BRIEF_F(agenpackageid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure genpackage_DELETE /*Пакет генерации*/ (
 aCURSESSION CHAR,
 agenpackageid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from genpackage where genpackageID=agenpackageID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from genpackage where genpackageid=agenpackageID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:genpackage',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=genpackage');
      return;
    end if;
  end if;
 --  verify lock  --
 genpackage_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenpackageid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=genpackage');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_generator_target is select generator_target.generator_targetid ID from generator_target where  generator_target.ParentStructRowID = agenpackageid;
    child_generator_target_rec  child_generator_target%ROWTYPE;
    begin
    --open child_generator_target;
      for child_generator_target_rec in child_generator_target loop
      generator_target_DELETE (acursession,child_generator_target_rec.id,aInstanceid);
      end loop;
      --close child_generator_target;
    end ;
declare cursor chld_genpackage is select  instanceid ID from instance where OwnerPartName ='genpackage' and OwnerRowID=agenpackageid;
row_genpackage  chld_genpackage%ROWTYPE;
begin
--open chld_genpackage;
for row_genpackage in chld_genpackage loop
 Kernel.INSTANCE_OWNER (acursession,row_genpackage.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_genpackage.id);
end loop;
--close chld_genpackage;
end ;
  delete from  genpackage 
  where  genpackageID = agenpackageID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Пакет генерации*/
procedure genpackage_SAVE /*Пакет генерации*/ (
 aCURSESSION CHAR,
 agenpackageid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from genpackage where genpackageID=agenpackageID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from genpackage where genpackageid=agenpackageID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:genpackage',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=genpackage');
      return;
    end if;
  end if;
 --  verify lock  --
 genpackage_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenpackageid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=genpackage');
    return;
  end if;
 -- update row  --
 update  genpackage set ChangeStamp=sysdate
,
  name=aname
  where  genpackageID = agenpackageID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:genpackage',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=genpackage');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=genpackage');
    return;
  end if;
 insert into   genpackage
 (  genpackageID 
,InstanceID
,name

 ) values ( agenpackageID 
,aInstanceID
,aname

 ); 
 genpackage_SINIT( aCURSESSION,agenpackageid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure genpackage_PARENT /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from genpackage where  genpackageid=aRowID;
 end; 

procedure genpackage_ISLOCKED /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from genpackage where genpackageid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  genpackage_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure genpackage_LOCK /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 genpackage_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  genpackage_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from genpackage where genpackageid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=genpackage');
    return;
  end if;
   if  aLockMode =2  
   then   
    update genpackage set LockUserID =auserID ,LockSessionID =null where genpackageid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update genpackage set LockUserID =null,LockSessionID =aCURSESSION  where genpackageid=aRowID;
     return;
   end if;
 end ;

procedure genpackage_HCL /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_generator_target is select generator_target.generator_targetid ID from generator_target where  generator_target.ParentStructRowID = aRowid;
row_generator_target lch_generator_target%ROWTYPE;
begin  
--open lch_generator_target;
for row_generator_target in lch_generator_target
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from generator_target where generator_targetid=row_generator_target.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_generator_target;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_generator_target;
     return;
   end if; 
 end if;  
 generator_target_HCL (acursession,row_generator_target.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_generator_target;
   return;
 end if;
end loop;
--close lch_generator_target;
end;
aIsLocked :=0;
end;

procedure genpackage_UNLOCK /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 genpackage_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update genpackage set LockUserID =null  where genpackageid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update genpackage set LockSessionID =null  where genpackageid=aRowID;
     return;
   end if;
 end; 

procedure genpackage_SINIT /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from genpackage where genpackageid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =genpackage');
    return;
  end if;
if aSecurityStyleID is null then
 genpackage_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update genpackage set securitystyleid =aStyleID where genpackageid = aRowID;
else 
 update genpackage set securitystyleid =aSecurityStyleID where genpackageid = aRowID;
end if; 
end ; 

procedure genpackage_propagate /*Пакет генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from genpackage where genpackageid=aRowid;
declare cursor pch_generator_target  is select generator_target.generator_targetid ID from generator_target where  generator_target.ParentStructRowID = aRowid;
row_generator_target  pch_generator_target%ROWTYPE;
begin
--open pch_generator_target;
for row_generator_target in pch_generator_target loop
   generator_target_SINIT( acursession,row_generator_target.id,assid);
   generator_target_propagate( acursession,row_generator_target.id);
end loop;
--close pch_generator_target;
end;
end;


procedure generator_target_BRIEF  (
 aCURSESSION CHAR,
 agenerator_targetid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if agenerator_targetid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from generator_target where generator_targetID=agenerator_targetID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from generator_target where generator_targetid=agenerator_targetID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=generator_target');
    return;
  end if;
  aBRIEF:=func.generator_target_BRIEF_F(agenerator_targetid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure generator_target_DELETE /*Генераторы*/ (
 aCURSESSION CHAR,
 agenerator_targetid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from generator_target where generator_targetID=agenerator_targetID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from generator_target where generator_targetid=agenerator_targetID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:generator_target',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=generator_target');
      return;
    end if;
  end if;
 --  verify lock  --
 generator_target_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenerator_targetid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=generator_target');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_genreference is select genreference.genreferenceid ID from genreference where  genreference.ParentStructRowID = agenerator_targetid;
    child_genreference_rec  child_genreference%ROWTYPE;
    begin
    --open child_genreference;
      for child_genreference_rec in child_genreference loop
      genreference_DELETE (acursession,child_genreference_rec.id,aInstanceid);
      end loop;
      --close child_genreference;
    end ;
    declare cursor child_genmanualcode is select genmanualcode.genmanualcodeid ID from genmanualcode where  genmanualcode.ParentStructRowID = agenerator_targetid;
    child_genmanualcode_rec  child_genmanualcode%ROWTYPE;
    begin
    --open child_genmanualcode;
      for child_genmanualcode_rec in child_genmanualcode loop
      genmanualcode_DELETE (acursession,child_genmanualcode_rec.id,aInstanceid);
      end loop;
      --close child_genmanualcode;
    end ;
    declare cursor child_gencontrols is select gencontrols.gencontrolsid ID from gencontrols where  gencontrols.ParentStructRowID = agenerator_targetid;
    child_gencontrols_rec  child_gencontrols%ROWTYPE;
    begin
    --open child_gencontrols;
      for child_gencontrols_rec in child_gencontrols loop
      gencontrols_DELETE (acursession,child_gencontrols_rec.id,aInstanceid);
      end loop;
      --close child_gencontrols;
    end ;
declare cursor chld_generator_target is select  instanceid ID from instance where OwnerPartName ='generator_target' and OwnerRowID=agenerator_targetid;
row_generator_target  chld_generator_target%ROWTYPE;
begin
--open chld_generator_target;
for row_generator_target in chld_generator_target loop
 Kernel.INSTANCE_OWNER (acursession,row_generator_target.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_generator_target.id);
end loop;
--close chld_generator_target;
end ;
  delete from  generator_target 
  where  generator_targetID = agenerator_targetID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Генераторы*/
procedure generator_target_SAVE /*Генераторы*/ (
 aCURSESSION CHAR,
 agenerator_targetid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atargettype
 NUMBER/* Тип платформы *//* Тип платформы */
,aqueuename
 VARCHAR2 := null /* Очередь *//* Очередь */
,ageneratorprogid
 VARCHAR2 := null /* COM класс *//* COM класс */
,ageneratorstyle
 NUMBER := null /* Вариант *//* Вариант */
,athedevelopmentenv
 NUMBER := null /* Среда разработки *//* Среда разработки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from generator_target where generator_targetID=agenerator_targetID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from generator_target where generator_targetid=agenerator_targetID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:generator_target',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=generator_target');
      return;
    end if;
  end if;
 --  verify lock  --
 generator_target_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenerator_targetid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=generator_target');
    return;
  end if;
 -- update row  --
 update  generator_target set ChangeStamp=sysdate
,
  name=aname
,
  targettype=atargettype
,
  queuename=aqueuename
,
  generatorprogid=ageneratorprogid
,
  generatorstyle=ageneratorstyle
,
  thedevelopmentenv=athedevelopmentenv
  where  generator_targetID = agenerator_targetID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from genpackage where genpackageid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:generator_target',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=generator_target');
      return;
    end if;
 end if;
 genpackage_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=generator_target');
    return;
  end if;
 insert into   generator_target
 (  generator_targetID 
,ParentStructRowID
,name

,targettype

,queuename

,generatorprogid

,generatorstyle

,thedevelopmentenv

 ) values ( agenerator_targetID 
,aParentStructRowID
,aname

,atargettype

,aqueuename

,ageneratorprogid

,ageneratorstyle

,athedevelopmentenv

 ); 
 generator_target_SINIT( aCURSESSION,agenerator_targetid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure generator_target_PARENT /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from generator_target where  generator_targetid=aRowID;
  aParentTable := 'genpackage';
 end; 

procedure generator_target_ISLOCKED /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from generator_target where generator_targetid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  generator_target_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure generator_target_LOCK /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 generator_target_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  generator_target_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from generator_target where generator_targetid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=generator_target');
    return;
  end if;
   if  aLockMode =2  
   then   
    update generator_target set LockUserID =auserID ,LockSessionID =null where generator_targetid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update generator_target set LockUserID =null,LockSessionID =aCURSESSION  where generator_targetid=aRowID;
     return;
   end if;
 end ;

procedure generator_target_HCL /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_genreference is select genreference.genreferenceid ID from genreference where  genreference.ParentStructRowID = aRowid;
row_genreference lch_genreference%ROWTYPE;
begin  
--open lch_genreference;
for row_genreference in lch_genreference
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from genreference where genreferenceid=row_genreference.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_genreference;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_genreference;
     return;
   end if; 
 end if;  
 genreference_HCL (acursession,row_genreference.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_genreference;
   return;
 end if;
end loop;
--close lch_genreference;
end;
declare cursor lch_genmanualcode is select genmanualcode.genmanualcodeid ID from genmanualcode where  genmanualcode.ParentStructRowID = aRowid;
row_genmanualcode lch_genmanualcode%ROWTYPE;
begin  
--open lch_genmanualcode;
for row_genmanualcode in lch_genmanualcode
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from genmanualcode where genmanualcodeid=row_genmanualcode.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_genmanualcode;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_genmanualcode;
     return;
   end if; 
 end if;  
 genmanualcode_HCL (acursession,row_genmanualcode.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_genmanualcode;
   return;
 end if;
end loop;
--close lch_genmanualcode;
end;
declare cursor lch_gencontrols is select gencontrols.gencontrolsid ID from gencontrols where  gencontrols.ParentStructRowID = aRowid;
row_gencontrols lch_gencontrols%ROWTYPE;
begin  
--open lch_gencontrols;
for row_gencontrols in lch_gencontrols
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from gencontrols where gencontrolsid=row_gencontrols.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_gencontrols;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_gencontrols;
     return;
   end if; 
 end if;  
 gencontrols_HCL (acursession,row_gencontrols.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_gencontrols;
   return;
 end if;
end loop;
--close lch_gencontrols;
end;
aIsLocked :=0;
end;

procedure generator_target_UNLOCK /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 generator_target_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update generator_target set LockUserID =null  where generator_targetid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update generator_target set LockSessionID =null  where generator_targetid=aRowID;
     return;
   end if;
 end; 

procedure generator_target_SINIT /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from generator_target where generator_targetid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =generator_target');
    return;
  end if;
if aSecurityStyleID is null then
 generator_target_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update generator_target set securitystyleid =aStyleID where generator_targetid = aRowID;
else 
 update generator_target set securitystyleid =aSecurityStyleID where generator_targetid = aRowID;
end if; 
end ; 

procedure generator_target_propagate /*Генераторы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from generator_target where generator_targetid=aRowid;
declare cursor pch_genreference  is select genreference.genreferenceid ID from genreference where  genreference.ParentStructRowID = aRowid;
row_genreference  pch_genreference%ROWTYPE;
begin
--open pch_genreference;
for row_genreference in pch_genreference loop
   genreference_SINIT( acursession,row_genreference.id,assid);
   genreference_propagate( acursession,row_genreference.id);
end loop;
--close pch_genreference;
end;
declare cursor pch_genmanualcode  is select genmanualcode.genmanualcodeid ID from genmanualcode where  genmanualcode.ParentStructRowID = aRowid;
row_genmanualcode  pch_genmanualcode%ROWTYPE;
begin
--open pch_genmanualcode;
for row_genmanualcode in pch_genmanualcode loop
   genmanualcode_SINIT( acursession,row_genmanualcode.id,assid);
   genmanualcode_propagate( acursession,row_genmanualcode.id);
end loop;
--close pch_genmanualcode;
end;
declare cursor pch_gencontrols  is select gencontrols.gencontrolsid ID from gencontrols where  gencontrols.ParentStructRowID = aRowid;
row_gencontrols  pch_gencontrols%ROWTYPE;
begin
--open pch_gencontrols;
for row_gencontrols in pch_gencontrols loop
   gencontrols_SINIT( acursession,row_gencontrols.id,assid);
   gencontrols_propagate( acursession,row_gencontrols.id);
end loop;
--close pch_gencontrols;
end;
end;


procedure genreference_BRIEF  (
 aCURSESSION CHAR,
 agenreferenceid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if agenreferenceid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from genreference where genreferenceID=agenreferenceID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from genreference where genreferenceid=agenreferenceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=genreference');
    return;
  end if;
  aBRIEF:=func.genreference_BRIEF_F(agenreferenceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure genreference_DELETE /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 agenreferenceid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from genreference where genreferenceID=agenreferenceID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from genreference where genreferenceid=agenreferenceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:genreference',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=genreference');
      return;
    end if;
  end if;
 --  verify lock  --
 genreference_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenreferenceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=genreference');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_genreference is select  instanceid ID from instance where OwnerPartName ='genreference' and OwnerRowID=agenreferenceid;
row_genreference  chld_genreference%ROWTYPE;
begin
--open chld_genreference;
for row_genreference in chld_genreference loop
 Kernel.INSTANCE_OWNER (acursession,row_genreference.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_genreference.id);
end loop;
--close chld_genreference;
end ;
  delete from  genreference 
  where  genreferenceID = agenreferenceID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Библиотеки*/
procedure genreference_SAVE /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 agenreferenceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,arefclassid
 VARCHAR2 := null /* Класс ссылки *//* Класс ссылки */
,aversionmajor
 NUMBER := null /* Номер версии *//* Номер версии */
,aversionminor
 NUMBER := null /* Подверсия *//* Подверсия */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from genreference where genreferenceID=agenreferenceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from genreference where genreferenceid=agenreferenceID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:genreference',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=genreference');
      return;
    end if;
  end if;
 --  verify lock  --
 genreference_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenreferenceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=genreference');
    return;
  end if;
 -- update row  --
 update  genreference set ChangeStamp=sysdate
,
  name=aname
,
  refclassid=arefclassid
,
  versionmajor=aversionmajor
,
  versionminor=aversionminor
  where  genreferenceID = agenreferenceID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from generator_target where generator_targetid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:genreference',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=genreference');
      return;
    end if;
 end if;
 generator_target_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=genreference');
    return;
  end if;
 insert into   genreference
 (  genreferenceID 
,ParentStructRowID
,name

,refclassid

,versionmajor

,versionminor

 ) values ( agenreferenceID 
,aParentStructRowID
,aname

,arefclassid

,aversionmajor

,aversionminor

 ); 
 genreference_SINIT( aCURSESSION,agenreferenceid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure genreference_PARENT /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from genreference where  genreferenceid=aRowID;
  aParentTable := 'generator_target';
 end; 

procedure genreference_ISLOCKED /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from genreference where genreferenceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  genreference_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure genreference_LOCK /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 genreference_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  genreference_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from genreference where genreferenceid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=genreference');
    return;
  end if;
   if  aLockMode =2  
   then   
    update genreference set LockUserID =auserID ,LockSessionID =null where genreferenceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update genreference set LockUserID =null,LockSessionID =aCURSESSION  where genreferenceid=aRowID;
     return;
   end if;
 end ;

procedure genreference_HCL /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure genreference_UNLOCK /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 genreference_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update genreference set LockUserID =null  where genreferenceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update genreference set LockSessionID =null  where genreferenceid=aRowID;
     return;
   end if;
 end; 

procedure genreference_SINIT /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from genreference where genreferenceid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =genreference');
    return;
  end if;
if aSecurityStyleID is null then
 genreference_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update genreference set securitystyleid =aStyleID where genreferenceid = aRowID;
else 
 update genreference set securitystyleid =aSecurityStyleID where genreferenceid = aRowID;
end if; 
end ; 

procedure genreference_propagate /*Библиотеки, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from genreference where genreferenceid=aRowid;
end;


procedure genmanualcode_BRIEF  (
 aCURSESSION CHAR,
 agenmanualcodeid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if agenmanualcodeid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from genmanualcode where genmanualcodeID=agenmanualcodeID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from genmanualcode where genmanualcodeid=agenmanualcodeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=genmanualcode');
    return;
  end if;
  aBRIEF:=func.genmanualcode_BRIEF_F(agenmanualcodeid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure genmanualcode_DELETE /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 agenmanualcodeid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from genmanualcode where genmanualcodeID=agenmanualcodeID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from genmanualcode where genmanualcodeid=agenmanualcodeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:genmanualcode',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=genmanualcode');
      return;
    end if;
  end if;
 --  verify lock  --
 genmanualcode_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenmanualcodeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=genmanualcode');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_genmanualcode is select  instanceid ID from instance where OwnerPartName ='genmanualcode' and OwnerRowID=agenmanualcodeid;
row_genmanualcode  chld_genmanualcode%ROWTYPE;
begin
--open chld_genmanualcode;
for row_genmanualcode in chld_genmanualcode loop
 Kernel.INSTANCE_OWNER (acursession,row_genmanualcode.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_genmanualcode.id);
end loop;
--close chld_genmanualcode;
end ;
  delete from  genmanualcode 
  where  genmanualcodeID = agenmanualcodeID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ручной код*/
procedure genmanualcode_SAVE /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 agenmanualcodeid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,acode VARCHAR2/* Код *//* Код */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from genmanualcode where genmanualcodeID=agenmanualcodeID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from genmanualcode where genmanualcodeid=agenmanualcodeID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:genmanualcode',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=genmanualcode');
      return;
    end if;
  end if;
 --  verify lock  --
 genmanualcode_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agenmanualcodeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=genmanualcode');
    return;
  end if;
 -- update row  --
 update  genmanualcode set ChangeStamp=sysdate
,
  name=aname
,
  the_alias=athe_alias
,
  code=acode
  where  genmanualcodeID = agenmanualcodeID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from generator_target where generator_targetid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:genmanualcode',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=genmanualcode');
      return;
    end if;
 end if;
 generator_target_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=genmanualcode');
    return;
  end if;
 insert into   genmanualcode
 (  genmanualcodeID 
,ParentStructRowID
,name

,the_alias

,code

 ) values ( agenmanualcodeID 
,aParentStructRowID
,aname

,athe_alias

,acode

 ); 
 genmanualcode_SINIT( aCURSESSION,agenmanualcodeid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure genmanualcode_PARENT /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from genmanualcode where  genmanualcodeid=aRowID;
  aParentTable := 'generator_target';
 end; 

procedure genmanualcode_ISLOCKED /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from genmanualcode where genmanualcodeid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  genmanualcode_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure genmanualcode_LOCK /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 genmanualcode_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  genmanualcode_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from genmanualcode where genmanualcodeid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=genmanualcode');
    return;
  end if;
   if  aLockMode =2  
   then   
    update genmanualcode set LockUserID =auserID ,LockSessionID =null where genmanualcodeid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update genmanualcode set LockUserID =null,LockSessionID =aCURSESSION  where genmanualcodeid=aRowID;
     return;
   end if;
 end ;

procedure genmanualcode_HCL /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure genmanualcode_UNLOCK /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 genmanualcode_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update genmanualcode set LockUserID =null  where genmanualcodeid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update genmanualcode set LockSessionID =null  where genmanualcodeid=aRowID;
     return;
   end if;
 end; 

procedure genmanualcode_SINIT /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from genmanualcode where genmanualcodeid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =genmanualcode');
    return;
  end if;
if aSecurityStyleID is null then
 genmanualcode_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update genmanualcode set securitystyleid =aStyleID where genmanualcodeid = aRowID;
else 
 update genmanualcode set securitystyleid =aSecurityStyleID where genmanualcodeid = aRowID;
end if; 
end ; 

procedure genmanualcode_propagate /*Код, который не укладывается в описание модели*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from genmanualcode where genmanualcodeid=aRowid;
end;


procedure gencontrols_BRIEF  (
 aCURSESSION CHAR,
 agencontrolsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if agencontrolsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from gencontrols where gencontrolsID=agencontrolsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from gencontrols where gencontrolsid=agencontrolsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=gencontrols');
    return;
  end if;
  aBRIEF:=func.gencontrols_BRIEF_F(agencontrolsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure gencontrols_DELETE /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 agencontrolsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from gencontrols where gencontrolsID=agencontrolsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from gencontrols where gencontrolsid=agencontrolsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:gencontrols',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=gencontrols');
      return;
    end if;
  end if;
 --  verify lock  --
 gencontrols_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agencontrolsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=gencontrols');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_gencontrols is select  instanceid ID from instance where OwnerPartName ='gencontrols' and OwnerRowID=agencontrolsid;
row_gencontrols  chld_gencontrols%ROWTYPE;
begin
--open chld_gencontrols;
for row_gencontrols in chld_gencontrols loop
 Kernel.INSTANCE_OWNER (acursession,row_gencontrols.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_gencontrols.id);
end loop;
--close chld_gencontrols;
end ;
  delete from  gencontrols 
  where  gencontrolsID = agencontrolsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Контрольные элементы*/
procedure gencontrols_SAVE /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 agencontrolsid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,acontrolprogid
 VARCHAR2/* ProgID контрольконо элемента *//* ProgID контрольконо элемента */
,acontrolclassid
 VARCHAR2 := null /* Класс контрольногоэлемента *//* Класс контрольногоэлемента */
,aversionmajor
 NUMBER := null /* Версия *//* Версия */
,aversionminor
 NUMBER := null /* Подверсия *//* Подверсия */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from gencontrols where gencontrolsID=agencontrolsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from gencontrols where gencontrolsid=agencontrolsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:gencontrols',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=gencontrols');
      return;
    end if;
  end if;
 --  verify lock  --
 gencontrols_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agencontrolsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=gencontrols');
    return;
  end if;
 -- update row  --
 update  gencontrols set ChangeStamp=sysdate
,
  controlprogid=acontrolprogid
,
  controlclassid=acontrolclassid
,
  versionmajor=aversionmajor
,
  versionminor=aversionminor
  where  gencontrolsID = agencontrolsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from generator_target where generator_targetid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:gencontrols',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=gencontrols');
      return;
    end if;
 end if;
 generator_target_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=gencontrols');
    return;
  end if;
 insert into   gencontrols
 (  gencontrolsID 
,ParentStructRowID
,controlprogid

,controlclassid

,versionmajor

,versionminor

 ) values ( agencontrolsID 
,aParentStructRowID
,acontrolprogid

,acontrolclassid

,aversionmajor

,aversionminor

 ); 
 gencontrols_SINIT( aCURSESSION,agencontrolsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure gencontrols_PARENT /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from gencontrols where  gencontrolsid=aRowID;
  aParentTable := 'generator_target';
 end; 

procedure gencontrols_ISLOCKED /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from gencontrols where gencontrolsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  gencontrols_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure gencontrols_LOCK /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 gencontrols_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  gencontrols_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from gencontrols where gencontrolsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=gencontrols');
    return;
  end if;
   if  aLockMode =2  
   then   
    update gencontrols set LockUserID =auserID ,LockSessionID =null where gencontrolsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update gencontrols set LockUserID =null,LockSessionID =aCURSESSION  where gencontrolsid=aRowID;
     return;
   end if;
 end ;

procedure gencontrols_HCL /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure gencontrols_UNLOCK /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 gencontrols_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update gencontrols set LockUserID =null  where gencontrolsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update gencontrols set LockSessionID =null  where gencontrolsid=aRowID;
     return;
   end if;
 end; 

procedure gencontrols_SINIT /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from gencontrols where gencontrolsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =gencontrols');
    return;
  end if;
if aSecurityStyleID is null then
 gencontrols_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update gencontrols set securitystyleid =aStyleID where gencontrolsid = aRowID;
else 
 update gencontrols set securitystyleid =aSecurityStyleID where gencontrolsid = aRowID;
end if; 
end ; 

procedure gencontrols_propagate /*Контрольные элементы, которые используются при генерации*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from gencontrols where gencontrolsid=aRowid;
end;


procedure localizeinfo_BRIEF  (
 aCURSESSION CHAR,
 alocalizeinfoid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if alocalizeinfoid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from localizeinfo where localizeinfoID=alocalizeinfoID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from localizeinfo where localizeinfoid=alocalizeinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=localizeinfo');
    return;
  end if;
  aBRIEF:=func.localizeinfo_BRIEF_F(alocalizeinfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure localizeinfo_DELETE /**/ (
 aCURSESSION CHAR,
 alocalizeinfoid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from localizeinfo where localizeinfoID=alocalizeinfoID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from localizeinfo where localizeinfoid=alocalizeinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:localizeinfo',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=localizeinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 localizeinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;alocalizeinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=localizeinfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_localizeinfo is select  instanceid ID from instance where OwnerPartName ='localizeinfo' and OwnerRowID=alocalizeinfoid;
row_localizeinfo  chld_localizeinfo%ROWTYPE;
begin
--open chld_localizeinfo;
for row_localizeinfo in chld_localizeinfo loop
 Kernel.INSTANCE_OWNER (acursession,row_localizeinfo.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_localizeinfo.id);
end loop;
--close chld_localizeinfo;
end ;
  delete from  localizeinfo 
  where  localizeinfoID = alocalizeinfoID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Локализация*/
procedure localizeinfo_SAVE /**/ (
 aCURSESSION CHAR,
 alocalizeinfoid CHAR,
aInstanceID CHAR 
,alangfull
 VARCHAR2/* Язык - название *//* Язык - название */
,alangshort
 VARCHAR2/* Код языка *//* Код языка */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from localizeinfo where localizeinfoID=alocalizeinfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from localizeinfo where localizeinfoid=alocalizeinfoID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:localizeinfo',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=localizeinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 localizeinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;alocalizeinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=localizeinfo');
    return;
  end if;
 -- update row  --
 update  localizeinfo set ChangeStamp=sysdate
,
  langfull=alangfull
,
  langshort=alangshort
  where  localizeinfoID = alocalizeinfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:localizeinfo',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=localizeinfo');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=localizeinfo');
    return;
  end if;
 insert into   localizeinfo
 (  localizeinfoID 
,InstanceID
,langfull

,langshort

 ) values ( alocalizeinfoID 
,aInstanceID
,alangfull

,alangshort

 ); 
 localizeinfo_SINIT( aCURSESSION,alocalizeinfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure localizeinfo_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from localizeinfo where  localizeinfoid=aRowID;
 end; 

procedure localizeinfo_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from localizeinfo where localizeinfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  localizeinfo_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure localizeinfo_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 localizeinfo_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  localizeinfo_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from localizeinfo where localizeinfoid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=localizeinfo');
    return;
  end if;
   if  aLockMode =2  
   then   
    update localizeinfo set LockUserID =auserID ,LockSessionID =null where localizeinfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update localizeinfo set LockUserID =null,LockSessionID =aCURSESSION  where localizeinfoid=aRowID;
     return;
   end if;
 end ;

procedure localizeinfo_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure localizeinfo_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 localizeinfo_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update localizeinfo set LockUserID =null  where localizeinfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update localizeinfo set LockSessionID =null  where localizeinfoid=aRowID;
     return;
   end if;
 end; 

procedure localizeinfo_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from localizeinfo where localizeinfoid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =localizeinfo');
    return;
  end if;
if aSecurityStyleID is null then
 localizeinfo_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update localizeinfo set securitystyleid =aStyleID where localizeinfoid = aRowID;
else 
 update localizeinfo set securitystyleid =aSecurityStyleID where localizeinfoid = aRowID;
end if; 
end ; 

procedure localizeinfo_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from localizeinfo where localizeinfoid=aRowid;
end;


procedure fieldtype_BRIEF  (
 aCURSESSION CHAR,
 afieldtypeid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldtypeid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldtype where fieldtypeID=afieldtypeID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldtype where fieldtypeid=afieldtypeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldtype');
    return;
  end if;
  aBRIEF:=func.fieldtype_BRIEF_F(afieldtypeid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldtype_DELETE /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 afieldtypeid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldtype where fieldtypeID=afieldtypeID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldtype where fieldtypeid=afieldtypeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldtype',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldtype');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldtype_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldtypeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldtype');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_enumitem is select enumitem.enumitemid ID from enumitem where  enumitem.ParentStructRowID = afieldtypeid;
    child_enumitem_rec  child_enumitem%ROWTYPE;
    begin
    --open child_enumitem;
      for child_enumitem_rec in child_enumitem loop
      enumitem_DELETE (acursession,child_enumitem_rec.id,aInstanceid);
      end loop;
      --close child_enumitem;
    end ;
    declare cursor child_fieldtypemap is select fieldtypemap.fieldtypemapid ID from fieldtypemap where  fieldtypemap.ParentStructRowID = afieldtypeid;
    child_fieldtypemap_rec  child_fieldtypemap%ROWTYPE;
    begin
    --open child_fieldtypemap;
      for child_fieldtypemap_rec in child_fieldtypemap loop
      fieldtypemap_DELETE (acursession,child_fieldtypemap_rec.id,aInstanceid);
      end loop;
      --close child_fieldtypemap;
    end ;
declare cursor chld_fieldtype is select  instanceid ID from instance where OwnerPartName ='fieldtype' and OwnerRowID=afieldtypeid;
row_fieldtype  chld_fieldtype%ROWTYPE;
begin
--open chld_fieldtype;
for row_fieldtype in chld_fieldtype loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldtype.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldtype.id);
end loop;
--close chld_fieldtype;
end ;
  delete from  fieldtype 
  where  fieldtypeID = afieldtypeID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Тип поля*/
procedure fieldtype_SAVE /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 afieldtypeid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atypestyle
 NUMBER/* Трактовка *//* Трактовка */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
,aallowsize
 NUMBER/* Нужен размер *//* Нужен размер */
,aminimum
 VARCHAR2 := null /* Минимум *//* Минимум */
,amaximum
 VARCHAR2 := null /* Максимум *//* Максимум */
,aallowlikesearch
 NUMBER/* Поиск текста *//* Поиск текста */
,agridsorttype
 NUMBER := null /* Вариант сортировки в табличном представлении *//* Вариант сортировки в табличном представлении */
,adelayedsave
 NUMBER/* Отложенное сохранение *//* Отложенное сохранение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldtype where fieldtypeID=afieldtypeID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldtype where fieldtypeid=afieldtypeID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldtype',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldtype');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldtype_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldtypeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldtype');
    return;
  end if;
 -- update row  --
 update  fieldtype set ChangeStamp=sysdate
,
  name=aname
,
  typestyle=atypestyle
,
  the_comment=athe_comment
,
  allowsize=aallowsize
,
  minimum=aminimum
,
  maximum=amaximum
,
  allowlikesearch=aallowlikesearch
,
  gridsorttype=agridsorttype
,
  delayedsave=adelayedsave
  where  fieldtypeID = afieldtypeID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from fieldtype where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=fieldtype');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldtype',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldtype');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldtype');
    return;
  end if;
 insert into   fieldtype
 (  fieldtypeID 
,InstanceID
,name

,typestyle

,the_comment

,allowsize

,minimum

,maximum

,allowlikesearch

,gridsorttype

,delayedsave

 ) values ( afieldtypeID 
,aInstanceID
,aname

,atypestyle

,athe_comment

,aallowsize

,aminimum

,amaximum

,aallowlikesearch

,agridsorttype

,adelayedsave

 ); 
 fieldtype_SINIT( aCURSESSION,afieldtypeid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from fieldtype where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=fieldtype');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure fieldtype_PARENT /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from fieldtype where  fieldtypeid=aRowID;
 end; 

procedure fieldtype_ISLOCKED /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldtype where fieldtypeid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldtype_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldtype_LOCK /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldtype_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldtype_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldtype where fieldtypeid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldtype');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldtype set LockUserID =auserID ,LockSessionID =null where fieldtypeid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldtype set LockUserID =null,LockSessionID =aCURSESSION  where fieldtypeid=aRowID;
     return;
   end if;
 end ;

procedure fieldtype_HCL /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_enumitem is select enumitem.enumitemid ID from enumitem where  enumitem.ParentStructRowID = aRowid;
row_enumitem lch_enumitem%ROWTYPE;
begin  
--open lch_enumitem;
for row_enumitem in lch_enumitem
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from enumitem where enumitemid=row_enumitem.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_enumitem;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_enumitem;
     return;
   end if; 
 end if;  
 enumitem_HCL (acursession,row_enumitem.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_enumitem;
   return;
 end if;
end loop;
--close lch_enumitem;
end;
declare cursor lch_fieldtypemap is select fieldtypemap.fieldtypemapid ID from fieldtypemap where  fieldtypemap.ParentStructRowID = aRowid;
row_fieldtypemap lch_fieldtypemap%ROWTYPE;
begin  
--open lch_fieldtypemap;
for row_fieldtypemap in lch_fieldtypemap
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fieldtypemap where fieldtypemapid=row_fieldtypemap.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldtypemap;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fieldtypemap;
     return;
   end if; 
 end if;  
 fieldtypemap_HCL (acursession,row_fieldtypemap.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldtypemap;
   return;
 end if;
end loop;
--close lch_fieldtypemap;
end;
aIsLocked :=0;
end;

procedure fieldtype_UNLOCK /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldtype_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldtype set LockUserID =null  where fieldtypeid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldtype set LockSessionID =null  where fieldtypeid=aRowID;
     return;
   end if;
 end; 

procedure fieldtype_SINIT /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldtype where fieldtypeid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldtype');
    return;
  end if;
if aSecurityStyleID is null then
 fieldtype_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldtype set securitystyleid =aStyleID where fieldtypeid = aRowID;
else 
 update fieldtype set securitystyleid =aSecurityStyleID where fieldtypeid = aRowID;
end if; 
end ; 

procedure fieldtype_propagate /*Типы полей, перечисления, интервалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldtype where fieldtypeid=aRowid;
declare cursor pch_enumitem  is select enumitem.enumitemid ID from enumitem where  enumitem.ParentStructRowID = aRowid;
row_enumitem  pch_enumitem%ROWTYPE;
begin
--open pch_enumitem;
for row_enumitem in pch_enumitem loop
   enumitem_SINIT( acursession,row_enumitem.id,assid);
   enumitem_propagate( acursession,row_enumitem.id);
end loop;
--close pch_enumitem;
end;
declare cursor pch_fieldtypemap  is select fieldtypemap.fieldtypemapid ID from fieldtypemap where  fieldtypemap.ParentStructRowID = aRowid;
row_fieldtypemap  pch_fieldtypemap%ROWTYPE;
begin
--open pch_fieldtypemap;
for row_fieldtypemap in pch_fieldtypemap loop
   fieldtypemap_SINIT( acursession,row_fieldtypemap.id,assid);
   fieldtypemap_propagate( acursession,row_fieldtypemap.id);
end loop;
--close pch_fieldtypemap;
end;
end;


procedure enumitem_BRIEF  (
 aCURSESSION CHAR,
 aenumitemid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aenumitemid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from enumitem where enumitemID=aenumitemID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from enumitem where enumitemid=aenumitemID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=enumitem');
    return;
  end if;
  aBRIEF:=func.enumitem_BRIEF_F(aenumitemid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure enumitem_DELETE /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aenumitemid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from enumitem where enumitemID=aenumitemID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from enumitem where enumitemid=aenumitemID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:enumitem',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=enumitem');
      return;
    end if;
  end if;
 --  verify lock  --
 enumitem_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aenumitemid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=enumitem');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_enumitem is select  instanceid ID from instance where OwnerPartName ='enumitem' and OwnerRowID=aenumitemid;
row_enumitem  chld_enumitem%ROWTYPE;
begin
--open chld_enumitem;
for row_enumitem in chld_enumitem loop
 Kernel.INSTANCE_OWNER (acursession,row_enumitem.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_enumitem.id);
end loop;
--close chld_enumitem;
end ;
  delete from  enumitem 
  where  enumitemID = aenumitemID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Зачения*/
procedure enumitem_SAVE /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aenumitemid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,anamevalue
 NUMBER/* Значение *//* Значение */
,anameincode
 VARCHAR2 := null /* Название в коде *//* Название в коде */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from enumitem where enumitemID=aenumitemID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from enumitem where enumitemid=aenumitemID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:enumitem',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=enumitem');
      return;
    end if;
  end if;
 --  verify lock  --
 enumitem_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aenumitemid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=enumitem');
    return;
  end if;
 -- update row  --
 update  enumitem set ChangeStamp=sysdate
,
  name=aname
,
  namevalue=anamevalue
,
  nameincode=anameincode
  where  enumitemID = aenumitemID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from enumitem where ParentStructRowID=aParentStructRowID 
 and namevalue=anamevalue;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=enumitem');
 return;
end if;
select Count(*) into aUniqueRowCount from enumitem where ParentStructRowID=aParentStructRowID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=enumitem');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from fieldtype where fieldtypeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:enumitem',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=enumitem');
      return;
    end if;
 end if;
 fieldtype_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=enumitem');
    return;
  end if;
 insert into   enumitem
 (  enumitemID 
,ParentStructRowID
,name

,namevalue

,nameincode

 ) values ( aenumitemID 
,aParentStructRowID
,aname

,anamevalue

,anameincode

 ); 
 enumitem_SINIT( aCURSESSION,aenumitemid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from enumitem where ParentStructRowID=aParentStructRowID 
 and namevalue=anamevalue;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=enumitem');
 return;
end if;
select Count(*) into aUniqueRowCount from enumitem where ParentStructRowID=aParentStructRowID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=enumitem');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure enumitem_PARENT /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from enumitem where  enumitemid=aRowID;
  aParentTable := 'fieldtype';
 end; 

procedure enumitem_ISLOCKED /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from enumitem where enumitemid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  enumitem_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure enumitem_LOCK /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 enumitem_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  enumitem_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from enumitem where enumitemid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=enumitem');
    return;
  end if;
   if  aLockMode =2  
   then   
    update enumitem set LockUserID =auserID ,LockSessionID =null where enumitemid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update enumitem set LockUserID =null,LockSessionID =aCURSESSION  where enumitemid=aRowID;
     return;
   end if;
 end ;

procedure enumitem_HCL /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure enumitem_UNLOCK /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 enumitem_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update enumitem set LockUserID =null  where enumitemid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update enumitem set LockSessionID =null  where enumitemid=aRowID;
     return;
   end if;
 end; 

procedure enumitem_SINIT /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from enumitem where enumitemid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =enumitem');
    return;
  end if;
if aSecurityStyleID is null then
 enumitem_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update enumitem set securitystyleid =aStyleID where enumitemid = aRowID;
else 
 update enumitem set securitystyleid =aSecurityStyleID where enumitemid = aRowID;
end if; 
end ; 

procedure enumitem_propagate /*Для описания Enum типов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from enumitem where enumitemid=aRowid;
end;


procedure fieldtypemap_BRIEF  (
 aCURSESSION CHAR,
 afieldtypemapid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldtypemapid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldtypemap where fieldtypemapID=afieldtypemapID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldtypemap where fieldtypemapid=afieldtypemapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldtypemap');
    return;
  end if;
  aBRIEF:=func.fieldtypemap_BRIEF_F(afieldtypemapid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldtypemap_DELETE /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 afieldtypemapid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldtypemap where fieldtypemapID=afieldtypemapID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldtypemap where fieldtypemapid=afieldtypemapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldtypemap',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldtypemap');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldtypemap_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldtypemapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldtypemap');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fieldtypemap is select  instanceid ID from instance where OwnerPartName ='fieldtypemap' and OwnerRowID=afieldtypemapid;
row_fieldtypemap  chld_fieldtypemap%ROWTYPE;
begin
--open chld_fieldtypemap;
for row_fieldtypemap in chld_fieldtypemap loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldtypemap.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldtypemap.id);
end loop;
--close chld_fieldtypemap;
end ;
  delete from  fieldtypemap 
  where  fieldtypemapID = afieldtypemapID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение*/
procedure fieldtypemap_SAVE /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 afieldtypemapid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,astoagetype
 VARCHAR2/* Тип хранения *//* Тип хранения */
,afixedsize
 NUMBER := null /* Размер *//* Размер */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldtypemap where fieldtypemapID=afieldtypemapID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldtypemap where fieldtypemapid=afieldtypemapID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldtypemap',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldtypemap');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldtypemap_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldtypemapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldtypemap');
    return;
  end if;
 -- update row  --
 update  fieldtypemap set ChangeStamp=sysdate
,
  target=atarget
,
  stoagetype=astoagetype
,
  fixedsize=afixedsize
  where  fieldtypemapID = afieldtypemapID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from fieldtype where fieldtypeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldtypemap',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldtypemap');
      return;
    end if;
 end if;
 fieldtype_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldtypemap');
    return;
  end if;
 insert into   fieldtypemap
 (  fieldtypemapID 
,ParentStructRowID
,target

,stoagetype

,fixedsize

 ) values ( afieldtypemapID 
,aParentStructRowID
,atarget

,astoagetype

,afixedsize

 ); 
 fieldtypemap_SINIT( aCURSESSION,afieldtypemapid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fieldtypemap_PARENT /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fieldtypemap where  fieldtypemapid=aRowID;
  aParentTable := 'fieldtype';
 end; 

procedure fieldtypemap_ISLOCKED /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldtypemap where fieldtypemapid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldtypemap_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldtypemap_LOCK /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldtypemap_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldtypemap_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldtypemap where fieldtypemapid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldtypemap');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldtypemap set LockUserID =auserID ,LockSessionID =null where fieldtypemapid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldtypemap set LockUserID =null,LockSessionID =aCURSESSION  where fieldtypemapid=aRowID;
     return;
   end if;
 end ;

procedure fieldtypemap_HCL /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fieldtypemap_UNLOCK /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldtypemap_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldtypemap set LockUserID =null  where fieldtypemapid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldtypemap set LockSessionID =null  where fieldtypemapid=aRowID;
     return;
   end if;
 end; 

procedure fieldtypemap_SINIT /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldtypemap where fieldtypemapid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldtypemap');
    return;
  end if;
if aSecurityStyleID is null then
 fieldtypemap_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldtypemap set securitystyleid =aStyleID where fieldtypemapid = aRowID;
else 
 update fieldtypemap set securitystyleid =aSecurityStyleID where fieldtypemapid = aRowID;
end if; 
end ; 

procedure fieldtypemap_propagate /*Отображение типа поля на физический тип хранения*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldtypemap where fieldtypemapid=aRowid;
end;


procedure sharedmethod_BRIEF  (
 aCURSESSION CHAR,
 asharedmethodid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if asharedmethodid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from sharedmethod where sharedmethodID=asharedmethodID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from sharedmethod where sharedmethodid=asharedmethodID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=sharedmethod');
    return;
  end if;
  aBRIEF:=func.sharedmethod_BRIEF_F(asharedmethodid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure sharedmethod_DELETE /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 asharedmethodid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from sharedmethod where sharedmethodID=asharedmethodID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from sharedmethod where sharedmethodid=asharedmethodID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:sharedmethod',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=sharedmethod');
      return;
    end if;
  end if;
 --  verify lock  --
 sharedmethod_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;asharedmethodid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=sharedmethod');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_script is select script.scriptid ID from script where  script.ParentStructRowID = asharedmethodid;
    child_script_rec  child_script%ROWTYPE;
    begin
    --open child_script;
      for child_script_rec in child_script loop
      script_DELETE (acursession,child_script_rec.id,aInstanceid);
      end loop;
      --close child_script;
    end ;
declare cursor chld_sharedmethod is select  instanceid ID from instance where OwnerPartName ='sharedmethod' and OwnerRowID=asharedmethodid;
row_sharedmethod  chld_sharedmethod%ROWTYPE;
begin
--open chld_sharedmethod;
for row_sharedmethod in chld_sharedmethod loop
 Kernel.INSTANCE_OWNER (acursession,row_sharedmethod.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_sharedmethod.id);
end loop;
--close chld_sharedmethod;
end ;
  delete from  sharedmethod 
  where  sharedmethodID = asharedmethodID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы и процедуры*/
procedure sharedmethod_SAVE /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 asharedmethodid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_comment VARCHAR2 := null /* Описание метода *//* Описание метода */
,areturntype CHAR := null /* Возвращаемый тип *//* Возвращаемый тип */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from sharedmethod where sharedmethodID=asharedmethodID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from sharedmethod where sharedmethodid=asharedmethodID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:sharedmethod',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=sharedmethod');
      return;
    end if;
  end if;
 --  verify lock  --
 sharedmethod_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;asharedmethodid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=sharedmethod');
    return;
  end if;
 -- update row  --
 update  sharedmethod set ChangeStamp=sysdate
,
  name=aname
,
  the_comment=athe_comment
,
  returntype=areturntype
  where  sharedmethodID = asharedmethodID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from sharedmethod where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=sharedmethod');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:sharedmethod',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=sharedmethod');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=sharedmethod');
    return;
  end if;
 insert into   sharedmethod
 (  sharedmethodID 
,InstanceID
,name

,the_comment

,returntype

 ) values ( asharedmethodID 
,aInstanceID
,aname

,athe_comment

,areturntype

 ); 
 sharedmethod_SINIT( aCURSESSION,asharedmethodid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from sharedmethod where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=sharedmethod');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure sharedmethod_PARENT /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from sharedmethod where  sharedmethodid=aRowID;
 end; 

procedure sharedmethod_ISLOCKED /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from sharedmethod where sharedmethodid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  sharedmethod_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure sharedmethod_LOCK /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 sharedmethod_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  sharedmethod_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from sharedmethod where sharedmethodid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=sharedmethod');
    return;
  end if;
   if  aLockMode =2  
   then   
    update sharedmethod set LockUserID =auserID ,LockSessionID =null where sharedmethodid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update sharedmethod set LockUserID =null,LockSessionID =aCURSESSION  where sharedmethodid=aRowID;
     return;
   end if;
 end ;

procedure sharedmethod_HCL /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_script is select script.scriptid ID from script where  script.ParentStructRowID = aRowid;
row_script lch_script%ROWTYPE;
begin  
--open lch_script;
for row_script in lch_script
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from script where scriptid=row_script.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_script;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_script;
     return;
   end if; 
 end if;  
 script_HCL (acursession,row_script.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_script;
   return;
 end if;
end loop;
--close lch_script;
end;
aIsLocked :=0;
end;

procedure sharedmethod_UNLOCK /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 sharedmethod_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update sharedmethod set LockUserID =null  where sharedmethodid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update sharedmethod set LockSessionID =null  where sharedmethodid=aRowID;
     return;
   end if;
 end; 

procedure sharedmethod_SINIT /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from sharedmethod where sharedmethodid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =sharedmethod');
    return;
  end if;
if aSecurityStyleID is null then
 sharedmethod_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update sharedmethod set securitystyleid =aStyleID where sharedmethodid = aRowID;
else 
 update sharedmethod set securitystyleid =aSecurityStyleID where sharedmethodid = aRowID;
end if; 
end ; 

procedure sharedmethod_propagate /*Методы и процедуры*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from sharedmethod where sharedmethodid=aRowid;
declare cursor pch_script  is select script.scriptid ID from script where  script.ParentStructRowID = aRowid;
row_script  pch_script%ROWTYPE;
begin
--open pch_script;
for row_script in pch_script loop
   script_SINIT( acursession,row_script.id,assid);
   script_propagate( acursession,row_script.id);
end loop;
--close pch_script;
end;
end;


procedure script_BRIEF  (
 aCURSESSION CHAR,
 ascriptid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ascriptid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from script where scriptID=ascriptID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from script where scriptid=ascriptID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=script');
    return;
  end if;
  aBRIEF:=func.script_BRIEF_F(ascriptid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure script_DELETE /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 ascriptid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from script where scriptID=ascriptID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from script where scriptid=ascriptID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:script',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=script');
      return;
    end if;
  end if;
 --  verify lock  --
 script_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ascriptid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=script');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_parameters is select parameters.parametersid ID from parameters where  parameters.ParentStructRowID = ascriptid;
    child_parameters_rec  child_parameters%ROWTYPE;
    begin
    --open child_parameters;
      for child_parameters_rec in child_parameters loop
      parameters_DELETE (acursession,child_parameters_rec.id,aInstanceid);
      end loop;
      --close child_parameters;
    end ;
declare cursor chld_script is select  instanceid ID from instance where OwnerPartName ='script' and OwnerRowID=ascriptid;
row_script  chld_script%ROWTYPE;
begin
--open chld_script;
for row_script in chld_script loop
 Kernel.INSTANCE_OWNER (acursession,row_script.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_script.id);
end loop;
--close chld_script;
end ;
  delete from  script 
  where  scriptID = ascriptID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Реализация*/
procedure script_SAVE /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 ascriptid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Целевая платформа *//* Целевая платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from script where scriptID=ascriptID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from script where scriptid=ascriptID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:script',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=script');
      return;
    end if;
  end if;
 --  verify lock  --
 script_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ascriptid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=script');
    return;
  end if;
 -- update row  --
 update  script set ChangeStamp=sysdate
,
  target=atarget
,
  code=acode
  where  scriptID = ascriptID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from sharedmethod where sharedmethodid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:script',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=script');
      return;
    end if;
 end if;
 sharedmethod_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=script');
    return;
  end if;
 insert into   script
 (  scriptID 
,ParentStructRowID
,target

,code

 ) values ( ascriptID 
,aParentStructRowID
,atarget

,acode

 ); 
 script_SINIT( aCURSESSION,ascriptid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure script_PARENT /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from script where  scriptid=aRowID;
  aParentTable := 'sharedmethod';
 end; 

procedure script_ISLOCKED /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from script where scriptid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  script_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure script_LOCK /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 script_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  script_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from script where scriptid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=script');
    return;
  end if;
   if  aLockMode =2  
   then   
    update script set LockUserID =auserID ,LockSessionID =null where scriptid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update script set LockUserID =null,LockSessionID =aCURSESSION  where scriptid=aRowID;
     return;
   end if;
 end ;

procedure script_HCL /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_parameters is select parameters.parametersid ID from parameters where  parameters.ParentStructRowID = aRowid;
row_parameters lch_parameters%ROWTYPE;
begin  
--open lch_parameters;
for row_parameters in lch_parameters
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from parameters where parametersid=row_parameters.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_parameters;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_parameters;
     return;
   end if; 
 end if;  
 parameters_HCL (acursession,row_parameters.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_parameters;
   return;
 end if;
end loop;
--close lch_parameters;
end;
aIsLocked :=0;
end;

procedure script_UNLOCK /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 script_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update script set LockUserID =null  where scriptid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update script set LockSessionID =null  where scriptid=aRowID;
     return;
   end if;
 end; 

procedure script_SINIT /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from script where scriptid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =script');
    return;
  end if;
if aSecurityStyleID is null then
 script_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update script set securitystyleid =aStyleID where scriptid = aRowID;
else 
 update script set securitystyleid =aSecurityStyleID where scriptid = aRowID;
end if; 
end ; 

procedure script_propagate /*Код метода на понятном конкретному генератору языке*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from script where scriptid=aRowid;
declare cursor pch_parameters  is select parameters.parametersid ID from parameters where  parameters.ParentStructRowID = aRowid;
row_parameters  pch_parameters%ROWTYPE;
begin
--open pch_parameters;
for row_parameters in pch_parameters loop
   parameters_SINIT( acursession,row_parameters.id,assid);
   parameters_propagate( acursession,row_parameters.id);
end loop;
--close pch_parameters;
end;
end;


procedure parameters_BRIEF  (
 aCURSESSION CHAR,
 aparametersid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aparametersid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from parameters where parametersID=aparametersID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from parameters where parametersid=aparametersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=parameters');
    return;
  end if;
  aBRIEF:=func.parameters_BRIEF_F(aparametersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure parameters_DELETE /*Параметры метода*/ (
 aCURSESSION CHAR,
 aparametersid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from parameters where parametersID=aparametersID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from parameters where parametersid=aparametersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:parameters',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=parameters');
      return;
    end if;
  end if;
 --  verify lock  --
 parameters_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aparametersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=parameters');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_parameters is select  instanceid ID from instance where OwnerPartName ='parameters' and OwnerRowID=aparametersid;
row_parameters  chld_parameters%ROWTYPE;
begin
--open chld_parameters;
for row_parameters in chld_parameters loop
 Kernel.INSTANCE_OWNER (acursession,row_parameters.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_parameters.id);
end loop;
--close chld_parameters;
end ;
  delete from  parameters 
  where  parametersID = aparametersID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Параметры*/
procedure parameters_SAVE /*Параметры метода*/ (
 aCURSESSION CHAR,
 aparametersid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Имя *//* Имя */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,atypeofparm CHAR/* Тип данных *//* Тип данных */
,adatasize
 NUMBER := null /* Размер *//* Размер */
,aallownull
 NUMBER/* Можно не задавать *//* Можно не задавать */
,aoutparam
 NUMBER/* Возвращает значение *//* Возвращает значение */
,areferencetype
 NUMBER/* Тип ссылки *//* Тип ссылки */
,areftotype CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,areftopart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from parameters where parametersID=aparametersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from parameters where parametersid=aparametersID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:parameters',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=parameters');
      return;
    end if;
  end if;
 --  verify lock  --
 parameters_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aparametersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=parameters');
    return;
  end if;
 -- update row  --
 update  parameters set ChangeStamp=sysdate
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  typeofparm=atypeofparm
,
  datasize=adatasize
,
  allownull=aallownull
,
  outparam=aoutparam
,
  referencetype=areferencetype
,
  reftotype=areftotype
,
  reftopart=areftopart
  where  parametersID = aparametersID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from parameters where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=parameters');
 return;
end if;
select Count(*) into aUniqueRowCount from parameters where ParentStructRowID=aParentStructRowID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=parameters');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from script where scriptid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:parameters',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=parameters');
      return;
    end if;
 end if;
 script_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=parameters');
    return;
  end if;
 insert into   parameters
 (  parametersID 
,ParentStructRowID
,sequence

,name

,caption

,typeofparm

,datasize

,allownull

,outparam

,referencetype

,reftotype

,reftopart

 ) values ( aparametersID 
,aParentStructRowID
,asequence

,aname

,acaption

,atypeofparm

,adatasize

,aallownull

,aoutparam

,areferencetype

,areftotype

,areftopart

 ); 
 parameters_SINIT( aCURSESSION,aparametersid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from parameters where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=parameters');
 return;
end if;
select Count(*) into aUniqueRowCount from parameters where ParentStructRowID=aParentStructRowID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=parameters');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure parameters_PARENT /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from parameters where  parametersid=aRowID;
  aParentTable := 'script';
 end; 

procedure parameters_ISLOCKED /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from parameters where parametersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  parameters_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure parameters_LOCK /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 parameters_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  parameters_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from parameters where parametersid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=parameters');
    return;
  end if;
   if  aLockMode =2  
   then   
    update parameters set LockUserID =auserID ,LockSessionID =null where parametersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update parameters set LockUserID =null,LockSessionID =aCURSESSION  where parametersid=aRowID;
     return;
   end if;
 end ;

procedure parameters_HCL /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure parameters_UNLOCK /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 parameters_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update parameters set LockUserID =null  where parametersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update parameters set LockSessionID =null  where parametersid=aRowID;
     return;
   end if;
 end; 

procedure parameters_SINIT /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from parameters where parametersid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =parameters');
    return;
  end if;
if aSecurityStyleID is null then
 parameters_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update parameters set securitystyleid =aStyleID where parametersid = aRowID;
else 
 update parameters set securitystyleid =aSecurityStyleID where parametersid = aRowID;
end if; 
end ; 

procedure parameters_propagate /*Параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from parameters where parametersid=aRowid;
end;


procedure objecttype_BRIEF  (
 aCURSESSION CHAR,
 aobjecttypeid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aobjecttypeid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from objecttype where objecttypeID=aobjecttypeID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from objecttype where objecttypeid=aobjecttypeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=objecttype');
    return;
  end if;
  aBRIEF:=func.objecttype_BRIEF_F(aobjecttypeid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure objecttype_DELETE /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aobjecttypeid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from objecttype where objecttypeID=aobjecttypeID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from objecttype where objecttypeid=aobjecttypeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:objecttype',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=objecttype');
      return;
    end if;
  end if;
 --  verify lock  --
 objecttype_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aobjecttypeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=objecttype');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_objstatus is select objstatus.objstatusid ID from objstatus where  objstatus.ParentStructRowID = aobjecttypeid;
    child_objstatus_rec  child_objstatus%ROWTYPE;
    begin
    --open child_objstatus;
      for child_objstatus_rec in child_objstatus loop
      objstatus_DELETE (acursession,child_objstatus_rec.id,aInstanceid);
      end loop;
      --close child_objstatus;
    end ;
    declare cursor child_objectmode is select objectmode.objectmodeid ID from objectmode where  objectmode.ParentStructRowID = aobjecttypeid;
    child_objectmode_rec  child_objectmode%ROWTYPE;
    begin
    --open child_objectmode;
      for child_objectmode_rec in child_objectmode loop
      objectmode_DELETE (acursession,child_objectmode_rec.id,aInstanceid);
      end loop;
      --close child_objectmode;
    end ;
    declare cursor child_typemenu is select typemenu.typemenuid ID from typemenu where  typemenu.ParentStructRowID = aobjecttypeid;
    child_typemenu_rec  child_typemenu%ROWTYPE;
    begin
    --open child_typemenu;
      for child_typemenu_rec in child_typemenu loop
      typemenu_DELETE (acursession,child_typemenu_rec.id,aInstanceid);
      end loop;
      --close child_typemenu;
    end ;
    declare cursor child_instancevalidator is select instancevalidator.instancevalidatorid ID from instancevalidator where  instancevalidator.ParentStructRowID = aobjecttypeid;
    child_instancevalidator_rec  child_instancevalidator%ROWTYPE;
    begin
    --open child_instancevalidator;
      for child_instancevalidator_rec in child_instancevalidator loop
      instancevalidator_DELETE (acursession,child_instancevalidator_rec.id,aInstanceid);
      end loop;
      --close child_instancevalidator;
    end ;
    declare cursor child_part is select part.partid ID from part where  part.ParentStructRowID = aobjecttypeid;
    child_part_rec  child_part%ROWTYPE;
    begin
    --open child_part;
      for child_part_rec in child_part loop
      part_DELETE (acursession,child_part_rec.id,aInstanceid);
      end loop;
      --close child_part;
    end ;
declare cursor chld_objecttype is select  instanceid ID from instance where OwnerPartName ='objecttype' and OwnerRowID=aobjecttypeid;
row_objecttype  chld_objecttype%ROWTYPE;
begin
--open chld_objecttype;
for row_objecttype in chld_objecttype loop
 Kernel.INSTANCE_OWNER (acursession,row_objecttype.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_objecttype.id);
end loop;
--close chld_objecttype;
end ;
  delete from  objecttype 
  where  objecttypeID = aobjecttypeID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Тип объекта*/
procedure objecttype_SAVE /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aobjecttypeid CHAR,
aInstanceID CHAR 
,apackage CHAR/* Приложение *//* Приложение */
,athe_comment
 VARCHAR2/* Название *//* Название */
,aname
 VARCHAR2/* Код *//* Код */
,aissingleinstance
 NUMBER/* Допускается только один объект *//* Допускается только один объект */
,achooseview CHAR := null /* Представление для выбора *//* Представление для выбора */
,aonrun CHAR := null /* При запуске *//* При запуске */
,aoncreate CHAR := null /* При создании *//* При создании */
,aondelete CHAR := null /* При удалении *//* При удалении */
,aallowreftoobject
 NUMBER/* Отображать при выборе ссылки *//* Отображать при выборе ссылки */
,aallowsearch
 NUMBER/* Отображать при поиске *//* Отображать при поиске */
,areplicatype
 NUMBER := null /* Тип репликации *//* Тип репликации */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,auseownership
 NUMBER/* Видмость зависит от пользователя *//* Видмость зависит от пользователя */
,ausearchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,acommitfullobject
 NUMBER/* Сохранять объект целиком *//* Сохранять объект целиком */
,aobjiconcls
 VARCHAR2 := null /* Иконка объекта *//* Иконка объекта */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from objecttype where objecttypeID=aobjecttypeID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from objecttype where objecttypeid=aobjecttypeID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:objecttype',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=objecttype');
      return;
    end if;
  end if;
 --  verify lock  --
 objecttype_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aobjecttypeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=objecttype');
    return;
  end if;
 -- update row  --
 update  objecttype set ChangeStamp=sysdate
,
  package=apackage
,
  the_comment=athe_comment
,
  name=aname
,
  issingleinstance=aissingleinstance
,
  chooseview=achooseview
,
  onrun=aonrun
,
  oncreate=aoncreate
,
  ondelete=aondelete
,
  allowreftoobject=aallowreftoobject
,
  allowsearch=aallowsearch
,
  replicatype=areplicatype
,
  thecomment=athecomment
,
  useownership=auseownership
,
  usearchiving=ausearchiving
,
  commitfullobject=acommitfullobject
,
  objiconcls=aobjiconcls
  where  objecttypeID = aobjecttypeID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from objecttype where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=objecttype');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:objecttype',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=objecttype');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=objecttype');
    return;
  end if;
 insert into   objecttype
 (  objecttypeID 
,InstanceID
,package

,the_comment

,name

,issingleinstance

,chooseview

,onrun

,oncreate

,ondelete

,allowreftoobject

,allowsearch

,replicatype

,thecomment

,useownership

,usearchiving

,commitfullobject

,objiconcls

 ) values ( aobjecttypeID 
,aInstanceID
,apackage

,athe_comment

,aname

,aissingleinstance

,achooseview

,aonrun

,aoncreate

,aondelete

,aallowreftoobject

,aallowsearch

,areplicatype

,athecomment

,auseownership

,ausearchiving

,acommitfullobject

,aobjiconcls

 ); 
 objecttype_SINIT( aCURSESSION,aobjecttypeid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from objecttype where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=objecttype');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure objecttype_PARENT /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from objecttype where  objecttypeid=aRowID;
 end; 

procedure objecttype_ISLOCKED /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from objecttype where objecttypeid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  objecttype_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure objecttype_LOCK /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 objecttype_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  objecttype_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from objecttype where objecttypeid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=objecttype');
    return;
  end if;
   if  aLockMode =2  
   then   
    update objecttype set LockUserID =auserID ,LockSessionID =null where objecttypeid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update objecttype set LockUserID =null,LockSessionID =aCURSESSION  where objecttypeid=aRowID;
     return;
   end if;
 end ;

procedure objecttype_HCL /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_objstatus is select objstatus.objstatusid ID from objstatus where  objstatus.ParentStructRowID = aRowid;
row_objstatus lch_objstatus%ROWTYPE;
begin  
--open lch_objstatus;
for row_objstatus in lch_objstatus
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from objstatus where objstatusid=row_objstatus.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_objstatus;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_objstatus;
     return;
   end if; 
 end if;  
 objstatus_HCL (acursession,row_objstatus.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_objstatus;
   return;
 end if;
end loop;
--close lch_objstatus;
end;
declare cursor lch_objectmode is select objectmode.objectmodeid ID from objectmode where  objectmode.ParentStructRowID = aRowid;
row_objectmode lch_objectmode%ROWTYPE;
begin  
--open lch_objectmode;
for row_objectmode in lch_objectmode
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from objectmode where objectmodeid=row_objectmode.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_objectmode;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_objectmode;
     return;
   end if; 
 end if;  
 objectmode_HCL (acursession,row_objectmode.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_objectmode;
   return;
 end if;
end loop;
--close lch_objectmode;
end;
declare cursor lch_typemenu is select typemenu.typemenuid ID from typemenu where  typemenu.ParentStructRowID = aRowid;
row_typemenu lch_typemenu%ROWTYPE;
begin  
--open lch_typemenu;
for row_typemenu in lch_typemenu
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from typemenu where typemenuid=row_typemenu.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_typemenu;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_typemenu;
     return;
   end if; 
 end if;  
 typemenu_HCL (acursession,row_typemenu.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_typemenu;
   return;
 end if;
end loop;
--close lch_typemenu;
end;
declare cursor lch_instancevalidator is select instancevalidator.instancevalidatorid ID from instancevalidator where  instancevalidator.ParentStructRowID = aRowid;
row_instancevalidator lch_instancevalidator%ROWTYPE;
begin  
--open lch_instancevalidator;
for row_instancevalidator in lch_instancevalidator
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from instancevalidator where instancevalidatorid=row_instancevalidator.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_instancevalidator;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_instancevalidator;
     return;
   end if; 
 end if;  
 instancevalidator_HCL (acursession,row_instancevalidator.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_instancevalidator;
   return;
 end if;
end loop;
--close lch_instancevalidator;
end;
declare cursor lch_part is select part.partid ID from part where  part.ParentStructRowID = aRowid;
row_part lch_part%ROWTYPE;
begin  
--open lch_part;
for row_part in lch_part
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from part where partid=row_part.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_part;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_part;
     return;
   end if; 
 end if;  
 part_HCL (acursession,row_part.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_part;
   return;
 end if;
end loop;
--close lch_part;
end;
aIsLocked :=0;
end;

procedure objecttype_UNLOCK /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 objecttype_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update objecttype set LockUserID =null  where objecttypeid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update objecttype set LockSessionID =null  where objecttypeid=aRowID;
     return;
   end if;
 end; 

procedure objecttype_SINIT /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from objecttype where objecttypeid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =objecttype');
    return;
  end if;
if aSecurityStyleID is null then
 objecttype_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update objecttype set securitystyleid =aStyleID where objecttypeid = aRowID;
else 
 update objecttype set securitystyleid =aSecurityStyleID where objecttypeid = aRowID;
end if; 
end ; 

procedure objecttype_propagate /*Тип объекта (карточки)*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from objecttype where objecttypeid=aRowid;
declare cursor pch_objstatus  is select objstatus.objstatusid ID from objstatus where  objstatus.ParentStructRowID = aRowid;
row_objstatus  pch_objstatus%ROWTYPE;
begin
--open pch_objstatus;
for row_objstatus in pch_objstatus loop
   objstatus_SINIT( acursession,row_objstatus.id,assid);
   objstatus_propagate( acursession,row_objstatus.id);
end loop;
--close pch_objstatus;
end;
declare cursor pch_objectmode  is select objectmode.objectmodeid ID from objectmode where  objectmode.ParentStructRowID = aRowid;
row_objectmode  pch_objectmode%ROWTYPE;
begin
--open pch_objectmode;
for row_objectmode in pch_objectmode loop
   objectmode_SINIT( acursession,row_objectmode.id,assid);
   objectmode_propagate( acursession,row_objectmode.id);
end loop;
--close pch_objectmode;
end;
declare cursor pch_typemenu  is select typemenu.typemenuid ID from typemenu where  typemenu.ParentStructRowID = aRowid;
row_typemenu  pch_typemenu%ROWTYPE;
begin
--open pch_typemenu;
for row_typemenu in pch_typemenu loop
   typemenu_SINIT( acursession,row_typemenu.id,assid);
   typemenu_propagate( acursession,row_typemenu.id);
end loop;
--close pch_typemenu;
end;
declare cursor pch_instancevalidator  is select instancevalidator.instancevalidatorid ID from instancevalidator where  instancevalidator.ParentStructRowID = aRowid;
row_instancevalidator  pch_instancevalidator%ROWTYPE;
begin
--open pch_instancevalidator;
for row_instancevalidator in pch_instancevalidator loop
   instancevalidator_SINIT( acursession,row_instancevalidator.id,assid);
   instancevalidator_propagate( acursession,row_instancevalidator.id);
end loop;
--close pch_instancevalidator;
end;
declare cursor pch_part  is select part.partid ID from part where  part.ParentStructRowID = aRowid;
row_part  pch_part%ROWTYPE;
begin
--open pch_part;
for row_part in pch_part loop
   part_SINIT( acursession,row_part.id,assid);
   part_propagate( acursession,row_part.id);
end loop;
--close pch_part;
end;
end;


procedure objstatus_BRIEF  (
 aCURSESSION CHAR,
 aobjstatusid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aobjstatusid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from objstatus where objstatusID=aobjstatusID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from objstatus where objstatusid=aobjstatusID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=objstatus');
    return;
  end if;
  aBRIEF:=func.objstatus_BRIEF_F(aobjstatusid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure objstatus_DELETE /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aobjstatusid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from objstatus where objstatusID=aobjstatusID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from objstatus where objstatusid=aobjstatusID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:objstatus',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=objstatus');
      return;
    end if;
  end if;
 --  verify lock  --
 objstatus_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aobjstatusid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=objstatus');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_nextstate is select nextstate.nextstateid ID from nextstate where  nextstate.ParentStructRowID = aobjstatusid;
    child_nextstate_rec  child_nextstate%ROWTYPE;
    begin
    --open child_nextstate;
      for child_nextstate_rec in child_nextstate loop
      nextstate_DELETE (acursession,child_nextstate_rec.id,aInstanceid);
      end loop;
      --close child_nextstate;
    end ;
declare cursor chld_objstatus is select  instanceid ID from instance where OwnerPartName ='objstatus' and OwnerRowID=aobjstatusid;
row_objstatus  chld_objstatus%ROWTYPE;
begin
--open chld_objstatus;
for row_objstatus in chld_objstatus loop
 Kernel.INSTANCE_OWNER (acursession,row_objstatus.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_objstatus.id);
end loop;
--close chld_objstatus;
end ;
  delete from  objstatus 
  where  objstatusID = aobjstatusID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Состояния*/
procedure objstatus_SAVE /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aobjstatusid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aisstartup
 NUMBER/* Начальное *//* Начальное */
,aisarchive
 NUMBER/* Архивное *//* Архивное */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from objstatus where objstatusID=aobjstatusID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from objstatus where objstatusid=aobjstatusID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:objstatus',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=objstatus');
      return;
    end if;
  end if;
 --  verify lock  --
 objstatus_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aobjstatusid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=objstatus');
    return;
  end if;
 -- update row  --
 update  objstatus set ChangeStamp=sysdate
,
  name=aname
,
  isstartup=aisstartup
,
  isarchive=aisarchive
,
  the_comment=athe_comment
  where  objstatusID = aobjstatusID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objecttype where objecttypeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:objstatus',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=objstatus');
      return;
    end if;
 end if;
 objecttype_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=objstatus');
    return;
  end if;
 insert into   objstatus
 (  objstatusID 
,ParentStructRowID
,name

,isstartup

,isarchive

,the_comment

 ) values ( aobjstatusID 
,aParentStructRowID
,aname

,aisstartup

,aisarchive

,athe_comment

 ); 
 objstatus_SINIT( aCURSESSION,aobjstatusid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure objstatus_PARENT /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from objstatus where  objstatusid=aRowID;
  aParentTable := 'objecttype';
 end; 

procedure objstatus_ISLOCKED /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from objstatus where objstatusid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  objstatus_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure objstatus_LOCK /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 objstatus_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  objstatus_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from objstatus where objstatusid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=objstatus');
    return;
  end if;
   if  aLockMode =2  
   then   
    update objstatus set LockUserID =auserID ,LockSessionID =null where objstatusid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update objstatus set LockUserID =null,LockSessionID =aCURSESSION  where objstatusid=aRowID;
     return;
   end if;
 end ;

procedure objstatus_HCL /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_nextstate is select nextstate.nextstateid ID from nextstate where  nextstate.ParentStructRowID = aRowid;
row_nextstate lch_nextstate%ROWTYPE;
begin  
--open lch_nextstate;
for row_nextstate in lch_nextstate
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from nextstate where nextstateid=row_nextstate.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_nextstate;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_nextstate;
     return;
   end if; 
 end if;  
 nextstate_HCL (acursession,row_nextstate.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_nextstate;
   return;
 end if;
end loop;
--close lch_nextstate;
end;
aIsLocked :=0;
end;

procedure objstatus_UNLOCK /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 objstatus_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update objstatus set LockUserID =null  where objstatusid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update objstatus set LockSessionID =null  where objstatusid=aRowID;
     return;
   end if;
 end; 

procedure objstatus_SINIT /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from objstatus where objstatusid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =objstatus');
    return;
  end if;
if aSecurityStyleID is null then
 objstatus_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update objstatus set securitystyleid =aStyleID where objstatusid = aRowID;
else 
 update objstatus set securitystyleid =aSecurityStyleID where objstatusid = aRowID;
end if; 
end ; 

procedure objstatus_propagate /*Возможные логические состояния документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from objstatus where objstatusid=aRowid;
declare cursor pch_nextstate  is select nextstate.nextstateid ID from nextstate where  nextstate.ParentStructRowID = aRowid;
row_nextstate  pch_nextstate%ROWTYPE;
begin
--open pch_nextstate;
for row_nextstate in pch_nextstate loop
   nextstate_SINIT( acursession,row_nextstate.id,assid);
   nextstate_propagate( acursession,row_nextstate.id);
end loop;
--close pch_nextstate;
end;
end;


procedure nextstate_BRIEF  (
 aCURSESSION CHAR,
 anextstateid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if anextstateid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from nextstate where nextstateID=anextstateID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from nextstate where nextstateid=anextstateID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=nextstate');
    return;
  end if;
  aBRIEF:=func.nextstate_BRIEF_F(anextstateid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure nextstate_DELETE /*Матрица переходов */ (
 aCURSESSION CHAR,
 anextstateid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from nextstate where nextstateID=anextstateID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from nextstate where nextstateid=anextstateID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:nextstate',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=nextstate');
      return;
    end if;
  end if;
 --  verify lock  --
 nextstate_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anextstateid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=nextstate');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_nextstate is select  instanceid ID from instance where OwnerPartName ='nextstate' and OwnerRowID=anextstateid;
row_nextstate  chld_nextstate%ROWTYPE;
begin
--open chld_nextstate;
for row_nextstate in chld_nextstate loop
 Kernel.INSTANCE_OWNER (acursession,row_nextstate.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_nextstate.id);
end loop;
--close chld_nextstate;
end ;
  delete from  nextstate 
  where  nextstateID = anextstateID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Разрешенные переходы*/
procedure nextstate_SAVE /*Матрица переходов */ (
 aCURSESSION CHAR,
 anextstateid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athestate CHAR/* Разрешенное состояние *//* Разрешенное состояние */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from nextstate where nextstateID=anextstateID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from nextstate where nextstateid=anextstateID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:nextstate',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=nextstate');
      return;
    end if;
  end if;
 --  verify lock  --
 nextstate_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anextstateid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=nextstate');
    return;
  end if;
 -- update row  --
 update  nextstate set ChangeStamp=sysdate
,
  thestate=athestate
  where  nextstateID = anextstateID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objstatus where objstatusid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:nextstate',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=nextstate');
      return;
    end if;
 end if;
 objstatus_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=nextstate');
    return;
  end if;
 insert into   nextstate
 (  nextstateID 
,ParentStructRowID
,thestate

 ) values ( anextstateID 
,aParentStructRowID
,athestate

 ); 
 nextstate_SINIT( aCURSESSION,anextstateid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure nextstate_PARENT /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from nextstate where  nextstateid=aRowID;
  aParentTable := 'objstatus';
 end; 

procedure nextstate_ISLOCKED /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from nextstate where nextstateid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  nextstate_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure nextstate_LOCK /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 nextstate_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  nextstate_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from nextstate where nextstateid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=nextstate');
    return;
  end if;
   if  aLockMode =2  
   then   
    update nextstate set LockUserID =auserID ,LockSessionID =null where nextstateid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update nextstate set LockUserID =null,LockSessionID =aCURSESSION  where nextstateid=aRowID;
     return;
   end if;
 end ;

procedure nextstate_HCL /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure nextstate_UNLOCK /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 nextstate_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update nextstate set LockUserID =null  where nextstateid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update nextstate set LockSessionID =null  where nextstateid=aRowID;
     return;
   end if;
 end; 

procedure nextstate_SINIT /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from nextstate where nextstateid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =nextstate');
    return;
  end if;
if aSecurityStyleID is null then
 nextstate_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update nextstate set securitystyleid =aStyleID where nextstateid = aRowID;
else 
 update nextstate set securitystyleid =aSecurityStyleID where nextstateid = aRowID;
end if; 
end ; 

procedure nextstate_propagate /*Матрица переходов */ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from nextstate where nextstateid=aRowid;
end;


procedure objectmode_BRIEF  (
 aCURSESSION CHAR,
 aobjectmodeid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aobjectmodeid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from objectmode where objectmodeID=aobjectmodeID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from objectmode where objectmodeid=aobjectmodeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=objectmode');
    return;
  end if;
  aBRIEF:=func.objectmode_BRIEF_F(aobjectmodeid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure objectmode_DELETE /*Режим работы*/ (
 aCURSESSION CHAR,
 aobjectmodeid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from objectmode where objectmodeID=aobjectmodeID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from objectmode where objectmodeid=aobjectmodeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:objectmode',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=objectmode');
      return;
    end if;
  end if;
 --  verify lock  --
 objectmode_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aobjectmodeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=objectmode');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_structrestriction is select structrestriction.structrestrictionid ID from structrestriction where  structrestriction.ParentStructRowID = aobjectmodeid;
    child_structrestriction_rec  child_structrestriction%ROWTYPE;
    begin
    --open child_structrestriction;
      for child_structrestriction_rec in child_structrestriction loop
      structrestriction_DELETE (acursession,child_structrestriction_rec.id,aInstanceid);
      end loop;
      --close child_structrestriction;
    end ;
    declare cursor child_methodrestriction is select methodrestriction.methodrestrictionid ID from methodrestriction where  methodrestriction.ParentStructRowID = aobjectmodeid;
    child_methodrestriction_rec  child_methodrestriction%ROWTYPE;
    begin
    --open child_methodrestriction;
      for child_methodrestriction_rec in child_methodrestriction loop
      methodrestriction_DELETE (acursession,child_methodrestriction_rec.id,aInstanceid);
      end loop;
      --close child_methodrestriction;
    end ;
    declare cursor child_fieldrestriction is select fieldrestriction.fieldrestrictionid ID from fieldrestriction where  fieldrestriction.ParentStructRowID = aobjectmodeid;
    child_fieldrestriction_rec  child_fieldrestriction%ROWTYPE;
    begin
    --open child_fieldrestriction;
      for child_fieldrestriction_rec in child_fieldrestriction loop
      fieldrestriction_DELETE (acursession,child_fieldrestriction_rec.id,aInstanceid);
      end loop;
      --close child_fieldrestriction;
    end ;
declare cursor chld_objectmode is select  instanceid ID from instance where OwnerPartName ='objectmode' and OwnerRowID=aobjectmodeid;
row_objectmode  chld_objectmode%ROWTYPE;
begin
--open chld_objectmode;
for row_objectmode in chld_objectmode loop
 Kernel.INSTANCE_OWNER (acursession,row_objectmode.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_objectmode.id);
end loop;
--close chld_objectmode;
end ;
  delete from  objectmode 
  where  objectmodeID = aobjectmodeID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Режим работы*/
procedure objectmode_SAVE /*Режим работы*/ (
 aCURSESSION CHAR,
 aobjectmodeid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название режима *//* Название режима */
,adefaultmode
 NUMBER/* Этот режим является основным режимом работы объекта *//* Этот режим является основным режимом работы объекта */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from objectmode where objectmodeID=aobjectmodeID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from objectmode where objectmodeid=aobjectmodeID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:objectmode',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=objectmode');
      return;
    end if;
  end if;
 --  verify lock  --
 objectmode_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aobjectmodeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=objectmode');
    return;
  end if;
 -- update row  --
 update  objectmode set ChangeStamp=sysdate
,
  name=aname
,
  defaultmode=adefaultmode
,
  thecomment=athecomment
  where  objectmodeID = aobjectmodeID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objecttype where objecttypeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:objectmode',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=objectmode');
      return;
    end if;
 end if;
 objecttype_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=objectmode');
    return;
  end if;
 insert into   objectmode
 (  objectmodeID 
,ParentStructRowID
,name

,defaultmode

,thecomment

 ) values ( aobjectmodeID 
,aParentStructRowID
,aname

,adefaultmode

,athecomment

 ); 
 objectmode_SINIT( aCURSESSION,aobjectmodeid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure objectmode_PARENT /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from objectmode where  objectmodeid=aRowID;
  aParentTable := 'objecttype';
 end; 

procedure objectmode_ISLOCKED /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from objectmode where objectmodeid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  objectmode_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure objectmode_LOCK /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 objectmode_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  objectmode_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from objectmode where objectmodeid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=objectmode');
    return;
  end if;
   if  aLockMode =2  
   then   
    update objectmode set LockUserID =auserID ,LockSessionID =null where objectmodeid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update objectmode set LockUserID =null,LockSessionID =aCURSESSION  where objectmodeid=aRowID;
     return;
   end if;
 end ;

procedure objectmode_HCL /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_structrestriction is select structrestriction.structrestrictionid ID from structrestriction where  structrestriction.ParentStructRowID = aRowid;
row_structrestriction lch_structrestriction%ROWTYPE;
begin  
--open lch_structrestriction;
for row_structrestriction in lch_structrestriction
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from structrestriction where structrestrictionid=row_structrestriction.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_structrestriction;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_structrestriction;
     return;
   end if; 
 end if;  
 structrestriction_HCL (acursession,row_structrestriction.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_structrestriction;
   return;
 end if;
end loop;
--close lch_structrestriction;
end;
declare cursor lch_methodrestriction is select methodrestriction.methodrestrictionid ID from methodrestriction where  methodrestriction.ParentStructRowID = aRowid;
row_methodrestriction lch_methodrestriction%ROWTYPE;
begin  
--open lch_methodrestriction;
for row_methodrestriction in lch_methodrestriction
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from methodrestriction where methodrestrictionid=row_methodrestriction.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_methodrestriction;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_methodrestriction;
     return;
   end if; 
 end if;  
 methodrestriction_HCL (acursession,row_methodrestriction.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_methodrestriction;
   return;
 end if;
end loop;
--close lch_methodrestriction;
end;
declare cursor lch_fieldrestriction is select fieldrestriction.fieldrestrictionid ID from fieldrestriction where  fieldrestriction.ParentStructRowID = aRowid;
row_fieldrestriction lch_fieldrestriction%ROWTYPE;
begin  
--open lch_fieldrestriction;
for row_fieldrestriction in lch_fieldrestriction
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fieldrestriction where fieldrestrictionid=row_fieldrestriction.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldrestriction;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fieldrestriction;
     return;
   end if; 
 end if;  
 fieldrestriction_HCL (acursession,row_fieldrestriction.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldrestriction;
   return;
 end if;
end loop;
--close lch_fieldrestriction;
end;
aIsLocked :=0;
end;

procedure objectmode_UNLOCK /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 objectmode_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update objectmode set LockUserID =null  where objectmodeid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update objectmode set LockSessionID =null  where objectmodeid=aRowID;
     return;
   end if;
 end; 

procedure objectmode_SINIT /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from objectmode where objectmodeid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =objectmode');
    return;
  end if;
if aSecurityStyleID is null then
 objectmode_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update objectmode set securitystyleid =aStyleID where objectmodeid = aRowID;
else 
 update objectmode set securitystyleid =aSecurityStyleID where objectmodeid = aRowID;
end if; 
end ; 

procedure objectmode_propagate /*Режим работы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from objectmode where objectmodeid=aRowid;
declare cursor pch_structrestriction  is select structrestriction.structrestrictionid ID from structrestriction where  structrestriction.ParentStructRowID = aRowid;
row_structrestriction  pch_structrestriction%ROWTYPE;
begin
--open pch_structrestriction;
for row_structrestriction in pch_structrestriction loop
   structrestriction_SINIT( acursession,row_structrestriction.id,assid);
   structrestriction_propagate( acursession,row_structrestriction.id);
end loop;
--close pch_structrestriction;
end;
declare cursor pch_methodrestriction  is select methodrestriction.methodrestrictionid ID from methodrestriction where  methodrestriction.ParentStructRowID = aRowid;
row_methodrestriction  pch_methodrestriction%ROWTYPE;
begin
--open pch_methodrestriction;
for row_methodrestriction in pch_methodrestriction loop
   methodrestriction_SINIT( acursession,row_methodrestriction.id,assid);
   methodrestriction_propagate( acursession,row_methodrestriction.id);
end loop;
--close pch_methodrestriction;
end;
declare cursor pch_fieldrestriction  is select fieldrestriction.fieldrestrictionid ID from fieldrestriction where  fieldrestriction.ParentStructRowID = aRowid;
row_fieldrestriction  pch_fieldrestriction%ROWTYPE;
begin
--open pch_fieldrestriction;
for row_fieldrestriction in pch_fieldrestriction loop
   fieldrestriction_SINIT( acursession,row_fieldrestriction.id,assid);
   fieldrestriction_propagate( acursession,row_fieldrestriction.id);
end loop;
--close pch_fieldrestriction;
end;
end;


procedure structrestriction_BRIEF  (
 aCURSESSION CHAR,
 astructrestrictionid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if astructrestrictionid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from structrestriction where structrestrictionID=astructrestrictionID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from structrestriction where structrestrictionid=astructrestrictionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=structrestriction');
    return;
  end if;
  aBRIEF:=func.structrestriction_BRIEF_F(astructrestrictionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure structrestriction_DELETE /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 astructrestrictionid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from structrestriction where structrestrictionID=astructrestrictionID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from structrestriction where structrestrictionid=astructrestrictionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:structrestriction',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=structrestriction');
      return;
    end if;
  end if;
 --  verify lock  --
 structrestriction_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;astructrestrictionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=structrestriction');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_structrestriction is select  instanceid ID from instance where OwnerPartName ='structrestriction' and OwnerRowID=astructrestrictionid;
row_structrestriction  chld_structrestriction%ROWTYPE;
begin
--open chld_structrestriction;
for row_structrestriction in chld_structrestriction loop
 Kernel.INSTANCE_OWNER (acursession,row_structrestriction.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_structrestriction.id);
end loop;
--close chld_structrestriction;
end ;
  delete from  structrestriction 
  where  structrestrictionID = astructrestrictionID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Органичения разделов*/
procedure structrestriction_SAVE /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 astructrestrictionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,astruct CHAR/* структура, доступ к которой ограничен *//* структура, доступ к которой ограничен */
,aallowread
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aallowadd
 NUMBER/* Разрешено добавлять *//* Разрешено добавлять */
,aallowedit
 NUMBER/* Разрешено изменять *//* Разрешено изменять */
,aallowdelete
 NUMBER/* Разрешено удалять *//* Разрешено удалять */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from structrestriction where structrestrictionID=astructrestrictionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from structrestriction where structrestrictionid=astructrestrictionID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:structrestriction',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=structrestriction');
      return;
    end if;
  end if;
 --  verify lock  --
 structrestriction_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;astructrestrictionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=structrestriction');
    return;
  end if;
 -- update row  --
 update  structrestriction set ChangeStamp=sysdate
,
  struct=astruct
,
  allowread=aallowread
,
  allowadd=aallowadd
,
  allowedit=aallowedit
,
  allowdelete=aallowdelete
  where  structrestrictionID = astructrestrictionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objectmode where objectmodeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:structrestriction',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=structrestriction');
      return;
    end if;
 end if;
 objectmode_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=structrestriction');
    return;
  end if;
 insert into   structrestriction
 (  structrestrictionID 
,ParentStructRowID
,struct

,allowread

,allowadd

,allowedit

,allowdelete

 ) values ( astructrestrictionID 
,aParentStructRowID
,astruct

,aallowread

,aallowadd

,aallowedit

,aallowdelete

 ); 
 structrestriction_SINIT( aCURSESSION,astructrestrictionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure structrestriction_PARENT /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from structrestriction where  structrestrictionid=aRowID;
  aParentTable := 'objectmode';
 end; 

procedure structrestriction_ISLOCKED /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from structrestriction where structrestrictionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  structrestriction_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure structrestriction_LOCK /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 structrestriction_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  structrestriction_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from structrestriction where structrestrictionid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=structrestriction');
    return;
  end if;
   if  aLockMode =2  
   then   
    update structrestriction set LockUserID =auserID ,LockSessionID =null where structrestrictionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update structrestriction set LockUserID =null,LockSessionID =aCURSESSION  where structrestrictionid=aRowID;
     return;
   end if;
 end ;

procedure structrestriction_HCL /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure structrestriction_UNLOCK /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 structrestriction_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update structrestriction set LockUserID =null  where structrestrictionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update structrestriction set LockSessionID =null  where structrestrictionid=aRowID;
     return;
   end if;
 end; 

procedure structrestriction_SINIT /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from structrestriction where structrestrictionid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =structrestriction');
    return;
  end if;
if aSecurityStyleID is null then
 structrestriction_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update structrestriction set securitystyleid =aStyleID where structrestrictionid = aRowID;
else 
 update structrestriction set securitystyleid =aSecurityStyleID where structrestrictionid = aRowID;
end if; 
end ; 

procedure structrestriction_propagate /*Ораничения на доступ к разделу документа*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from structrestriction where structrestrictionid=aRowid;
end;


procedure methodrestriction_BRIEF  (
 aCURSESSION CHAR,
 amethodrestrictionid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if amethodrestrictionid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from methodrestriction where methodrestrictionID=amethodrestrictionID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from methodrestriction where methodrestrictionid=amethodrestrictionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=methodrestriction');
    return;
  end if;
  aBRIEF:=func.methodrestriction_BRIEF_F(amethodrestrictionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure methodrestriction_DELETE /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 amethodrestrictionid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from methodrestriction where methodrestrictionID=amethodrestrictionID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from methodrestriction where methodrestrictionid=amethodrestrictionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:methodrestriction',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=methodrestriction');
      return;
    end if;
  end if;
 --  verify lock  --
 methodrestriction_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amethodrestrictionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=methodrestriction');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_methodrestriction is select  instanceid ID from instance where OwnerPartName ='methodrestriction' and OwnerRowID=amethodrestrictionid;
row_methodrestriction  chld_methodrestriction%ROWTYPE;
begin
--open chld_methodrestriction;
for row_methodrestriction in chld_methodrestriction loop
 Kernel.INSTANCE_OWNER (acursession,row_methodrestriction.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_methodrestriction.id);
end loop;
--close chld_methodrestriction;
end ;
  delete from  methodrestriction 
  where  methodrestrictionID = amethodrestrictionID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ограничения методов*/
procedure methodrestriction_SAVE /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 amethodrestrictionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,apart CHAR := null /* Структура, которой принадлежит метод *//* Структура, которой принадлежит метод */
,amethod CHAR/* Метод *//* Метод */
,aisrestricted
 NUMBER/* Запрещено использовать *//* Запрещено использовать */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from methodrestriction where methodrestrictionID=amethodrestrictionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from methodrestriction where methodrestrictionid=amethodrestrictionID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:methodrestriction',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=methodrestriction');
      return;
    end if;
  end if;
 --  verify lock  --
 methodrestriction_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amethodrestrictionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=methodrestriction');
    return;
  end if;
 -- update row  --
 update  methodrestriction set ChangeStamp=sysdate
,
  part=apart
,
  method=amethod
,
  isrestricted=aisrestricted
  where  methodrestrictionID = amethodrestrictionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objectmode where objectmodeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:methodrestriction',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=methodrestriction');
      return;
    end if;
 end if;
 objectmode_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=methodrestriction');
    return;
  end if;
 insert into   methodrestriction
 (  methodrestrictionID 
,ParentStructRowID
,part

,method

,isrestricted

 ) values ( amethodrestrictionID 
,aParentStructRowID
,apart

,amethod

,aisrestricted

 ); 
 methodrestriction_SINIT( aCURSESSION,amethodrestrictionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure methodrestriction_PARENT /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from methodrestriction where  methodrestrictionid=aRowID;
  aParentTable := 'objectmode';
 end; 

procedure methodrestriction_ISLOCKED /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from methodrestriction where methodrestrictionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  methodrestriction_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure methodrestriction_LOCK /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 methodrestriction_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  methodrestriction_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from methodrestriction where methodrestrictionid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=methodrestriction');
    return;
  end if;
   if  aLockMode =2  
   then   
    update methodrestriction set LockUserID =auserID ,LockSessionID =null where methodrestrictionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update methodrestriction set LockUserID =null,LockSessionID =aCURSESSION  where methodrestrictionid=aRowID;
     return;
   end if;
 end ;

procedure methodrestriction_HCL /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure methodrestriction_UNLOCK /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 methodrestriction_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update methodrestriction set LockUserID =null  where methodrestrictionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update methodrestriction set LockSessionID =null  where methodrestrictionid=aRowID;
     return;
   end if;
 end; 

procedure methodrestriction_SINIT /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from methodrestriction where methodrestrictionid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =methodrestriction');
    return;
  end if;
if aSecurityStyleID is null then
 methodrestriction_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update methodrestriction set securitystyleid =aStyleID where methodrestrictionid = aRowID;
else 
 update methodrestriction set securitystyleid =aSecurityStyleID where methodrestrictionid = aRowID;
end if; 
end ; 

procedure methodrestriction_propagate /*Ограничение на использование методов раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from methodrestriction where methodrestrictionid=aRowid;
end;


procedure fieldrestriction_BRIEF  (
 aCURSESSION CHAR,
 afieldrestrictionid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldrestrictionid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldrestriction where fieldrestrictionID=afieldrestrictionID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldrestriction where fieldrestrictionid=afieldrestrictionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldrestriction');
    return;
  end if;
  aBRIEF:=func.fieldrestriction_BRIEF_F(afieldrestrictionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldrestriction_DELETE /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 afieldrestrictionid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldrestriction where fieldrestrictionID=afieldrestrictionID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldrestriction where fieldrestrictionid=afieldrestrictionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldrestriction',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldrestriction');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldrestriction_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldrestrictionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldrestriction');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fieldrestriction is select  instanceid ID from instance where OwnerPartName ='fieldrestriction' and OwnerRowID=afieldrestrictionid;
row_fieldrestriction  chld_fieldrestriction%ROWTYPE;
begin
--open chld_fieldrestriction;
for row_fieldrestriction in chld_fieldrestriction loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldrestriction.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldrestriction.id);
end loop;
--close chld_fieldrestriction;
end ;
  delete from  fieldrestriction 
  where  fieldrestrictionID = afieldrestrictionID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ограничения полей*/
procedure fieldrestriction_SAVE /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 afieldrestrictionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athepart CHAR/* Структура, которой принадлежит поле *//* Структура, которой принадлежит поле */
,athefield CHAR/* Поле, на которое накладывается ограничение *//* Поле, на которое накладывается ограничение */
,aallowread
 NUMBER/* Разрешен просмотр *//* Разрешен просмотр */
,aallowmodify
 NUMBER/* Разрешена модификация *//* Разрешена модификация */
,amandatoryfield
 NUMBER := null /* Обязательное поле *//* Обязательное поле */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldrestriction where fieldrestrictionID=afieldrestrictionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldrestriction where fieldrestrictionid=afieldrestrictionID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldrestriction',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldrestriction');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldrestriction_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldrestrictionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldrestriction');
    return;
  end if;
 -- update row  --
 update  fieldrestriction set ChangeStamp=sysdate
,
  thepart=athepart
,
  thefield=athefield
,
  allowread=aallowread
,
  allowmodify=aallowmodify
,
  mandatoryfield=amandatoryfield
  where  fieldrestrictionID = afieldrestrictionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objectmode where objectmodeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldrestriction',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldrestriction');
      return;
    end if;
 end if;
 objectmode_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldrestriction');
    return;
  end if;
 insert into   fieldrestriction
 (  fieldrestrictionID 
,ParentStructRowID
,thepart

,thefield

,allowread

,allowmodify

,mandatoryfield

 ) values ( afieldrestrictionID 
,aParentStructRowID
,athepart

,athefield

,aallowread

,aallowmodify

,amandatoryfield

 ); 
 fieldrestriction_SINIT( aCURSESSION,afieldrestrictionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fieldrestriction_PARENT /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fieldrestriction where  fieldrestrictionid=aRowID;
  aParentTable := 'objectmode';
 end; 

procedure fieldrestriction_ISLOCKED /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldrestriction where fieldrestrictionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldrestriction_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldrestriction_LOCK /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldrestriction_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldrestriction_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldrestriction where fieldrestrictionid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldrestriction');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldrestriction set LockUserID =auserID ,LockSessionID =null where fieldrestrictionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldrestriction set LockUserID =null,LockSessionID =aCURSESSION  where fieldrestrictionid=aRowID;
     return;
   end if;
 end ;

procedure fieldrestriction_HCL /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fieldrestriction_UNLOCK /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldrestriction_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldrestriction set LockUserID =null  where fieldrestrictionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldrestriction set LockSessionID =null  where fieldrestrictionid=aRowID;
     return;
   end if;
 end; 

procedure fieldrestriction_SINIT /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldrestriction where fieldrestrictionid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldrestriction');
    return;
  end if;
if aSecurityStyleID is null then
 fieldrestriction_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldrestriction set securitystyleid =aStyleID where fieldrestrictionid = aRowID;
else 
 update fieldrestriction set securitystyleid =aSecurityStyleID where fieldrestrictionid = aRowID;
end if; 
end ; 

procedure fieldrestriction_propagate /*Ограничения на доступ к полям раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldrestriction where fieldrestrictionid=aRowid;
end;


procedure typemenu_BRIEF  (
 aCURSESSION CHAR,
 atypemenuid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atypemenuid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from typemenu where typemenuID=atypemenuID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from typemenu where typemenuid=atypemenuID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=typemenu');
    return;
  end if;
  aBRIEF:=func.typemenu_BRIEF_F(atypemenuid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure typemenu_DELETE /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 atypemenuid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from typemenu where typemenuID=atypemenuID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from typemenu where typemenuid=atypemenuID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:typemenu',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=typemenu');
      return;
    end if;
  end if;
 --  verify lock  --
 typemenu_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atypemenuid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=typemenu');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_typemenu is select  instanceid ID from instance where OwnerPartName ='typemenu' and OwnerRowID=atypemenuid;
row_typemenu  chld_typemenu%ROWTYPE;
begin
--open chld_typemenu;
for row_typemenu in chld_typemenu loop
 Kernel.INSTANCE_OWNER (acursession,row_typemenu.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_typemenu.id);
end loop;
--close chld_typemenu;
end ;
  delete from  typemenu 
  where  typemenuID = atypemenuID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы типа*/
procedure typemenu_SAVE /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 atypemenuid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,atooltip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_action CHAR := null /* Метод *//* Метод */
,aismenuitem
 NUMBER/* Включать в меню *//* Включать в меню */
,aistoolbarbutton
 NUMBER/* Включать в тулбар *//* Включать в тулбар */
,ahotkey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from typemenu where typemenuID=atypemenuID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from typemenu where typemenuid=atypemenuID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:typemenu',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=typemenu');
      return;
    end if;
  end if;
 --  verify lock  --
 typemenu_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atypemenuid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=typemenu');
    return;
  end if;
 -- update row  --
 update  typemenu set ChangeStamp=sysdate
,
  name=aname
,
  caption=acaption
,
  tooltip=atooltip
,
  the_action=athe_action
,
  ismenuitem=aismenuitem
,
  istoolbarbutton=aistoolbarbutton
,
  hotkey=ahotkey
  where  typemenuID = atypemenuID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objecttype where objecttypeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:typemenu',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=typemenu');
      return;
    end if;
 end if;
 objecttype_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=typemenu');
    return;
  end if;
 insert into   typemenu
 (  typemenuID 
,ParentStructRowID
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 ) values ( atypemenuID 
,aParentStructRowID
,aname

,acaption

,atooltip

,athe_action

,aismenuitem

,aistoolbarbutton

,ahotkey

 ); 
 typemenu_SINIT( aCURSESSION,atypemenuid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure typemenu_PARENT /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from typemenu where  typemenuid=aRowID;
  aParentTable := 'objecttype';
 end; 

procedure typemenu_ISLOCKED /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from typemenu where typemenuid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  typemenu_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure typemenu_LOCK /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 typemenu_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  typemenu_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from typemenu where typemenuid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=typemenu');
    return;
  end if;
   if  aLockMode =2  
   then   
    update typemenu set LockUserID =auserID ,LockSessionID =null where typemenuid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update typemenu set LockUserID =null,LockSessionID =aCURSESSION  where typemenuid=aRowID;
     return;
   end if;
 end ;

procedure typemenu_HCL /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure typemenu_UNLOCK /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 typemenu_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update typemenu set LockUserID =null  where typemenuid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update typemenu set LockSessionID =null  where typemenuid=aRowID;
     return;
   end if;
 end; 

procedure typemenu_SINIT /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from typemenu where typemenuid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =typemenu');
    return;
  end if;
if aSecurityStyleID is null then
 typemenu_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update typemenu set securitystyleid =aStyleID where typemenuid = aRowID;
else 
 update typemenu set securitystyleid =aSecurityStyleID where typemenuid = aRowID;
end if; 
end ; 

procedure typemenu_propagate /*Методы уровня типа*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from typemenu where typemenuid=aRowid;
end;


procedure instancevalidator_BRIEF  (
 aCURSESSION CHAR,
 ainstancevalidatorid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ainstancevalidatorid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from instancevalidator where instancevalidatorID=ainstancevalidatorID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from instancevalidator where instancevalidatorid=ainstancevalidatorID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=instancevalidator');
    return;
  end if;
  aBRIEF:=func.instancevalidator_BRIEF_F(ainstancevalidatorid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure instancevalidator_DELETE /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 ainstancevalidatorid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from instancevalidator where instancevalidatorID=ainstancevalidatorID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from instancevalidator where instancevalidatorid=ainstancevalidatorID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:instancevalidator',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=instancevalidator');
      return;
    end if;
  end if;
 --  verify lock  --
 instancevalidator_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ainstancevalidatorid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=instancevalidator');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_instancevalidator is select  instanceid ID from instance where OwnerPartName ='instancevalidator' and OwnerRowID=ainstancevalidatorid;
row_instancevalidator  chld_instancevalidator%ROWTYPE;
begin
--open chld_instancevalidator;
for row_instancevalidator in chld_instancevalidator loop
 Kernel.INSTANCE_OWNER (acursession,row_instancevalidator.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_instancevalidator.id);
end loop;
--close chld_instancevalidator;
end ;
  delete from  instancevalidator 
  where  instancevalidatorID = ainstancevalidatorID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Проверка правильности*/
procedure instancevalidator_SAVE /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 ainstancevalidatorid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from instancevalidator where instancevalidatorID=ainstancevalidatorID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from instancevalidator where instancevalidatorid=ainstancevalidatorID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:instancevalidator',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=instancevalidator');
      return;
    end if;
  end if;
 --  verify lock  --
 instancevalidator_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ainstancevalidatorid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=instancevalidator');
    return;
  end if;
 -- update row  --
 update  instancevalidator set ChangeStamp=sysdate
,
  target=atarget
,
  code=acode
  where  instancevalidatorID = ainstancevalidatorID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objecttype where objecttypeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:instancevalidator',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=instancevalidator');
      return;
    end if;
 end if;
 objecttype_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=instancevalidator');
    return;
  end if;
 insert into   instancevalidator
 (  instancevalidatorID 
,ParentStructRowID
,target

,code

 ) values ( ainstancevalidatorID 
,aParentStructRowID
,atarget

,acode

 ); 
 instancevalidator_SINIT( aCURSESSION,ainstancevalidatorid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure instancevalidator_PARENT /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from instancevalidator where  instancevalidatorid=aRowID;
  aParentTable := 'objecttype';
 end; 

procedure instancevalidator_ISLOCKED /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from instancevalidator where instancevalidatorid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  instancevalidator_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure instancevalidator_LOCK /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 instancevalidator_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  instancevalidator_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from instancevalidator where instancevalidatorid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=instancevalidator');
    return;
  end if;
   if  aLockMode =2  
   then   
    update instancevalidator set LockUserID =auserID ,LockSessionID =null where instancevalidatorid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update instancevalidator set LockUserID =null,LockSessionID =aCURSESSION  where instancevalidatorid=aRowID;
     return;
   end if;
 end ;

procedure instancevalidator_HCL /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure instancevalidator_UNLOCK /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 instancevalidator_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update instancevalidator set LockUserID =null  where instancevalidatorid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update instancevalidator set LockSessionID =null  where instancevalidatorid=aRowID;
     return;
   end if;
 end; 

procedure instancevalidator_SINIT /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from instancevalidator where instancevalidatorid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =instancevalidator');
    return;
  end if;
if aSecurityStyleID is null then
 instancevalidator_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update instancevalidator set securitystyleid =aStyleID where instancevalidatorid = aRowID;
else 
 update instancevalidator set securitystyleid =aSecurityStyleID where instancevalidatorid = aRowID;
end if; 
end ; 

procedure instancevalidator_propagate /*Проверка правильности для объекта в целом*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from instancevalidator where instancevalidatorid=aRowid;
end;


procedure part_BRIEF  (
 aCURSESSION CHAR,
 apartid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if apartid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from part where partID=apartID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from part where partid=apartID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=part');
    return;
  end if;
  aBRIEF:=func.part_BRIEF_F(apartid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure part_DELETE /*Раздел объекта*/ (
 aCURSESSION CHAR,
 apartid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from part where partID=apartID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from part where partid=apartID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:part',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=part');
      return;
    end if;
  end if;
 --  verify lock  --
 part_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=part');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_partmenu is select partmenu.partmenuid ID from partmenu where  partmenu.ParentStructRowID = apartid;
    child_partmenu_rec  child_partmenu%ROWTYPE;
    begin
    --open child_partmenu;
      for child_partmenu_rec in child_partmenu loop
      partmenu_DELETE (acursession,child_partmenu_rec.id,aInstanceid);
      end loop;
      --close child_partmenu;
    end ;
    declare cursor child_partview is select partview.partviewid ID from partview where  partview.ParentStructRowID = apartid;
    child_partview_rec  child_partview%ROWTYPE;
    begin
    --open child_partview;
      for child_partview_rec in child_partview loop
      partview_DELETE (acursession,child_partview_rec.id,aInstanceid);
      end loop;
      --close child_partview;
    end ;
    declare cursor child_validator is select validator.validatorid ID from validator where  validator.ParentStructRowID = apartid;
    child_validator_rec  child_validator%ROWTYPE;
    begin
    --open child_validator;
      for child_validator_rec in child_validator loop
      validator_DELETE (acursession,child_validator_rec.id,aInstanceid);
      end loop;
      --close child_validator;
    end ;
    declare cursor child_uniqueconstraint is select uniqueconstraint.uniqueconstraintid ID from uniqueconstraint where  uniqueconstraint.ParentStructRowID = apartid;
    child_uniqueconstraint_rec  child_uniqueconstraint%ROWTYPE;
    begin
    --open child_uniqueconstraint;
      for child_uniqueconstraint_rec in child_uniqueconstraint loop
      uniqueconstraint_DELETE (acursession,child_uniqueconstraint_rec.id,aInstanceid);
      end loop;
      --close child_uniqueconstraint;
    end ;
    declare cursor child_extenderinterface is select extenderinterface.extenderinterfaceid ID from extenderinterface where  extenderinterface.ParentStructRowID = apartid;
    child_extenderinterface_rec  child_extenderinterface%ROWTYPE;
    begin
    --open child_extenderinterface;
      for child_extenderinterface_rec in child_extenderinterface loop
      extenderinterface_DELETE (acursession,child_extenderinterface_rec.id,aInstanceid);
      end loop;
      --close child_extenderinterface;
    end ;
    declare cursor child_field is select field.fieldid ID from field where  field.ParentStructRowID = apartid;
    child_field_rec  child_field%ROWTYPE;
    begin
    --open child_field;
      for child_field_rec in child_field loop
      field_DELETE (acursession,child_field_rec.id,aInstanceid);
      end loop;
      --close child_field;
    end ;
declare cursor chld_part is select  instanceid ID from instance where OwnerPartName ='part' and OwnerRowID=apartid;
row_part  chld_part%ROWTYPE;
begin
--open chld_part;
for row_part in chld_part loop
 Kernel.INSTANCE_OWNER (acursession,row_part.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_part.id);
end loop;
--close chld_part;
end ;
  delete from  part 
  where  partID = apartID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Раздел*/
procedure part_SAVE /*Раздел объекта*/ (
 aCURSESSION CHAR,
 apartid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
, aParentRowid CHAR :=null
,asequence
 NUMBER/* № п/п *//* № п/п */
,aparttype
 NUMBER/* Тип структры *//* Тип структры */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aname
 VARCHAR2/* Название *//* Название */
,athe_comment VARCHAR2 := null /* Описание *//* Описание */
,anolog
 NUMBER/* Не записывать в журнал *//* Не записывать в журнал */
,amanualregister
 NUMBER/* Исключить из индексирования *//* Исключить из индексирования */
,aoncreate CHAR := null /* При создании *//* При создании */
,aonsave CHAR := null /* При сохранении *//* При сохранении */
,aonrun CHAR := null /* При открытии *//* При открытии */
,aondelete CHAR := null /* При удалении *//* При удалении */
,aaddbehaivor
 NUMBER := null /* Поведение при добавлении *//* Поведение при добавлении */
,aextenderobject CHAR := null /* Объект расширения *//* Объект расширения */
,ashablonbrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,arulebrief
 VARCHAR2 := null /* Правило составления BRIEF поля *//* Правило составления BRIEF поля */
,aisjormalchange
 NUMBER/* Вести журнал изменений *//* Вести журнал изменений */
,ausearchiving
 NUMBER/* Архивировать вместо удаления *//* Архивировать вместо удаления */
,aintegerpkey
 NUMBER/* Целочисленный ключ *//* Целочисленный ключ */
,aparticoncls
 VARCHAR2 := null /* Иконка раздела *//* Иконка раздела */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from part where partID=apartID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from part where partid=apartID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:part',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=part');
      return;
    end if;
  end if;
 --  verify lock  --
 part_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=part');
    return;
  end if;
 -- update row  --
 update  part set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  sequence=asequence
,
  parttype=aparttype
,
  caption=acaption
,
  name=aname
,
  the_comment=athe_comment
,
  nolog=anolog
,
  manualregister=amanualregister
,
  oncreate=aoncreate
,
  onsave=aonsave
,
  onrun=aonrun
,
  ondelete=aondelete
,
  addbehaivor=aaddbehaivor
,
  extenderobject=aextenderobject
,
  shablonbrief=ashablonbrief
,
  rulebrief=arulebrief
,
  isjormalchange=aisjormalchange
,
  usearchiving=ausearchiving
,
  integerpkey=aintegerpkey
,
  particoncls=aparticoncls
  where  partID = apartID; 
 -- checking unique constraints  --

 if aParentRowID is null then
   select Count(*) into aUniqueRowCount from part where ParentStructRowID=aParentStructRowID and ParentRowID is null 
 and sequence=asequence;
 else 
   select Count(*) into aUniqueRowCount from part where ParentStructRowID=aParentStructRowID and ParentRowID =aParentRowID 
 and sequence=asequence;
 end if;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=part');
 return;
end if;
select Count(*) into aUniqueRowCount from part where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=part');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from objecttype where objecttypeid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:part',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=part');
      return;
    end if;
 end if;
 objecttype_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=part');
    return;
  end if;
 insert into   part
 (  partID 
,ParentRowid
,ParentStructRowID
,sequence

,parttype

,caption

,name

,the_comment

,nolog

,manualregister

,oncreate

,onsave

,onrun

,ondelete

,addbehaivor

,extenderobject

,shablonbrief

,rulebrief

,isjormalchange

,usearchiving

,integerpkey

,particoncls

 ) values ( apartID 
,aParentRowid
,aParentStructRowID
,asequence

,aparttype

,acaption

,aname

,athe_comment

,anolog

,amanualregister

,aoncreate

,aonsave

,aonrun

,aondelete

,aaddbehaivor

,aextenderobject

,ashablonbrief

,arulebrief

,aisjormalchange

,ausearchiving

,aintegerpkey

,aparticoncls

 ); 
 part_SINIT( aCURSESSION,apartid,atmpid);
 -- checking unique constraints  --

 if aParentRowID is null then
   select Count(*) into aUniqueRowCount from part where ParentStructRowID=aParentStructRowID and ParentRowID is null 
 and sequence=asequence;
 else 
   select Count(*) into aUniqueRowCount from part where ParentStructRowID=aParentStructRowID and ParentRowID =aParentRowID 
 and sequence=asequence;
 end if;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=part');
 return;
end if;
select Count(*) into aUniqueRowCount from part where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=part');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure part_PARENT /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from part where  partid=aRowID;
  aParentTable := 'objecttype';
 end; 

procedure part_ISLOCKED /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from part where partid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  part_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure part_LOCK /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 part_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  part_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from part where partid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=part');
    return;
  end if;
   if  aLockMode =2  
   then   
    update part set LockUserID =auserID ,LockSessionID =null where partid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update part set LockUserID =null,LockSessionID =aCURSESSION  where partid=aRowID;
     return;
   end if;
 end ;

procedure part_HCL /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_partmenu is select partmenu.partmenuid ID from partmenu where  partmenu.ParentStructRowID = aRowid;
row_partmenu lch_partmenu%ROWTYPE;
begin  
--open lch_partmenu;
for row_partmenu in lch_partmenu
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from partmenu where partmenuid=row_partmenu.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_partmenu;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_partmenu;
     return;
   end if; 
 end if;  
 partmenu_HCL (acursession,row_partmenu.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_partmenu;
   return;
 end if;
end loop;
--close lch_partmenu;
end;
declare cursor lch_partview is select partview.partviewid ID from partview where  partview.ParentStructRowID = aRowid;
row_partview lch_partview%ROWTYPE;
begin  
--open lch_partview;
for row_partview in lch_partview
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from partview where partviewid=row_partview.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_partview;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_partview;
     return;
   end if; 
 end if;  
 partview_HCL (acursession,row_partview.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_partview;
   return;
 end if;
end loop;
--close lch_partview;
end;
declare cursor lch_validator is select validator.validatorid ID from validator where  validator.ParentStructRowID = aRowid;
row_validator lch_validator%ROWTYPE;
begin  
--open lch_validator;
for row_validator in lch_validator
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from validator where validatorid=row_validator.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_validator;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_validator;
     return;
   end if; 
 end if;  
 validator_HCL (acursession,row_validator.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_validator;
   return;
 end if;
end loop;
--close lch_validator;
end;
declare cursor lch_uniqueconstraint is select uniqueconstraint.uniqueconstraintid ID from uniqueconstraint where  uniqueconstraint.ParentStructRowID = aRowid;
row_uniqueconstraint lch_uniqueconstraint%ROWTYPE;
begin  
--open lch_uniqueconstraint;
for row_uniqueconstraint in lch_uniqueconstraint
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from uniqueconstraint where uniqueconstraintid=row_uniqueconstraint.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_uniqueconstraint;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_uniqueconstraint;
     return;
   end if; 
 end if;  
 uniqueconstraint_HCL (acursession,row_uniqueconstraint.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_uniqueconstraint;
   return;
 end if;
end loop;
--close lch_uniqueconstraint;
end;
declare cursor lch_extenderinterface is select extenderinterface.extenderinterfaceid ID from extenderinterface where  extenderinterface.ParentStructRowID = aRowid;
row_extenderinterface lch_extenderinterface%ROWTYPE;
begin  
--open lch_extenderinterface;
for row_extenderinterface in lch_extenderinterface
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from extenderinterface where extenderinterfaceid=row_extenderinterface.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_extenderinterface;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_extenderinterface;
     return;
   end if; 
 end if;  
 extenderinterface_HCL (acursession,row_extenderinterface.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_extenderinterface;
   return;
 end if;
end loop;
--close lch_extenderinterface;
end;
declare cursor lch_field is select field.fieldid ID from field where  field.ParentStructRowID = aRowid;
row_field lch_field%ROWTYPE;
begin  
--open lch_field;
for row_field in lch_field
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from field where fieldid=row_field.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_field;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_field;
     return;
   end if; 
 end if;  
 field_HCL (acursession,row_field.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_field;
   return;
 end if;
end loop;
--close lch_field;
end;
aIsLocked :=0;
end;

procedure part_UNLOCK /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 part_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update part set LockUserID =null  where partid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update part set LockSessionID =null  where partid=aRowID;
     return;
   end if;
 end; 

procedure part_SINIT /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from part where partid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =part');
    return;
  end if;
if aSecurityStyleID is null then
 part_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update part set securitystyleid =aStyleID where partid = aRowID;
else 
 update part set securitystyleid =aSecurityStyleID where partid = aRowID;
end if; 
end ; 

procedure part_propagate /*Раздел объекта*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from part where partid=aRowid;
declare cursor pch_partmenu  is select partmenu.partmenuid ID from partmenu where  partmenu.ParentStructRowID = aRowid;
row_partmenu  pch_partmenu%ROWTYPE;
begin
--open pch_partmenu;
for row_partmenu in pch_partmenu loop
   partmenu_SINIT( acursession,row_partmenu.id,assid);
   partmenu_propagate( acursession,row_partmenu.id);
end loop;
--close pch_partmenu;
end;
declare cursor pch_partview  is select partview.partviewid ID from partview where  partview.ParentStructRowID = aRowid;
row_partview  pch_partview%ROWTYPE;
begin
--open pch_partview;
for row_partview in pch_partview loop
   partview_SINIT( acursession,row_partview.id,assid);
   partview_propagate( acursession,row_partview.id);
end loop;
--close pch_partview;
end;
declare cursor pch_validator  is select validator.validatorid ID from validator where  validator.ParentStructRowID = aRowid;
row_validator  pch_validator%ROWTYPE;
begin
--open pch_validator;
for row_validator in pch_validator loop
   validator_SINIT( acursession,row_validator.id,assid);
   validator_propagate( acursession,row_validator.id);
end loop;
--close pch_validator;
end;
declare cursor pch_uniqueconstraint  is select uniqueconstraint.uniqueconstraintid ID from uniqueconstraint where  uniqueconstraint.ParentStructRowID = aRowid;
row_uniqueconstraint  pch_uniqueconstraint%ROWTYPE;
begin
--open pch_uniqueconstraint;
for row_uniqueconstraint in pch_uniqueconstraint loop
   uniqueconstraint_SINIT( acursession,row_uniqueconstraint.id,assid);
   uniqueconstraint_propagate( acursession,row_uniqueconstraint.id);
end loop;
--close pch_uniqueconstraint;
end;
declare cursor pch_extenderinterface  is select extenderinterface.extenderinterfaceid ID from extenderinterface where  extenderinterface.ParentStructRowID = aRowid;
row_extenderinterface  pch_extenderinterface%ROWTYPE;
begin
--open pch_extenderinterface;
for row_extenderinterface in pch_extenderinterface loop
   extenderinterface_SINIT( acursession,row_extenderinterface.id,assid);
   extenderinterface_propagate( acursession,row_extenderinterface.id);
end loop;
--close pch_extenderinterface;
end;
declare cursor pch_field  is select field.fieldid ID from field where  field.ParentStructRowID = aRowid;
row_field  pch_field%ROWTYPE;
begin
--open pch_field;
for row_field in pch_field loop
   field_SINIT( acursession,row_field.id,assid);
   field_propagate( acursession,row_field.id);
end loop;
--close pch_field;
end;
end;


procedure partmenu_BRIEF  (
 aCURSESSION CHAR,
 apartmenuid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if apartmenuid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from partmenu where partmenuID=apartmenuID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from partmenu where partmenuid=apartmenuID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=partmenu');
    return;
  end if;
  aBRIEF:=func.partmenu_BRIEF_F(apartmenuid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure partmenu_DELETE /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 apartmenuid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from partmenu where partmenuID=apartmenuID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from partmenu where partmenuid=apartmenuID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:partmenu',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=partmenu');
      return;
    end if;
  end if;
 --  verify lock  --
 partmenu_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartmenuid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=partmenu');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_partparammap is select partparammap.partparammapid ID from partparammap where  partparammap.ParentStructRowID = apartmenuid;
    child_partparammap_rec  child_partparammap%ROWTYPE;
    begin
    --open child_partparammap;
      for child_partparammap_rec in child_partparammap loop
      partparammap_DELETE (acursession,child_partparammap_rec.id,aInstanceid);
      end loop;
      --close child_partparammap;
    end ;
declare cursor chld_partmenu is select  instanceid ID from instance where OwnerPartName ='partmenu' and OwnerRowID=apartmenuid;
row_partmenu  chld_partmenu%ROWTYPE;
begin
--open chld_partmenu;
for row_partmenu in chld_partmenu loop
 Kernel.INSTANCE_OWNER (acursession,row_partmenu.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_partmenu.id);
end loop;
--close chld_partmenu;
end ;
  delete from  partmenu 
  where  partmenuID = apartmenuID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы раздела*/
procedure partmenu_SAVE /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 apartmenuid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,atooltip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,athe_action CHAR := null /* Метод *//* Метод */
,aismenuitem
 NUMBER/* Включать в меню *//* Включать в меню */
,aistoolbarbutton
 NUMBER/* В тулбар *//* В тулбар */
,ahotkey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from partmenu where partmenuID=apartmenuID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from partmenu where partmenuid=apartmenuID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:partmenu',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=partmenu');
      return;
    end if;
  end if;
 --  verify lock  --
 partmenu_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartmenuid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partmenu');
    return;
  end if;
 -- update row  --
 update  partmenu set ChangeStamp=sysdate
,
  name=aname
,
  caption=acaption
,
  tooltip=atooltip
,
  the_action=athe_action
,
  ismenuitem=aismenuitem
,
  istoolbarbutton=aistoolbarbutton
,
  hotkey=ahotkey
  where  partmenuID = apartmenuID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from part where partid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:partmenu',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=partmenu');
      return;
    end if;
 end if;
 part_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partmenu');
    return;
  end if;
 insert into   partmenu
 (  partmenuID 
,ParentStructRowID
,name

,caption

,tooltip

,the_action

,ismenuitem

,istoolbarbutton

,hotkey

 ) values ( apartmenuID 
,aParentStructRowID
,aname

,acaption

,atooltip

,athe_action

,aismenuitem

,aistoolbarbutton

,ahotkey

 ); 
 partmenu_SINIT( aCURSESSION,apartmenuid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure partmenu_PARENT /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from partmenu where  partmenuid=aRowID;
  aParentTable := 'part';
 end; 

procedure partmenu_ISLOCKED /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from partmenu where partmenuid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  partmenu_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure partmenu_LOCK /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 partmenu_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  partmenu_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from partmenu where partmenuid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=partmenu');
    return;
  end if;
   if  aLockMode =2  
   then   
    update partmenu set LockUserID =auserID ,LockSessionID =null where partmenuid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update partmenu set LockUserID =null,LockSessionID =aCURSESSION  where partmenuid=aRowID;
     return;
   end if;
 end ;

procedure partmenu_HCL /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_partparammap is select partparammap.partparammapid ID from partparammap where  partparammap.ParentStructRowID = aRowid;
row_partparammap lch_partparammap%ROWTYPE;
begin  
--open lch_partparammap;
for row_partparammap in lch_partparammap
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from partparammap where partparammapid=row_partparammap.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_partparammap;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_partparammap;
     return;
   end if; 
 end if;  
 partparammap_HCL (acursession,row_partparammap.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_partparammap;
   return;
 end if;
end loop;
--close lch_partparammap;
end;
aIsLocked :=0;
end;

procedure partmenu_UNLOCK /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 partmenu_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update partmenu set LockUserID =null  where partmenuid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update partmenu set LockSessionID =null  where partmenuid=aRowID;
     return;
   end if;
 end; 

procedure partmenu_SINIT /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from partmenu where partmenuid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =partmenu');
    return;
  end if;
if aSecurityStyleID is null then
 partmenu_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update partmenu set securitystyleid =aStyleID where partmenuid = aRowID;
else 
 update partmenu set securitystyleid =aSecurityStyleID where partmenuid = aRowID;
end if; 
end ; 

procedure partmenu_propagate /*Методы уровня раздела*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from partmenu where partmenuid=aRowid;
declare cursor pch_partparammap  is select partparammap.partparammapid ID from partparammap where  partparammap.ParentStructRowID = aRowid;
row_partparammap  pch_partparammap%ROWTYPE;
begin
--open pch_partparammap;
for row_partparammap in pch_partparammap loop
   partparammap_SINIT( acursession,row_partparammap.id,assid);
   partparammap_propagate( acursession,row_partparammap.id);
end loop;
--close pch_partparammap;
end;
end;


procedure partparammap_BRIEF  (
 aCURSESSION CHAR,
 apartparammapid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if apartparammapid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from partparammap where partparammapID=apartparammapID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from partparammap where partparammapid=apartparammapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=partparammap');
    return;
  end if;
  aBRIEF:=func.partparammap_BRIEF_F(apartparammapid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure partparammap_DELETE /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 apartparammapid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from partparammap where partparammapID=apartparammapID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from partparammap where partparammapid=apartparammapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:partparammap',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=partparammap');
      return;
    end if;
  end if;
 --  verify lock  --
 partparammap_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartparammapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=partparammap');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_partparammap is select  instanceid ID from instance where OwnerPartName ='partparammap' and OwnerRowID=apartparammapid;
row_partparammap  chld_partparammap%ROWTYPE;
begin
--open chld_partparammap;
for row_partparammap in chld_partparammap loop
 Kernel.INSTANCE_OWNER (acursession,row_partparammap.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_partparammap.id);
end loop;
--close chld_partparammap;
end ;
  delete from  partparammap 
  where  partparammapID = apartparammapID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение параметров*/
procedure partparammap_SAVE /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 apartparammapid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,afieldname
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aparamname
 VARCHAR2/* Параметр *//* Параметр */
,anoedit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from partparammap where partparammapID=apartparammapID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from partparammap where partparammapid=apartparammapID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:partparammap',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=partparammap');
      return;
    end if;
  end if;
 --  verify lock  --
 partparammap_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartparammapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partparammap');
    return;
  end if;
 -- update row  --
 update  partparammap set ChangeStamp=sysdate
,
  fieldname=afieldname
,
  paramname=aparamname
,
  noedit=anoedit
  where  partparammapID = apartparammapID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from partmenu where partmenuid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:partparammap',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=partparammap');
      return;
    end if;
 end if;
 partmenu_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partparammap');
    return;
  end if;
 insert into   partparammap
 (  partparammapID 
,ParentStructRowID
,fieldname

,paramname

,noedit

 ) values ( apartparammapID 
,aParentStructRowID
,afieldname

,aparamname

,anoedit

 ); 
 partparammap_SINIT( aCURSESSION,apartparammapid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure partparammap_PARENT /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from partparammap where  partparammapid=aRowID;
  aParentTable := 'partmenu';
 end; 

procedure partparammap_ISLOCKED /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from partparammap where partparammapid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  partparammap_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure partparammap_LOCK /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 partparammap_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  partparammap_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from partparammap where partparammapid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=partparammap');
    return;
  end if;
   if  aLockMode =2  
   then   
    update partparammap set LockUserID =auserID ,LockSessionID =null where partparammapid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update partparammap set LockUserID =null,LockSessionID =aCURSESSION  where partparammapid=aRowID;
     return;
   end if;
 end ;

procedure partparammap_HCL /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure partparammap_UNLOCK /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 partparammap_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update partparammap set LockUserID =null  where partparammapid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update partparammap set LockSessionID =null  where partparammapid=aRowID;
     return;
   end if;
 end; 

procedure partparammap_SINIT /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from partparammap where partparammapid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =partparammap');
    return;
  end if;
if aSecurityStyleID is null then
 partparammap_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update partparammap set securitystyleid =aStyleID where partparammapid = aRowID;
else 
 update partparammap set securitystyleid =aSecurityStyleID where partparammapid = aRowID;
end if; 
end ; 

procedure partparammap_propagate /*отображение значений полей раздела на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from partparammap where partparammapid=aRowid;
end;


procedure partview_BRIEF  (
 aCURSESSION CHAR,
 apartviewid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if apartviewid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from partview where partviewID=apartviewID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from partview where partviewid=apartviewID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=partview');
    return;
  end if;
  aBRIEF:=func.partview_BRIEF_F(apartviewid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure partview_DELETE /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 apartviewid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from partview where partviewID=apartviewID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from partview where partviewid=apartviewID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:partview',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=partview');
      return;
    end if;
  end if;
 --  verify lock  --
 partview_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartviewid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=partview');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_viewcolumn is select viewcolumn.viewcolumnid ID from viewcolumn where  viewcolumn.ParentStructRowID = apartviewid;
    child_viewcolumn_rec  child_viewcolumn%ROWTYPE;
    begin
    --open child_viewcolumn;
      for child_viewcolumn_rec in child_viewcolumn loop
      viewcolumn_DELETE (acursession,child_viewcolumn_rec.id,aInstanceid);
      end loop;
      --close child_viewcolumn;
    end ;
    declare cursor child_partview_lnk is select partview_lnk.partview_lnkid ID from partview_lnk where  partview_lnk.ParentStructRowID = apartviewid;
    child_partview_lnk_rec  child_partview_lnk%ROWTYPE;
    begin
    --open child_partview_lnk;
      for child_partview_lnk_rec in child_partview_lnk loop
      partview_lnk_DELETE (acursession,child_partview_lnk_rec.id,aInstanceid);
      end loop;
      --close child_partview_lnk;
    end ;
declare cursor chld_partview is select  instanceid ID from instance where OwnerPartName ='partview' and OwnerRowID=apartviewid;
row_partview  chld_partview%ROWTYPE;
begin
--open chld_partview;
for row_partview in chld_partview loop
 Kernel.INSTANCE_OWNER (acursession,row_partview.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_partview.id);
end loop;
--close chld_partview;
end ;
  delete from  partview 
  where  partviewID = apartviewID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Представление*/
procedure partview_SAVE /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 apartviewid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2/* Псевдоним *//* Псевдоним */
,aforchoose
 NUMBER/* Для поиска *//* Для поиска */
,afilterfield0
 VARCHAR2 := null /* Поле - фильтр 0 *//* Поле - фильтр 0 */
,afilterfield1
 VARCHAR2 := null /* Поле - фильтр 1 *//* Поле - фильтр 1 */
,afilterfield2
 VARCHAR2 := null /* Поле - фильтр 2 *//* Поле - фильтр 2 */
,afilterfield3
 VARCHAR2 := null /* Поле - фильтр 3 *//* Поле - фильтр 3 */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from partview where partviewID=apartviewID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from partview where partviewid=apartviewID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:partview',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=partview');
      return;
    end if;
  end if;
 --  verify lock  --
 partview_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartviewid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partview');
    return;
  end if;
 -- update row  --
 update  partview set ChangeStamp=sysdate
,
  name=aname
,
  the_alias=athe_alias
,
  forchoose=aforchoose
,
  filterfield0=afilterfield0
,
  filterfield1=afilterfield1
,
  filterfield2=afilterfield2
,
  filterfield3=afilterfield3
  where  partviewID = apartviewID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from part where partid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:partview',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=partview');
      return;
    end if;
 end if;
 part_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partview');
    return;
  end if;
 insert into   partview
 (  partviewID 
,ParentStructRowID
,name

,the_alias

,forchoose

,filterfield0

,filterfield1

,filterfield2

,filterfield3

 ) values ( apartviewID 
,aParentStructRowID
,aname

,athe_alias

,aforchoose

,afilterfield0

,afilterfield1

,afilterfield2

,afilterfield3

 ); 
 partview_SINIT( aCURSESSION,apartviewid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure partview_PARENT /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from partview where  partviewid=aRowID;
  aParentTable := 'part';
 end; 

procedure partview_ISLOCKED /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from partview where partviewid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  partview_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure partview_LOCK /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 partview_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  partview_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from partview where partviewid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=partview');
    return;
  end if;
   if  aLockMode =2  
   then   
    update partview set LockUserID =auserID ,LockSessionID =null where partviewid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update partview set LockUserID =null,LockSessionID =aCURSESSION  where partviewid=aRowID;
     return;
   end if;
 end ;

procedure partview_HCL /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_viewcolumn is select viewcolumn.viewcolumnid ID from viewcolumn where  viewcolumn.ParentStructRowID = aRowid;
row_viewcolumn lch_viewcolumn%ROWTYPE;
begin  
--open lch_viewcolumn;
for row_viewcolumn in lch_viewcolumn
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from viewcolumn where viewcolumnid=row_viewcolumn.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_viewcolumn;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_viewcolumn;
     return;
   end if; 
 end if;  
 viewcolumn_HCL (acursession,row_viewcolumn.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_viewcolumn;
   return;
 end if;
end loop;
--close lch_viewcolumn;
end;
declare cursor lch_partview_lnk is select partview_lnk.partview_lnkid ID from partview_lnk where  partview_lnk.ParentStructRowID = aRowid;
row_partview_lnk lch_partview_lnk%ROWTYPE;
begin  
--open lch_partview_lnk;
for row_partview_lnk in lch_partview_lnk
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from partview_lnk where partview_lnkid=row_partview_lnk.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_partview_lnk;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_partview_lnk;
     return;
   end if; 
 end if;  
 partview_lnk_HCL (acursession,row_partview_lnk.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_partview_lnk;
   return;
 end if;
end loop;
--close lch_partview_lnk;
end;
aIsLocked :=0;
end;

procedure partview_UNLOCK /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 partview_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update partview set LockUserID =null  where partviewid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update partview set LockSessionID =null  where partviewid=aRowID;
     return;
   end if;
 end; 

procedure partview_SINIT /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from partview where partviewid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =partview');
    return;
  end if;
if aSecurityStyleID is null then
 partview_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update partview set securitystyleid =aStyleID where partviewid = aRowID;
else 
 update partview set securitystyleid =aSecurityStyleID where partviewid = aRowID;
end if; 
end ; 

procedure partview_propagate /*Вариант представления, который может использоваться для создания журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from partview where partviewid=aRowid;
declare cursor pch_viewcolumn  is select viewcolumn.viewcolumnid ID from viewcolumn where  viewcolumn.ParentStructRowID = aRowid;
row_viewcolumn  pch_viewcolumn%ROWTYPE;
begin
--open pch_viewcolumn;
for row_viewcolumn in pch_viewcolumn loop
   viewcolumn_SINIT( acursession,row_viewcolumn.id,assid);
   viewcolumn_propagate( acursession,row_viewcolumn.id);
end loop;
--close pch_viewcolumn;
end;
declare cursor pch_partview_lnk  is select partview_lnk.partview_lnkid ID from partview_lnk where  partview_lnk.ParentStructRowID = aRowid;
row_partview_lnk  pch_partview_lnk%ROWTYPE;
begin
--open pch_partview_lnk;
for row_partview_lnk in pch_partview_lnk loop
   partview_lnk_SINIT( acursession,row_partview_lnk.id,assid);
   partview_lnk_propagate( acursession,row_partview_lnk.id);
end loop;
--close pch_partview_lnk;
end;
end;


procedure viewcolumn_BRIEF  (
 aCURSESSION CHAR,
 aviewcolumnid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aviewcolumnid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from viewcolumn where viewcolumnID=aviewcolumnID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from viewcolumn where viewcolumnid=aviewcolumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=viewcolumn');
    return;
  end if;
  aBRIEF:=func.viewcolumn_BRIEF_F(aviewcolumnid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure viewcolumn_DELETE /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aviewcolumnid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from viewcolumn where viewcolumnID=aviewcolumnID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from viewcolumn where viewcolumnid=aviewcolumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:viewcolumn',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=viewcolumn');
      return;
    end if;
  end if;
 --  verify lock  --
 viewcolumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aviewcolumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=viewcolumn');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_viewcolumn is select  instanceid ID from instance where OwnerPartName ='viewcolumn' and OwnerRowID=aviewcolumnid;
row_viewcolumn  chld_viewcolumn%ROWTYPE;
begin
--open chld_viewcolumn;
for row_viewcolumn in chld_viewcolumn loop
 Kernel.INSTANCE_OWNER (acursession,row_viewcolumn.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_viewcolumn.id);
end loop;
--close chld_viewcolumn;
end ;
  delete from  viewcolumn 
  where  viewcolumnID = aviewcolumnID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Колонка*/
procedure viewcolumn_SAVE /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aviewcolumnid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER := null /* № *//* № */
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2/* Псвдоним *//* Псвдоним */
,afrompart CHAR/* Раздел *//* Раздел */
,afield CHAR/* Поле *//* Поле */
,aaggregation
 NUMBER/* Агрегация *//* Агрегация */
,aexpression VARCHAR2 := null /* Формула *//* Формула */
,aforcombo
 NUMBER/* Для комбо *//* Для комбо */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from viewcolumn where viewcolumnID=aviewcolumnID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from viewcolumn where viewcolumnid=aviewcolumnID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:viewcolumn',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=viewcolumn');
      return;
    end if;
  end if;
 --  verify lock  --
 viewcolumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aviewcolumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=viewcolumn');
    return;
  end if;
 -- update row  --
 update  viewcolumn set ChangeStamp=sysdate
,
  sequence=asequence
,
  name=aname
,
  the_alias=athe_alias
,
  frompart=afrompart
,
  field=afield
,
  aggregation=aaggregation
,
  expression=aexpression
,
  forcombo=aforcombo
  where  viewcolumnID = aviewcolumnID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from partview where partviewid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:viewcolumn',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=viewcolumn');
      return;
    end if;
 end if;
 partview_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=viewcolumn');
    return;
  end if;
 insert into   viewcolumn
 (  viewcolumnID 
,ParentStructRowID
,sequence

,name

,the_alias

,frompart

,field

,aggregation

,expression

,forcombo

 ) values ( aviewcolumnID 
,aParentStructRowID
,asequence

,aname

,athe_alias

,afrompart

,afield

,aaggregation

,aexpression

,aforcombo

 ); 
 viewcolumn_SINIT( aCURSESSION,aviewcolumnid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure viewcolumn_PARENT /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from viewcolumn where  viewcolumnid=aRowID;
  aParentTable := 'partview';
 end; 

procedure viewcolumn_ISLOCKED /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from viewcolumn where viewcolumnid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  viewcolumn_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure viewcolumn_LOCK /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 viewcolumn_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  viewcolumn_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from viewcolumn where viewcolumnid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=viewcolumn');
    return;
  end if;
   if  aLockMode =2  
   then   
    update viewcolumn set LockUserID =auserID ,LockSessionID =null where viewcolumnid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update viewcolumn set LockUserID =null,LockSessionID =aCURSESSION  where viewcolumnid=aRowID;
     return;
   end if;
 end ;

procedure viewcolumn_HCL /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure viewcolumn_UNLOCK /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 viewcolumn_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update viewcolumn set LockUserID =null  where viewcolumnid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update viewcolumn set LockSessionID =null  where viewcolumnid=aRowID;
     return;
   end if;
 end; 

procedure viewcolumn_SINIT /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from viewcolumn where viewcolumnid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =viewcolumn');
    return;
  end if;
if aSecurityStyleID is null then
 viewcolumn_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update viewcolumn set securitystyleid =aStyleID where viewcolumnid = aRowID;
else 
 update viewcolumn set securitystyleid =aSecurityStyleID where viewcolumnid = aRowID;
end if; 
end ; 

procedure viewcolumn_propagate /*Колонка пердставления*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from viewcolumn where viewcolumnid=aRowid;
end;


procedure partview_lnk_BRIEF  (
 aCURSESSION CHAR,
 apartview_lnkid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if apartview_lnkid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from partview_lnk where partview_lnkID=apartview_lnkID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from partview_lnk where partview_lnkid=apartview_lnkID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=partview_lnk');
    return;
  end if;
  aBRIEF:=func.partview_lnk_BRIEF_F(apartview_lnkid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure partview_lnk_DELETE /**/ (
 aCURSESSION CHAR,
 apartview_lnkid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from partview_lnk where partview_lnkID=apartview_lnkID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from partview_lnk where partview_lnkid=apartview_lnkID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:partview_lnk',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=partview_lnk');
      return;
    end if;
  end if;
 --  verify lock  --
 partview_lnk_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartview_lnkid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=partview_lnk');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_partview_lnk is select  instanceid ID from instance where OwnerPartName ='partview_lnk' and OwnerRowID=apartview_lnkid;
row_partview_lnk  chld_partview_lnk%ROWTYPE;
begin
--open chld_partview_lnk;
for row_partview_lnk in chld_partview_lnk loop
 Kernel.INSTANCE_OWNER (acursession,row_partview_lnk.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_partview_lnk.id);
end loop;
--close chld_partview_lnk;
end ;
  delete from  partview_lnk 
  where  partview_lnkID = apartview_lnkID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Связанные представления*/
procedure partview_lnk_SAVE /**/ (
 aCURSESSION CHAR,
 apartview_lnkid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atheview CHAR/* Представление *//* Представление */
,athejoinsource CHAR := null /* Связь: Поле для join источник *//* Связь: Поле для join источник */
,areftype
 NUMBER/* Связывать как *//* Связывать как */
,athejoindestination CHAR := null /* Свзяь: Поле для join приемник *//* Свзяь: Поле для join приемник */
,ahandjoin
 VARCHAR2 := null /* Ручной join *//* Ручной join */
,aseq
 NUMBER/* Порядок *//* Порядок */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from partview_lnk where partview_lnkID=apartview_lnkID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from partview_lnk where partview_lnkid=apartview_lnkID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:partview_lnk',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=partview_lnk');
      return;
    end if;
  end if;
 --  verify lock  --
 partview_lnk_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;apartview_lnkid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partview_lnk');
    return;
  end if;
 -- update row  --
 update  partview_lnk set ChangeStamp=sysdate
,
  theview=atheview
,
  thejoinsource=athejoinsource
,
  reftype=areftype
,
  thejoindestination=athejoindestination
,
  handjoin=ahandjoin
,
  seq=aseq
  where  partview_lnkID = apartview_lnkID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from partview where partviewid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:partview_lnk',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=partview_lnk');
      return;
    end if;
 end if;
 partview_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=partview_lnk');
    return;
  end if;
 insert into   partview_lnk
 (  partview_lnkID 
,ParentStructRowID
,theview

,thejoinsource

,reftype

,thejoindestination

,handjoin

,seq

 ) values ( apartview_lnkID 
,aParentStructRowID
,atheview

,athejoinsource

,areftype

,athejoindestination

,ahandjoin

,aseq

 ); 
 partview_lnk_SINIT( aCURSESSION,apartview_lnkid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure partview_lnk_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from partview_lnk where  partview_lnkid=aRowID;
  aParentTable := 'partview';
 end; 

procedure partview_lnk_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from partview_lnk where partview_lnkid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  partview_lnk_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure partview_lnk_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 partview_lnk_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  partview_lnk_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from partview_lnk where partview_lnkid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=partview_lnk');
    return;
  end if;
   if  aLockMode =2  
   then   
    update partview_lnk set LockUserID =auserID ,LockSessionID =null where partview_lnkid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update partview_lnk set LockUserID =null,LockSessionID =aCURSESSION  where partview_lnkid=aRowID;
     return;
   end if;
 end ;

procedure partview_lnk_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure partview_lnk_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 partview_lnk_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update partview_lnk set LockUserID =null  where partview_lnkid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update partview_lnk set LockSessionID =null  where partview_lnkid=aRowID;
     return;
   end if;
 end; 

procedure partview_lnk_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from partview_lnk where partview_lnkid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =partview_lnk');
    return;
  end if;
if aSecurityStyleID is null then
 partview_lnk_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update partview_lnk set securitystyleid =aStyleID where partview_lnkid = aRowID;
else 
 update partview_lnk set securitystyleid =aSecurityStyleID where partview_lnkid = aRowID;
end if; 
end ; 

procedure partview_lnk_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from partview_lnk where partview_lnkid=aRowid;
end;


procedure validator_BRIEF  (
 aCURSESSION CHAR,
 avalidatorid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if avalidatorid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from validator where validatorID=avalidatorID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from validator where validatorid=avalidatorID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=validator');
    return;
  end if;
  aBRIEF:=func.validator_BRIEF_F(avalidatorid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure validator_DELETE /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 avalidatorid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from validator where validatorID=avalidatorID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from validator where validatorid=avalidatorID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:validator',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=validator');
      return;
    end if;
  end if;
 --  verify lock  --
 validator_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;avalidatorid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=validator');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_validator is select  instanceid ID from instance where OwnerPartName ='validator' and OwnerRowID=avalidatorid;
row_validator  chld_validator%ROWTYPE;
begin
--open chld_validator;
for row_validator in chld_validator loop
 Kernel.INSTANCE_OWNER (acursession,row_validator.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_validator.id);
end loop;
--close chld_validator;
end ;
  delete from  validator 
  where  validatorID = avalidatorID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Логика на форме*/
procedure validator_SAVE /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 avalidatorid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Целевая платформа *//* Целевая платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from validator where validatorID=avalidatorID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from validator where validatorid=avalidatorID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:validator',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=validator');
      return;
    end if;
  end if;
 --  verify lock  --
 validator_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;avalidatorid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=validator');
    return;
  end if;
 -- update row  --
 update  validator set ChangeStamp=sysdate
,
  target=atarget
,
  code=acode
  where  validatorID = avalidatorID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from part where partid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:validator',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=validator');
      return;
    end if;
 end if;
 part_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=validator');
    return;
  end if;
 insert into   validator
 (  validatorID 
,ParentStructRowID
,target

,code

 ) values ( avalidatorID 
,aParentStructRowID
,atarget

,acode

 ); 
 validator_SINIT( aCURSESSION,avalidatorid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure validator_PARENT /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from validator where  validatorid=aRowID;
  aParentTable := 'part';
 end; 

procedure validator_ISLOCKED /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from validator where validatorid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  validator_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure validator_LOCK /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 validator_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  validator_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from validator where validatorid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=validator');
    return;
  end if;
   if  aLockMode =2  
   then   
    update validator set LockUserID =auserID ,LockSessionID =null where validatorid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update validator set LockUserID =null,LockSessionID =aCURSESSION  where validatorid=aRowID;
     return;
   end if;
 end ;

procedure validator_HCL /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure validator_UNLOCK /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 validator_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update validator set LockUserID =null  where validatorid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update validator set LockSessionID =null  where validatorid=aRowID;
     return;
   end if;
 end; 

procedure validator_SINIT /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from validator where validatorid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =validator');
    return;
  end if;
if aSecurityStyleID is null then
 validator_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update validator set securitystyleid =aStyleID where validatorid = aRowID;
else 
 update validator set securitystyleid =aSecurityStyleID where validatorid = aRowID;
end if; 
end ; 

procedure validator_propagate /*Действия в впроцессе редактирования*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from validator where validatorid=aRowid;
end;


procedure uniqueconstraint_BRIEF  (
 aCURSESSION CHAR,
 auniqueconstraintid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if auniqueconstraintid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from uniqueconstraint where uniqueconstraintID=auniqueconstraintID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from uniqueconstraint where uniqueconstraintid=auniqueconstraintID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=uniqueconstraint');
    return;
  end if;
  aBRIEF:=func.uniqueconstraint_BRIEF_F(auniqueconstraintid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure uniqueconstraint_DELETE /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 auniqueconstraintid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from uniqueconstraint where uniqueconstraintID=auniqueconstraintID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from uniqueconstraint where uniqueconstraintid=auniqueconstraintID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:uniqueconstraint',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=uniqueconstraint');
      return;
    end if;
  end if;
 --  verify lock  --
 uniqueconstraint_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;auniqueconstraintid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=uniqueconstraint');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_constraintfield is select constraintfield.constraintfieldid ID from constraintfield where  constraintfield.ParentStructRowID = auniqueconstraintid;
    child_constraintfield_rec  child_constraintfield%ROWTYPE;
    begin
    --open child_constraintfield;
      for child_constraintfield_rec in child_constraintfield loop
      constraintfield_DELETE (acursession,child_constraintfield_rec.id,aInstanceid);
      end loop;
      --close child_constraintfield;
    end ;
declare cursor chld_uniqueconstraint is select  instanceid ID from instance where OwnerPartName ='uniqueconstraint' and OwnerRowID=auniqueconstraintid;
row_uniqueconstraint  chld_uniqueconstraint%ROWTYPE;
begin
--open chld_uniqueconstraint;
for row_uniqueconstraint in chld_uniqueconstraint loop
 Kernel.INSTANCE_OWNER (acursession,row_uniqueconstraint.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_uniqueconstraint.id);
end loop;
--close chld_uniqueconstraint;
end ;
  delete from  uniqueconstraint 
  where  uniqueconstraintID = auniqueconstraintID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Ограничение уникальности*/
procedure uniqueconstraint_SAVE /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 auniqueconstraintid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aperparent
 NUMBER/* По родителю *//* По родителю */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from uniqueconstraint where uniqueconstraintID=auniqueconstraintID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from uniqueconstraint where uniqueconstraintid=auniqueconstraintID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:uniqueconstraint',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=uniqueconstraint');
      return;
    end if;
  end if;
 --  verify lock  --
 uniqueconstraint_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;auniqueconstraintid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=uniqueconstraint');
    return;
  end if;
 -- update row  --
 update  uniqueconstraint set ChangeStamp=sysdate
,
  name=aname
,
  perparent=aperparent
,
  thecomment=athecomment
  where  uniqueconstraintID = auniqueconstraintID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from part where partid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:uniqueconstraint',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=uniqueconstraint');
      return;
    end if;
 end if;
 part_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=uniqueconstraint');
    return;
  end if;
 insert into   uniqueconstraint
 (  uniqueconstraintID 
,ParentStructRowID
,name

,perparent

,thecomment

 ) values ( auniqueconstraintID 
,aParentStructRowID
,aname

,aperparent

,athecomment

 ); 
 uniqueconstraint_SINIT( aCURSESSION,auniqueconstraintid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure uniqueconstraint_PARENT /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from uniqueconstraint where  uniqueconstraintid=aRowID;
  aParentTable := 'part';
 end; 

procedure uniqueconstraint_ISLOCKED /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from uniqueconstraint where uniqueconstraintid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  uniqueconstraint_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure uniqueconstraint_LOCK /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 uniqueconstraint_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  uniqueconstraint_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from uniqueconstraint where uniqueconstraintid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=uniqueconstraint');
    return;
  end if;
   if  aLockMode =2  
   then   
    update uniqueconstraint set LockUserID =auserID ,LockSessionID =null where uniqueconstraintid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update uniqueconstraint set LockUserID =null,LockSessionID =aCURSESSION  where uniqueconstraintid=aRowID;
     return;
   end if;
 end ;

procedure uniqueconstraint_HCL /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_constraintfield is select constraintfield.constraintfieldid ID from constraintfield where  constraintfield.ParentStructRowID = aRowid;
row_constraintfield lch_constraintfield%ROWTYPE;
begin  
--open lch_constraintfield;
for row_constraintfield in lch_constraintfield
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from constraintfield where constraintfieldid=row_constraintfield.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_constraintfield;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_constraintfield;
     return;
   end if; 
 end if;  
 constraintfield_HCL (acursession,row_constraintfield.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_constraintfield;
   return;
 end if;
end loop;
--close lch_constraintfield;
end;
aIsLocked :=0;
end;

procedure uniqueconstraint_UNLOCK /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 uniqueconstraint_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update uniqueconstraint set LockUserID =null  where uniqueconstraintid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update uniqueconstraint set LockSessionID =null  where uniqueconstraintid=aRowID;
     return;
   end if;
 end; 

procedure uniqueconstraint_SINIT /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from uniqueconstraint where uniqueconstraintid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =uniqueconstraint');
    return;
  end if;
if aSecurityStyleID is null then
 uniqueconstraint_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update uniqueconstraint set securitystyleid =aStyleID where uniqueconstraintid = aRowID;
else 
 update uniqueconstraint set securitystyleid =aSecurityStyleID where uniqueconstraintid = aRowID;
end if; 
end ; 

procedure uniqueconstraint_propagate /*Ограничение уникальности*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from uniqueconstraint where uniqueconstraintid=aRowid;
declare cursor pch_constraintfield  is select constraintfield.constraintfieldid ID from constraintfield where  constraintfield.ParentStructRowID = aRowid;
row_constraintfield  pch_constraintfield%ROWTYPE;
begin
--open pch_constraintfield;
for row_constraintfield in pch_constraintfield loop
   constraintfield_SINIT( acursession,row_constraintfield.id,assid);
   constraintfield_propagate( acursession,row_constraintfield.id);
end loop;
--close pch_constraintfield;
end;
end;


procedure constraintfield_BRIEF  (
 aCURSESSION CHAR,
 aconstraintfieldid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aconstraintfieldid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from constraintfield where constraintfieldID=aconstraintfieldID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from constraintfield where constraintfieldid=aconstraintfieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=constraintfield');
    return;
  end if;
  aBRIEF:=func.constraintfield_BRIEF_F(aconstraintfieldid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure constraintfield_DELETE /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aconstraintfieldid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from constraintfield where constraintfieldID=aconstraintfieldID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from constraintfield where constraintfieldid=aconstraintfieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:constraintfield',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=constraintfield');
      return;
    end if;
  end if;
 --  verify lock  --
 constraintfield_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aconstraintfieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=constraintfield');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_constraintfield is select  instanceid ID from instance where OwnerPartName ='constraintfield' and OwnerRowID=aconstraintfieldid;
row_constraintfield  chld_constraintfield%ROWTYPE;
begin
--open chld_constraintfield;
for row_constraintfield in chld_constraintfield loop
 Kernel.INSTANCE_OWNER (acursession,row_constraintfield.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_constraintfield.id);
end loop;
--close chld_constraintfield;
end ;
  delete from  constraintfield 
  where  constraintfieldID = aconstraintfieldID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поля ограничения*/
procedure constraintfield_SAVE /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aconstraintfieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athefield CHAR/* Поле *//* Поле */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from constraintfield where constraintfieldID=aconstraintfieldID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from constraintfield where constraintfieldid=aconstraintfieldID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:constraintfield',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=constraintfield');
      return;
    end if;
  end if;
 --  verify lock  --
 constraintfield_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aconstraintfieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=constraintfield');
    return;
  end if;
 -- update row  --
 update  constraintfield set ChangeStamp=sysdate
,
  thefield=athefield
  where  constraintfieldID = aconstraintfieldID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from uniqueconstraint where uniqueconstraintid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:constraintfield',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=constraintfield');
      return;
    end if;
 end if;
 uniqueconstraint_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=constraintfield');
    return;
  end if;
 insert into   constraintfield
 (  constraintfieldID 
,ParentStructRowID
,thefield

 ) values ( aconstraintfieldID 
,aParentStructRowID
,athefield

 ); 
 constraintfield_SINIT( aCURSESSION,aconstraintfieldid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure constraintfield_PARENT /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from constraintfield where  constraintfieldid=aRowID;
  aParentTable := 'uniqueconstraint';
 end; 

procedure constraintfield_ISLOCKED /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from constraintfield where constraintfieldid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  constraintfield_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure constraintfield_LOCK /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 constraintfield_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  constraintfield_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from constraintfield where constraintfieldid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=constraintfield');
    return;
  end if;
   if  aLockMode =2  
   then   
    update constraintfield set LockUserID =auserID ,LockSessionID =null where constraintfieldid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update constraintfield set LockUserID =null,LockSessionID =aCURSESSION  where constraintfieldid=aRowID;
     return;
   end if;
 end ;

procedure constraintfield_HCL /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure constraintfield_UNLOCK /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 constraintfield_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update constraintfield set LockUserID =null  where constraintfieldid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update constraintfield set LockSessionID =null  where constraintfieldid=aRowID;
     return;
   end if;
 end; 

procedure constraintfield_SINIT /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from constraintfield where constraintfieldid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =constraintfield');
    return;
  end if;
if aSecurityStyleID is null then
 constraintfield_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update constraintfield set securitystyleid =aStyleID where constraintfieldid = aRowID;
else 
 update constraintfield set securitystyleid =aSecurityStyleID where constraintfieldid = aRowID;
end if; 
end ; 

procedure constraintfield_propagate /*Поля ограничения*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from constraintfield where constraintfieldid=aRowid;
end;


procedure extenderinterface_BRIEF  (
 aCURSESSION CHAR,
 aextenderinterfaceid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aextenderinterfaceid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from extenderinterface where extenderinterfaceID=aextenderinterfaceID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from extenderinterface where extenderinterfaceid=aextenderinterfaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=extenderinterface');
    return;
  end if;
  aBRIEF:=func.extenderinterface_BRIEF_F(aextenderinterfaceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure extenderinterface_DELETE /**/ (
 aCURSESSION CHAR,
 aextenderinterfaceid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from extenderinterface where extenderinterfaceID=aextenderinterfaceID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from extenderinterface where extenderinterfaceid=aextenderinterfaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:extenderinterface',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=extenderinterface');
      return;
    end if;
  end if;
 --  verify lock  --
 extenderinterface_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aextenderinterfaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=extenderinterface');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_extenderinterface is select  instanceid ID from instance where OwnerPartName ='extenderinterface' and OwnerRowID=aextenderinterfaceid;
row_extenderinterface  chld_extenderinterface%ROWTYPE;
begin
--open chld_extenderinterface;
for row_extenderinterface in chld_extenderinterface loop
 Kernel.INSTANCE_OWNER (acursession,row_extenderinterface.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_extenderinterface.id);
end loop;
--close chld_extenderinterface;
end ;
  delete from  extenderinterface 
  where  extenderinterfaceID = aextenderinterfaceID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Интерфейсы расширения*/
procedure extenderinterface_SAVE /**/ (
 aCURSESSION CHAR,
 aextenderinterfaceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athename
 VARCHAR2/* Название *//* Название */
,atargetplatform CHAR/* Целевая платформа *//* Целевая платформа */
,atheobject
 VARCHAR2/* Объект *//* Объект */
,atheconfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from extenderinterface where extenderinterfaceID=aextenderinterfaceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from extenderinterface where extenderinterfaceid=aextenderinterfaceID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:extenderinterface',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=extenderinterface');
      return;
    end if;
  end if;
 --  verify lock  --
 extenderinterface_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aextenderinterfaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=extenderinterface');
    return;
  end if;
 -- update row  --
 update  extenderinterface set ChangeStamp=sysdate
,
  thename=athename
,
  targetplatform=atargetplatform
,
  theobject=atheobject
,
  theconfig=atheconfig
  where  extenderinterfaceID = aextenderinterfaceID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from part where partid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:extenderinterface',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=extenderinterface');
      return;
    end if;
 end if;
 part_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=extenderinterface');
    return;
  end if;
 insert into   extenderinterface
 (  extenderinterfaceID 
,ParentStructRowID
,thename

,targetplatform

,theobject

,theconfig

 ) values ( aextenderinterfaceID 
,aParentStructRowID
,athename

,atargetplatform

,atheobject

,atheconfig

 ); 
 extenderinterface_SINIT( aCURSESSION,aextenderinterfaceid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure extenderinterface_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from extenderinterface where  extenderinterfaceid=aRowID;
  aParentTable := 'part';
 end; 

procedure extenderinterface_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from extenderinterface where extenderinterfaceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  extenderinterface_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure extenderinterface_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 extenderinterface_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  extenderinterface_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from extenderinterface where extenderinterfaceid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=extenderinterface');
    return;
  end if;
   if  aLockMode =2  
   then   
    update extenderinterface set LockUserID =auserID ,LockSessionID =null where extenderinterfaceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update extenderinterface set LockUserID =null,LockSessionID =aCURSESSION  where extenderinterfaceid=aRowID;
     return;
   end if;
 end ;

procedure extenderinterface_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure extenderinterface_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 extenderinterface_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update extenderinterface set LockUserID =null  where extenderinterfaceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update extenderinterface set LockSessionID =null  where extenderinterfaceid=aRowID;
     return;
   end if;
 end; 

procedure extenderinterface_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from extenderinterface where extenderinterfaceid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =extenderinterface');
    return;
  end if;
if aSecurityStyleID is null then
 extenderinterface_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update extenderinterface set securitystyleid =aStyleID where extenderinterfaceid = aRowID;
else 
 update extenderinterface set securitystyleid =aSecurityStyleID where extenderinterfaceid = aRowID;
end if; 
end ; 

procedure extenderinterface_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from extenderinterface where extenderinterfaceid=aRowid;
end;


procedure field_BRIEF  (
 aCURSESSION CHAR,
 afieldid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from field where fieldID=afieldID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from field where fieldid=afieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=field');
    return;
  end if;
  aBRIEF:=func.field_BRIEF_F(afieldid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure field_DELETE /*Поле*/ (
 aCURSESSION CHAR,
 afieldid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from field where fieldID=afieldID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from field where fieldid=afieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:field',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=field');
      return;
    end if;
  end if;
 --  verify lock  --
 field_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=field');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_fldextenders is select fldextenders.fldextendersid ID from fldextenders where  fldextenders.ParentStructRowID = afieldid;
    child_fldextenders_rec  child_fldextenders%ROWTYPE;
    begin
    --open child_fldextenders;
      for child_fldextenders_rec in child_fldextenders loop
      fldextenders_DELETE (acursession,child_fldextenders_rec.id,aInstanceid);
      end loop;
      --close child_fldextenders;
    end ;
    declare cursor child_fieldsrcdef is select fieldsrcdef.fieldsrcdefid ID from fieldsrcdef where  fieldsrcdef.ParentStructRowID = afieldid;
    child_fieldsrcdef_rec  child_fieldsrcdef%ROWTYPE;
    begin
    --open child_fieldsrcdef;
      for child_fieldsrcdef_rec in child_fieldsrcdef loop
      fieldsrcdef_DELETE (acursession,child_fieldsrcdef_rec.id,aInstanceid);
      end loop;
      --close child_fieldsrcdef;
    end ;
    declare cursor child_dinamicfilterscript is select dinamicfilterscript.dinamicfilterscriptid ID from dinamicfilterscript where  dinamicfilterscript.ParentStructRowID = afieldid;
    child_dinamicfilterscript_rec  child_dinamicfilterscript%ROWTYPE;
    begin
    --open child_dinamicfilterscript;
      for child_dinamicfilterscript_rec in child_dinamicfilterscript loop
      dinamicfilterscript_DELETE (acursession,child_dinamicfilterscript_rec.id,aInstanceid);
      end loop;
      --close child_dinamicfilterscript;
    end ;
    declare cursor child_fieldexpression is select fieldexpression.fieldexpressionid ID from fieldexpression where  fieldexpression.ParentStructRowID = afieldid;
    child_fieldexpression_rec  child_fieldexpression%ROWTYPE;
    begin
    --open child_fieldexpression;
      for child_fieldexpression_rec in child_fieldexpression loop
      fieldexpression_DELETE (acursession,child_fieldexpression_rec.id,aInstanceid);
      end loop;
      --close child_fieldexpression;
    end ;
    declare cursor child_fieldvalidator is select fieldvalidator.fieldvalidatorid ID from fieldvalidator where  fieldvalidator.ParentStructRowID = afieldid;
    child_fieldvalidator_rec  child_fieldvalidator%ROWTYPE;
    begin
    --open child_fieldvalidator;
      for child_fieldvalidator_rec in child_fieldvalidator loop
      fieldvalidator_DELETE (acursession,child_fieldvalidator_rec.id,aInstanceid);
      end loop;
      --close child_fieldvalidator;
    end ;
    declare cursor child_fieldmenu is select fieldmenu.fieldmenuid ID from fieldmenu where  fieldmenu.ParentStructRowID = afieldid;
    child_fieldmenu_rec  child_fieldmenu%ROWTYPE;
    begin
    --open child_fieldmenu;
      for child_fieldmenu_rec in child_fieldmenu loop
      fieldmenu_DELETE (acursession,child_fieldmenu_rec.id,aInstanceid);
      end loop;
      --close child_fieldmenu;
    end ;
declare cursor chld_field is select  instanceid ID from instance where OwnerPartName ='field' and OwnerRowID=afieldid;
row_field  chld_field%ROWTYPE;
begin
--open chld_field;
for row_field in chld_field loop
 Kernel.INSTANCE_OWNER (acursession,row_field.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_field.id);
end loop;
--close chld_field;
end ;
  delete from  field 
  where  fieldID = afieldID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поле*/
procedure field_SAVE /*Поле*/ (
 aCURSESSION CHAR,
 afieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atabname
 VARCHAR2 := null /* Имя вкладки *//* Имя вкладки */
,afieldgroupbox
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,asequence
 NUMBER/* № п/п *//* № п/п */
,acaption
 VARCHAR2/* Надпись *//* Надпись */
,aname
 VARCHAR2/* Имя поля *//* Имя поля */
,afieldtype CHAR/* Тип поля *//* Тип поля */
,aisbrief
 NUMBER/* Краткая информация *//* Краткая информация */
,aistabbrief
 NUMBER/* Для отображения в таблице *//* Для отображения в таблице */
,aallownull
 NUMBER/* Может быть пустым *//* Может быть пустым */
,adatasize
 NUMBER := null /* Размер поля *//* Размер поля */
,areferencetype
 NUMBER/* Тип ссылки *//* Тип ссылки */
,areftotype CHAR := null /* Ссылка на тип *//* Ссылка на тип */
,areftopart CHAR := null /* Ссылка на раздел *//* Ссылка на раздел */
,athestyle
 VARCHAR2 := null /* Стиль *//* Стиль */
,ainternalreference
 NUMBER/* Ссылка в пределах объекта *//* Ссылка в пределах объекта */
,acreaterefonly
 NUMBER/* Только создание объекта *//* Только создание объекта */
,aisautonumber
 NUMBER/* Автонумерация *//* Автонумерация */
,athenumerator CHAR := null /* Нумератор *//* Нумератор */
,azonetemplate
 VARCHAR2 := null /* Шаблон зоны нумерации *//* Шаблон зоны нумерации */
,anumberdatefield CHAR := null /* Поле для расчета даты *//* Поле для расчета даты */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,ashablonbrief
 VARCHAR2 := null /* Шаблон для краткого отображения *//* Шаблон для краткого отображения */
,athenameclass
 VARCHAR2 := null /* Имя класса для мастера строк *//* Имя класса для мастера строк */
,athemask
 VARCHAR2 := null /* Маска *//* Маска */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from field where fieldID=afieldID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from field where fieldid=afieldID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:field',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=field');
      return;
    end if;
  end if;
 --  verify lock  --
 field_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=field');
    return;
  end if;
 -- update row  --
 update  field set ChangeStamp=sysdate
,
  tabname=atabname
,
  fieldgroupbox=afieldgroupbox
,
  sequence=asequence
,
  caption=acaption
,
  name=aname
,
  fieldtype=afieldtype
,
  isbrief=aisbrief
,
  istabbrief=aistabbrief
,
  allownull=aallownull
,
  datasize=adatasize
,
  referencetype=areferencetype
,
  reftotype=areftotype
,
  reftopart=areftopart
,
  thestyle=athestyle
,
  internalreference=ainternalreference
,
  createrefonly=acreaterefonly
,
  isautonumber=aisautonumber
,
  thenumerator=athenumerator
,
  zonetemplate=azonetemplate
,
  numberdatefield=anumberdatefield
,
  thecomment=athecomment
,
  shablonbrief=ashablonbrief
,
  thenameclass=athenameclass
,
  themask=athemask
  where  fieldID = afieldID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from field where ParentStructRowID=aParentStructRowID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=field');
 return;
end if;
select Count(*) into aUniqueRowCount from field where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=field');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from part where partid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:field',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=field');
      return;
    end if;
 end if;
 part_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=field');
    return;
  end if;
 insert into   field
 (  fieldID 
,ParentStructRowID
,tabname

,fieldgroupbox

,sequence

,caption

,name

,fieldtype

,isbrief

,istabbrief

,allownull

,datasize

,referencetype

,reftotype

,reftopart

,thestyle

,internalreference

,createrefonly

,isautonumber

,thenumerator

,zonetemplate

,numberdatefield

,thecomment

,shablonbrief

,thenameclass

,themask

 ) values ( afieldID 
,aParentStructRowID
,atabname

,afieldgroupbox

,asequence

,acaption

,aname

,afieldtype

,aisbrief

,aistabbrief

,aallownull

,adatasize

,areferencetype

,areftotype

,areftopart

,athestyle

,ainternalreference

,acreaterefonly

,aisautonumber

,athenumerator

,azonetemplate

,anumberdatefield

,athecomment

,ashablonbrief

,athenameclass

,athemask

 ); 
 field_SINIT( aCURSESSION,afieldid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from field where ParentStructRowID=aParentStructRowID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=field');
 return;
end if;
select Count(*) into aUniqueRowCount from field where ParentStructRowID=aParentStructRowID 
 and sequence=asequence;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=field');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure field_PARENT /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from field where  fieldid=aRowID;
  aParentTable := 'part';
 end; 

procedure field_ISLOCKED /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from field where fieldid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  field_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure field_LOCK /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 field_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  field_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from field where fieldid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=field');
    return;
  end if;
   if  aLockMode =2  
   then   
    update field set LockUserID =auserID ,LockSessionID =null where fieldid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update field set LockUserID =null,LockSessionID =aCURSESSION  where fieldid=aRowID;
     return;
   end if;
 end ;

procedure field_HCL /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_fldextenders is select fldextenders.fldextendersid ID from fldextenders where  fldextenders.ParentStructRowID = aRowid;
row_fldextenders lch_fldextenders%ROWTYPE;
begin  
--open lch_fldextenders;
for row_fldextenders in lch_fldextenders
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fldextenders where fldextendersid=row_fldextenders.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fldextenders;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fldextenders;
     return;
   end if; 
 end if;  
 fldextenders_HCL (acursession,row_fldextenders.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fldextenders;
   return;
 end if;
end loop;
--close lch_fldextenders;
end;
declare cursor lch_fieldsrcdef is select fieldsrcdef.fieldsrcdefid ID from fieldsrcdef where  fieldsrcdef.ParentStructRowID = aRowid;
row_fieldsrcdef lch_fieldsrcdef%ROWTYPE;
begin  
--open lch_fieldsrcdef;
for row_fieldsrcdef in lch_fieldsrcdef
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fieldsrcdef where fieldsrcdefid=row_fieldsrcdef.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldsrcdef;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fieldsrcdef;
     return;
   end if; 
 end if;  
 fieldsrcdef_HCL (acursession,row_fieldsrcdef.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldsrcdef;
   return;
 end if;
end loop;
--close lch_fieldsrcdef;
end;
declare cursor lch_dinamicfilterscript is select dinamicfilterscript.dinamicfilterscriptid ID from dinamicfilterscript where  dinamicfilterscript.ParentStructRowID = aRowid;
row_dinamicfilterscript lch_dinamicfilterscript%ROWTYPE;
begin  
--open lch_dinamicfilterscript;
for row_dinamicfilterscript in lch_dinamicfilterscript
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from dinamicfilterscript where dinamicfilterscriptid=row_dinamicfilterscript.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_dinamicfilterscript;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_dinamicfilterscript;
     return;
   end if; 
 end if;  
 dinamicfilterscript_HCL (acursession,row_dinamicfilterscript.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_dinamicfilterscript;
   return;
 end if;
end loop;
--close lch_dinamicfilterscript;
end;
declare cursor lch_fieldexpression is select fieldexpression.fieldexpressionid ID from fieldexpression where  fieldexpression.ParentStructRowID = aRowid;
row_fieldexpression lch_fieldexpression%ROWTYPE;
begin  
--open lch_fieldexpression;
for row_fieldexpression in lch_fieldexpression
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fieldexpression where fieldexpressionid=row_fieldexpression.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldexpression;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fieldexpression;
     return;
   end if; 
 end if;  
 fieldexpression_HCL (acursession,row_fieldexpression.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldexpression;
   return;
 end if;
end loop;
--close lch_fieldexpression;
end;
declare cursor lch_fieldvalidator is select fieldvalidator.fieldvalidatorid ID from fieldvalidator where  fieldvalidator.ParentStructRowID = aRowid;
row_fieldvalidator lch_fieldvalidator%ROWTYPE;
begin  
--open lch_fieldvalidator;
for row_fieldvalidator in lch_fieldvalidator
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fieldvalidator where fieldvalidatorid=row_fieldvalidator.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldvalidator;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fieldvalidator;
     return;
   end if; 
 end if;  
 fieldvalidator_HCL (acursession,row_fieldvalidator.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldvalidator;
   return;
 end if;
end loop;
--close lch_fieldvalidator;
end;
declare cursor lch_fieldmenu is select fieldmenu.fieldmenuid ID from fieldmenu where  fieldmenu.ParentStructRowID = aRowid;
row_fieldmenu lch_fieldmenu%ROWTYPE;
begin  
--open lch_fieldmenu;
for row_fieldmenu in lch_fieldmenu
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fieldmenu where fieldmenuid=row_fieldmenu.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldmenu;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fieldmenu;
     return;
   end if; 
 end if;  
 fieldmenu_HCL (acursession,row_fieldmenu.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldmenu;
   return;
 end if;
end loop;
--close lch_fieldmenu;
end;
aIsLocked :=0;
end;

procedure field_UNLOCK /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 field_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update field set LockUserID =null  where fieldid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update field set LockSessionID =null  where fieldid=aRowID;
     return;
   end if;
 end; 

procedure field_SINIT /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from field where fieldid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =field');
    return;
  end if;
if aSecurityStyleID is null then
 field_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update field set securitystyleid =aStyleID where fieldid = aRowID;
else 
 update field set securitystyleid =aSecurityStyleID where fieldid = aRowID;
end if; 
end ; 

procedure field_propagate /*Поле*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from field where fieldid=aRowid;
declare cursor pch_fldextenders  is select fldextenders.fldextendersid ID from fldextenders where  fldextenders.ParentStructRowID = aRowid;
row_fldextenders  pch_fldextenders%ROWTYPE;
begin
--open pch_fldextenders;
for row_fldextenders in pch_fldextenders loop
   fldextenders_SINIT( acursession,row_fldextenders.id,assid);
   fldextenders_propagate( acursession,row_fldextenders.id);
end loop;
--close pch_fldextenders;
end;
declare cursor pch_fieldsrcdef  is select fieldsrcdef.fieldsrcdefid ID from fieldsrcdef where  fieldsrcdef.ParentStructRowID = aRowid;
row_fieldsrcdef  pch_fieldsrcdef%ROWTYPE;
begin
--open pch_fieldsrcdef;
for row_fieldsrcdef in pch_fieldsrcdef loop
   fieldsrcdef_SINIT( acursession,row_fieldsrcdef.id,assid);
   fieldsrcdef_propagate( acursession,row_fieldsrcdef.id);
end loop;
--close pch_fieldsrcdef;
end;
declare cursor pch_dinamicfilterscript  is select dinamicfilterscript.dinamicfilterscriptid ID from dinamicfilterscript where  dinamicfilterscript.ParentStructRowID = aRowid;
row_dinamicfilterscript  pch_dinamicfilterscript%ROWTYPE;
begin
--open pch_dinamicfilterscript;
for row_dinamicfilterscript in pch_dinamicfilterscript loop
   dinamicfilterscript_SINIT( acursession,row_dinamicfilterscript.id,assid);
   dinamicfilterscript_propagate( acursession,row_dinamicfilterscript.id);
end loop;
--close pch_dinamicfilterscript;
end;
declare cursor pch_fieldexpression  is select fieldexpression.fieldexpressionid ID from fieldexpression where  fieldexpression.ParentStructRowID = aRowid;
row_fieldexpression  pch_fieldexpression%ROWTYPE;
begin
--open pch_fieldexpression;
for row_fieldexpression in pch_fieldexpression loop
   fieldexpression_SINIT( acursession,row_fieldexpression.id,assid);
   fieldexpression_propagate( acursession,row_fieldexpression.id);
end loop;
--close pch_fieldexpression;
end;
declare cursor pch_fieldvalidator  is select fieldvalidator.fieldvalidatorid ID from fieldvalidator where  fieldvalidator.ParentStructRowID = aRowid;
row_fieldvalidator  pch_fieldvalidator%ROWTYPE;
begin
--open pch_fieldvalidator;
for row_fieldvalidator in pch_fieldvalidator loop
   fieldvalidator_SINIT( acursession,row_fieldvalidator.id,assid);
   fieldvalidator_propagate( acursession,row_fieldvalidator.id);
end loop;
--close pch_fieldvalidator;
end;
declare cursor pch_fieldmenu  is select fieldmenu.fieldmenuid ID from fieldmenu where  fieldmenu.ParentStructRowID = aRowid;
row_fieldmenu  pch_fieldmenu%ROWTYPE;
begin
--open pch_fieldmenu;
for row_fieldmenu in pch_fieldmenu loop
   fieldmenu_SINIT( acursession,row_fieldmenu.id,assid);
   fieldmenu_propagate( acursession,row_fieldmenu.id);
end loop;
--close pch_fieldmenu;
end;
end;


procedure fldextenders_BRIEF  (
 aCURSESSION CHAR,
 afldextendersid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afldextendersid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fldextenders where fldextendersID=afldextendersID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fldextenders where fldextendersid=afldextendersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fldextenders');
    return;
  end if;
  aBRIEF:=func.fldextenders_BRIEF_F(afldextendersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fldextenders_DELETE /**/ (
 aCURSESSION CHAR,
 afldextendersid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fldextenders where fldextendersID=afldextendersID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fldextenders where fldextendersid=afldextendersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fldextenders',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fldextenders');
      return;
    end if;
  end if;
 --  verify lock  --
 fldextenders_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afldextendersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fldextenders');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fldextenders is select  instanceid ID from instance where OwnerPartName ='fldextenders' and OwnerRowID=afldextendersid;
row_fldextenders  chld_fldextenders%ROWTYPE;
begin
--open chld_fldextenders;
for row_fldextenders in chld_fldextenders loop
 Kernel.INSTANCE_OWNER (acursession,row_fldextenders.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fldextenders.id);
end loop;
--close chld_fldextenders;
end ;
  delete from  fldextenders 
  where  fldextendersID = afldextendersID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Интерфейсы расширения*/
procedure fldextenders_SAVE /**/ (
 aCURSESSION CHAR,
 afldextendersid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athename
 VARCHAR2/* Название *//* Название */
,atargetplatform CHAR/* Целевая платформа *//* Целевая платформа */
,atheobject
 VARCHAR2/* Объект *//* Объект */
,atheconfig
 VARCHAR2 := null /* Конфиг *//* Конфиг */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fldextenders where fldextendersID=afldextendersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fldextenders where fldextendersid=afldextendersID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fldextenders',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fldextenders');
      return;
    end if;
  end if;
 --  verify lock  --
 fldextenders_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afldextendersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fldextenders');
    return;
  end if;
 -- update row  --
 update  fldextenders set ChangeStamp=sysdate
,
  thename=athename
,
  targetplatform=atargetplatform
,
  theobject=atheobject
,
  theconfig=atheconfig
  where  fldextendersID = afldextendersID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from field where fieldid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fldextenders',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fldextenders');
      return;
    end if;
 end if;
 field_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fldextenders');
    return;
  end if;
 insert into   fldextenders
 (  fldextendersID 
,ParentStructRowID
,thename

,targetplatform

,theobject

,theconfig

 ) values ( afldextendersID 
,aParentStructRowID
,athename

,atargetplatform

,atheobject

,atheconfig

 ); 
 fldextenders_SINIT( aCURSESSION,afldextendersid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fldextenders_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fldextenders where  fldextendersid=aRowID;
  aParentTable := 'field';
 end; 

procedure fldextenders_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fldextenders where fldextendersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fldextenders_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fldextenders_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fldextenders_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fldextenders_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fldextenders where fldextendersid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fldextenders');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fldextenders set LockUserID =auserID ,LockSessionID =null where fldextendersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fldextenders set LockUserID =null,LockSessionID =aCURSESSION  where fldextendersid=aRowID;
     return;
   end if;
 end ;

procedure fldextenders_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fldextenders_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fldextenders_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fldextenders set LockUserID =null  where fldextendersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fldextenders set LockSessionID =null  where fldextendersid=aRowID;
     return;
   end if;
 end; 

procedure fldextenders_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fldextenders where fldextendersid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fldextenders');
    return;
  end if;
if aSecurityStyleID is null then
 fldextenders_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fldextenders set securitystyleid =aStyleID where fldextendersid = aRowID;
else 
 update fldextenders set securitystyleid =aSecurityStyleID where fldextendersid = aRowID;
end if; 
end ; 

procedure fldextenders_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fldextenders where fldextendersid=aRowid;
end;


procedure fieldsrcdef_BRIEF  (
 aCURSESSION CHAR,
 afieldsrcdefid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldsrcdefid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldsrcdef where fieldsrcdefID=afieldsrcdefID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldsrcdef where fieldsrcdefid=afieldsrcdefID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldsrcdef');
    return;
  end if;
  aBRIEF:=func.fieldsrcdef_BRIEF_F(afieldsrcdefid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldsrcdef_DELETE /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 afieldsrcdefid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldsrcdef where fieldsrcdefID=afieldsrcdefID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldsrcdef where fieldsrcdefid=afieldsrcdefID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldsrcdef',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldsrcdef');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldsrcdef_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldsrcdefid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldsrcdef');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fieldsrcdef is select  instanceid ID from instance where OwnerPartName ='fieldsrcdef' and OwnerRowID=afieldsrcdefid;
row_fieldsrcdef  chld_fieldsrcdef%ROWTYPE;
begin
--open chld_fieldsrcdef;
for row_fieldsrcdef in chld_fieldsrcdef loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldsrcdef.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldsrcdef.id);
end loop;
--close chld_fieldsrcdef;
end ;
  delete from  fieldsrcdef 
  where  fieldsrcdefID = afieldsrcdefID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание источника данных*/
procedure fieldsrcdef_SAVE /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 afieldsrcdefid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aprovider
 VARCHAR2 := null /* Провайдер *//* Провайдер */
,aconnectionstring
 VARCHAR2 := null /* Строка соединения с источником *//* Строка соединения с источником */
,adatasource
 VARCHAR2/* Источник данных *//* Источник данных */
,aidfield
 VARCHAR2 := null /* ID *//* ID */
,abriefstring
 VARCHAR2 := null /* Источник краткой информации *//* Источник краткой информации */
,afilterstring
 VARCHAR2 := null /* Фильтр источника данных *//* Фильтр источника данных */
,asortfield
 VARCHAR2 := null /* Сортировка источника данных *//* Сортировка источника данных */
,adescriptionstring VARCHAR2 := null /* Примечания *//* Примечания */
,adontshowdialog
 NUMBER := null /* Не показывать форму выбора *//* Не показывать форму выбора */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldsrcdef where fieldsrcdefID=afieldsrcdefID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldsrcdef where fieldsrcdefid=afieldsrcdefID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldsrcdef',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldsrcdef');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldsrcdef_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldsrcdefid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldsrcdef');
    return;
  end if;
 -- update row  --
 update  fieldsrcdef set ChangeStamp=sysdate
,
  provider=aprovider
,
  connectionstring=aconnectionstring
,
  datasource=adatasource
,
  idfield=aidfield
,
  briefstring=abriefstring
,
  filterstring=afilterstring
,
  sortfield=asortfield
,
  descriptionstring=adescriptionstring
,
  dontshowdialog=adontshowdialog
  where  fieldsrcdefID = afieldsrcdefID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from field where fieldid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldsrcdef',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldsrcdef');
      return;
    end if;
 end if;
 field_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldsrcdef');
    return;
  end if;
select Count(*) into existsCnt from fieldsrcdef where 
ParentStructRowID=aParentStructRowID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;fieldsrcdef&gt;');
    return;
 End if;
 insert into   fieldsrcdef
 (  fieldsrcdefID 
,ParentStructRowID
,provider

,connectionstring

,datasource

,idfield

,briefstring

,filterstring

,sortfield

,descriptionstring

,dontshowdialog

 ) values ( afieldsrcdefID 
,aParentStructRowID
,aprovider

,aconnectionstring

,adatasource

,aidfield

,abriefstring

,afilterstring

,asortfield

,adescriptionstring

,adontshowdialog

 ); 
 fieldsrcdef_SINIT( aCURSESSION,afieldsrcdefid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fieldsrcdef_PARENT /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fieldsrcdef where  fieldsrcdefid=aRowID;
  aParentTable := 'field';
 end; 

procedure fieldsrcdef_ISLOCKED /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldsrcdef where fieldsrcdefid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldsrcdef_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldsrcdef_LOCK /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldsrcdef_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldsrcdef_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldsrcdef where fieldsrcdefid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldsrcdef');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldsrcdef set LockUserID =auserID ,LockSessionID =null where fieldsrcdefid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldsrcdef set LockUserID =null,LockSessionID =aCURSESSION  where fieldsrcdefid=aRowID;
     return;
   end if;
 end ;

procedure fieldsrcdef_HCL /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fieldsrcdef_UNLOCK /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldsrcdef_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldsrcdef set LockUserID =null  where fieldsrcdefid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldsrcdef set LockSessionID =null  where fieldsrcdefid=aRowID;
     return;
   end if;
 end; 

procedure fieldsrcdef_SINIT /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldsrcdef where fieldsrcdefid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldsrcdef');
    return;
  end if;
if aSecurityStyleID is null then
 fieldsrcdef_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldsrcdef set securitystyleid =aStyleID where fieldsrcdefid = aRowID;
else 
 update fieldsrcdef set securitystyleid =aSecurityStyleID where fieldsrcdefid = aRowID;
end if; 
end ; 

procedure fieldsrcdef_propagate /*Описание источника данных для полей типа ReferenceSQL */ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldsrcdef where fieldsrcdefid=aRowid;
end;


procedure dinamicfilterscript_BRIEF  (
 aCURSESSION CHAR,
 adinamicfilterscriptid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if adinamicfilterscriptid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from dinamicfilterscript where dinamicfilterscriptID=adinamicfilterscriptID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from dinamicfilterscript where dinamicfilterscriptid=adinamicfilterscriptID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=dinamicfilterscript');
    return;
  end if;
  aBRIEF:=func.dinamicfilterscript_BRIEF_F(adinamicfilterscriptid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure dinamicfilterscript_DELETE /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 adinamicfilterscriptid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from dinamicfilterscript where dinamicfilterscriptID=adinamicfilterscriptID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from dinamicfilterscript where dinamicfilterscriptid=adinamicfilterscriptID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:dinamicfilterscript',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=dinamicfilterscript');
      return;
    end if;
  end if;
 --  verify lock  --
 dinamicfilterscript_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;adinamicfilterscriptid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=dinamicfilterscript');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_dinamicfilterscript is select  instanceid ID from instance where OwnerPartName ='dinamicfilterscript' and OwnerRowID=adinamicfilterscriptid;
row_dinamicfilterscript  chld_dinamicfilterscript%ROWTYPE;
begin
--open chld_dinamicfilterscript;
for row_dinamicfilterscript in chld_dinamicfilterscript loop
 Kernel.INSTANCE_OWNER (acursession,row_dinamicfilterscript.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_dinamicfilterscript.id);
end loop;
--close chld_dinamicfilterscript;
end ;
  delete from  dinamicfilterscript 
  where  dinamicfilterscriptID = adinamicfilterscriptID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Динамический фильтр*/
procedure dinamicfilterscript_SAVE /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 adinamicfilterscriptid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Целевая платформа *//* Целевая платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from dinamicfilterscript where dinamicfilterscriptID=adinamicfilterscriptID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from dinamicfilterscript where dinamicfilterscriptid=adinamicfilterscriptID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:dinamicfilterscript',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=dinamicfilterscript');
      return;
    end if;
  end if;
 --  verify lock  --
 dinamicfilterscript_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;adinamicfilterscriptid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=dinamicfilterscript');
    return;
  end if;
 -- update row  --
 update  dinamicfilterscript set ChangeStamp=sysdate
,
  target=atarget
,
  code=acode
  where  dinamicfilterscriptID = adinamicfilterscriptID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from field where fieldid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:dinamicfilterscript',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=dinamicfilterscript');
      return;
    end if;
 end if;
 field_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=dinamicfilterscript');
    return;
  end if;
 insert into   dinamicfilterscript
 (  dinamicfilterscriptID 
,ParentStructRowID
,target

,code

 ) values ( adinamicfilterscriptID 
,aParentStructRowID
,atarget

,acode

 ); 
 dinamicfilterscript_SINIT( aCURSESSION,adinamicfilterscriptid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure dinamicfilterscript_PARENT /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from dinamicfilterscript where  dinamicfilterscriptid=aRowID;
  aParentTable := 'field';
 end; 

procedure dinamicfilterscript_ISLOCKED /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from dinamicfilterscript where dinamicfilterscriptid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  dinamicfilterscript_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure dinamicfilterscript_LOCK /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 dinamicfilterscript_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  dinamicfilterscript_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from dinamicfilterscript where dinamicfilterscriptid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=dinamicfilterscript');
    return;
  end if;
   if  aLockMode =2  
   then   
    update dinamicfilterscript set LockUserID =auserID ,LockSessionID =null where dinamicfilterscriptid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update dinamicfilterscript set LockUserID =null,LockSessionID =aCURSESSION  where dinamicfilterscriptid=aRowID;
     return;
   end if;
 end ;

procedure dinamicfilterscript_HCL /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure dinamicfilterscript_UNLOCK /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 dinamicfilterscript_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update dinamicfilterscript set LockUserID =null  where dinamicfilterscriptid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update dinamicfilterscript set LockSessionID =null  where dinamicfilterscriptid=aRowID;
     return;
   end if;
 end; 

procedure dinamicfilterscript_SINIT /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from dinamicfilterscript where dinamicfilterscriptid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =dinamicfilterscript');
    return;
  end if;
if aSecurityStyleID is null then
 dinamicfilterscript_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update dinamicfilterscript set securitystyleid =aStyleID where dinamicfilterscriptid = aRowID;
else 
 update dinamicfilterscript set securitystyleid =aSecurityStyleID where dinamicfilterscriptid = aRowID;
end if; 
end ; 

procedure dinamicfilterscript_propagate /*Выражение для построения дополнительного фильтра для ссылочных полей*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from dinamicfilterscript where dinamicfilterscriptid=aRowid;
end;


procedure fieldexpression_BRIEF  (
 aCURSESSION CHAR,
 afieldexpressionid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldexpressionid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldexpression where fieldexpressionID=afieldexpressionID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldexpression where fieldexpressionid=afieldexpressionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldexpression');
    return;
  end if;
  aBRIEF:=func.fieldexpression_BRIEF_F(afieldexpressionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldexpression_DELETE /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 afieldexpressionid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldexpression where fieldexpressionID=afieldexpressionID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldexpression where fieldexpressionid=afieldexpressionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldexpression',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldexpression');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldexpression_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldexpressionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldexpression');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fieldexpression is select  instanceid ID from instance where OwnerPartName ='fieldexpression' and OwnerRowID=afieldexpressionid;
row_fieldexpression  chld_fieldexpression%ROWTYPE;
begin
--open chld_fieldexpression;
for row_fieldexpression in chld_fieldexpression loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldexpression.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldexpression.id);
end loop;
--close chld_fieldexpression;
end ;
  delete from  fieldexpression 
  where  fieldexpressionID = afieldexpressionID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Значение по умолчанию*/
procedure fieldexpression_SAVE /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 afieldexpressionid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldexpression where fieldexpressionID=afieldexpressionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldexpression where fieldexpressionid=afieldexpressionID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldexpression',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldexpression');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldexpression_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldexpressionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldexpression');
    return;
  end if;
 -- update row  --
 update  fieldexpression set ChangeStamp=sysdate
,
  target=atarget
,
  code=acode
  where  fieldexpressionID = afieldexpressionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from field where fieldid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldexpression',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldexpression');
      return;
    end if;
 end if;
 field_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldexpression');
    return;
  end if;
 insert into   fieldexpression
 (  fieldexpressionID 
,ParentStructRowID
,target

,code

 ) values ( afieldexpressionID 
,aParentStructRowID
,atarget

,acode

 ); 
 fieldexpression_SINIT( aCURSESSION,afieldexpressionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fieldexpression_PARENT /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fieldexpression where  fieldexpressionid=aRowID;
  aParentTable := 'field';
 end; 

procedure fieldexpression_ISLOCKED /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldexpression where fieldexpressionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldexpression_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldexpression_LOCK /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldexpression_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldexpression_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldexpression where fieldexpressionid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldexpression');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldexpression set LockUserID =auserID ,LockSessionID =null where fieldexpressionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldexpression set LockUserID =null,LockSessionID =aCURSESSION  where fieldexpressionid=aRowID;
     return;
   end if;
 end ;

procedure fieldexpression_HCL /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fieldexpression_UNLOCK /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldexpression_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldexpression set LockUserID =null  where fieldexpressionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldexpression set LockSessionID =null  where fieldexpressionid=aRowID;
     return;
   end if;
 end; 

procedure fieldexpression_SINIT /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldexpression where fieldexpressionid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldexpression');
    return;
  end if;
if aSecurityStyleID is null then
 fieldexpression_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldexpression set securitystyleid =aStyleID where fieldexpressionid = aRowID;
else 
 update fieldexpression set securitystyleid =aSecurityStyleID where fieldexpressionid = aRowID;
end if; 
end ; 

procedure fieldexpression_propagate /*Выражение для вычисления поля
или значение по умолчанию*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldexpression where fieldexpressionid=aRowid;
end;


procedure fieldvalidator_BRIEF  (
 aCURSESSION CHAR,
 afieldvalidatorid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldvalidatorid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldvalidator where fieldvalidatorID=afieldvalidatorID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldvalidator where fieldvalidatorid=afieldvalidatorID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldvalidator');
    return;
  end if;
  aBRIEF:=func.fieldvalidator_BRIEF_F(afieldvalidatorid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldvalidator_DELETE /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 afieldvalidatorid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldvalidator where fieldvalidatorID=afieldvalidatorID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldvalidator where fieldvalidatorid=afieldvalidatorID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldvalidator',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldvalidator');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldvalidator_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldvalidatorid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldvalidator');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fieldvalidator is select  instanceid ID from instance where OwnerPartName ='fieldvalidator' and OwnerRowID=afieldvalidatorid;
row_fieldvalidator  chld_fieldvalidator%ROWTYPE;
begin
--open chld_fieldvalidator;
for row_fieldvalidator in chld_fieldvalidator loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldvalidator.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldvalidator.id);
end loop;
--close chld_fieldvalidator;
end ;
  delete from  fieldvalidator 
  where  fieldvalidatorID = afieldvalidatorID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Логика поля на форме*/
procedure fieldvalidator_SAVE /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 afieldvalidatorid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atarget CHAR/* Платформа *//* Платформа */
,acode VARCHAR2 := null /* Скрипт *//* Скрипт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldvalidator where fieldvalidatorID=afieldvalidatorID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldvalidator where fieldvalidatorid=afieldvalidatorID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldvalidator',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldvalidator');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldvalidator_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldvalidatorid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldvalidator');
    return;
  end if;
 -- update row  --
 update  fieldvalidator set ChangeStamp=sysdate
,
  target=atarget
,
  code=acode
  where  fieldvalidatorID = afieldvalidatorID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from field where fieldid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldvalidator',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldvalidator');
      return;
    end if;
 end if;
 field_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldvalidator');
    return;
  end if;
 insert into   fieldvalidator
 (  fieldvalidatorID 
,ParentStructRowID
,target

,code

 ) values ( afieldvalidatorID 
,aParentStructRowID
,atarget

,acode

 ); 
 fieldvalidator_SINIT( aCURSESSION,afieldvalidatorid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fieldvalidator_PARENT /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fieldvalidator where  fieldvalidatorid=aRowID;
  aParentTable := 'field';
 end; 

procedure fieldvalidator_ISLOCKED /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldvalidator where fieldvalidatorid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldvalidator_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldvalidator_LOCK /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldvalidator_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldvalidator_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldvalidator where fieldvalidatorid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldvalidator');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldvalidator set LockUserID =auserID ,LockSessionID =null where fieldvalidatorid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldvalidator set LockUserID =null,LockSessionID =aCURSESSION  where fieldvalidatorid=aRowID;
     return;
   end if;
 end ;

procedure fieldvalidator_HCL /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fieldvalidator_UNLOCK /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldvalidator_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldvalidator set LockUserID =null  where fieldvalidatorid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldvalidator set LockSessionID =null  where fieldvalidatorid=aRowID;
     return;
   end if;
 end; 

procedure fieldvalidator_SINIT /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldvalidator where fieldvalidatorid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldvalidator');
    return;
  end if;
if aSecurityStyleID is null then
 fieldvalidator_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldvalidator set securitystyleid =aStyleID where fieldvalidatorid = aRowID;
else 
 update fieldvalidator set securitystyleid =aSecurityStyleID where fieldvalidatorid = aRowID;
end if; 
end ; 

procedure fieldvalidator_propagate /*Логика взаимосвязей на форме при изменении поля*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldvalidator where fieldvalidatorid=aRowid;
end;


procedure fieldmenu_BRIEF  (
 aCURSESSION CHAR,
 afieldmenuid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldmenuid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldmenu where fieldmenuID=afieldmenuID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldmenu where fieldmenuid=afieldmenuID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldmenu');
    return;
  end if;
  aBRIEF:=func.fieldmenu_BRIEF_F(afieldmenuid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldmenu_DELETE /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 afieldmenuid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldmenu where fieldmenuID=afieldmenuID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldmenu where fieldmenuid=afieldmenuID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldmenu',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldmenu');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldmenu_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldmenuid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldmenu');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_fieldparammap is select fieldparammap.fieldparammapid ID from fieldparammap where  fieldparammap.ParentStructRowID = afieldmenuid;
    child_fieldparammap_rec  child_fieldparammap%ROWTYPE;
    begin
    --open child_fieldparammap;
      for child_fieldparammap_rec in child_fieldparammap loop
      fieldparammap_DELETE (acursession,child_fieldparammap_rec.id,aInstanceid);
      end loop;
      --close child_fieldparammap;
    end ;
declare cursor chld_fieldmenu is select  instanceid ID from instance where OwnerPartName ='fieldmenu' and OwnerRowID=afieldmenuid;
row_fieldmenu  chld_fieldmenu%ROWTYPE;
begin
--open chld_fieldmenu;
for row_fieldmenu in chld_fieldmenu loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldmenu.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldmenu.id);
end loop;
--close chld_fieldmenu;
end ;
  delete from  fieldmenu 
  where  fieldmenuID = afieldmenuID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Методы поля*/
procedure fieldmenu_SAVE /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 afieldmenuid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,atooltip
 VARCHAR2 := null /* Подсказка *//* Подсказка */
,aactionid CHAR/* Идентификатор вызываемого метода *//* Идентификатор вызываемого метода */
,aismenuitem
 NUMBER/* В меню *//* В меню */
,aistoolbarbutton
 NUMBER/* В тулбар *//* В тулбар */
,ahotkey
 VARCHAR2 := null /* Горячая клавиша *//* Горячая клавиша */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldmenu where fieldmenuID=afieldmenuID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldmenu where fieldmenuid=afieldmenuID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldmenu',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldmenu');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldmenu_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldmenuid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldmenu');
    return;
  end if;
 -- update row  --
 update  fieldmenu set ChangeStamp=sysdate
,
  name=aname
,
  caption=acaption
,
  tooltip=atooltip
,
  actionid=aactionid
,
  ismenuitem=aismenuitem
,
  istoolbarbutton=aistoolbarbutton
,
  hotkey=ahotkey
  where  fieldmenuID = afieldmenuID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from field where fieldid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldmenu',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldmenu');
      return;
    end if;
 end if;
 field_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldmenu');
    return;
  end if;
 insert into   fieldmenu
 (  fieldmenuID 
,ParentStructRowID
,name

,caption

,tooltip

,actionid

,ismenuitem

,istoolbarbutton

,hotkey

 ) values ( afieldmenuID 
,aParentStructRowID
,aname

,acaption

,atooltip

,aactionid

,aismenuitem

,aistoolbarbutton

,ahotkey

 ); 
 fieldmenu_SINIT( aCURSESSION,afieldmenuid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fieldmenu_PARENT /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fieldmenu where  fieldmenuid=aRowID;
  aParentTable := 'field';
 end; 

procedure fieldmenu_ISLOCKED /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldmenu where fieldmenuid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldmenu_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldmenu_LOCK /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldmenu_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldmenu_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldmenu where fieldmenuid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldmenu');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldmenu set LockUserID =auserID ,LockSessionID =null where fieldmenuid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldmenu set LockUserID =null,LockSessionID =aCURSESSION  where fieldmenuid=aRowID;
     return;
   end if;
 end ;

procedure fieldmenu_HCL /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_fieldparammap is select fieldparammap.fieldparammapid ID from fieldparammap where  fieldparammap.ParentStructRowID = aRowid;
row_fieldparammap lch_fieldparammap%ROWTYPE;
begin  
--open lch_fieldparammap;
for row_fieldparammap in lch_fieldparammap
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fieldparammap where fieldparammapid=row_fieldparammap.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fieldparammap;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fieldparammap;
     return;
   end if; 
 end if;  
 fieldparammap_HCL (acursession,row_fieldparammap.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fieldparammap;
   return;
 end if;
end loop;
--close lch_fieldparammap;
end;
aIsLocked :=0;
end;

procedure fieldmenu_UNLOCK /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldmenu_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldmenu set LockUserID =null  where fieldmenuid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldmenu set LockSessionID =null  where fieldmenuid=aRowID;
     return;
   end if;
 end; 

procedure fieldmenu_SINIT /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldmenu where fieldmenuid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldmenu');
    return;
  end if;
if aSecurityStyleID is null then
 fieldmenu_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldmenu set securitystyleid =aStyleID where fieldmenuid = aRowID;
else 
 update fieldmenu set securitystyleid =aSecurityStyleID where fieldmenuid = aRowID;
end if; 
end ; 

procedure fieldmenu_propagate /*Методы, ассоциированные с полем*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldmenu where fieldmenuid=aRowid;
declare cursor pch_fieldparammap  is select fieldparammap.fieldparammapid ID from fieldparammap where  fieldparammap.ParentStructRowID = aRowid;
row_fieldparammap  pch_fieldparammap%ROWTYPE;
begin
--open pch_fieldparammap;
for row_fieldparammap in pch_fieldparammap loop
   fieldparammap_SINIT( acursession,row_fieldparammap.id,assid);
   fieldparammap_propagate( acursession,row_fieldparammap.id);
end loop;
--close pch_fieldparammap;
end;
end;


procedure fieldparammap_BRIEF  (
 aCURSESSION CHAR,
 afieldparammapid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afieldparammapid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fieldparammap where fieldparammapID=afieldparammapID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fieldparammap where fieldparammapid=afieldparammapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fieldparammap');
    return;
  end if;
  aBRIEF:=func.fieldparammap_BRIEF_F(afieldparammapid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fieldparammap_DELETE /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 afieldparammapid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fieldparammap where fieldparammapID=afieldparammapID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fieldparammap where fieldparammapid=afieldparammapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fieldparammap',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fieldparammap');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldparammap_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldparammapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fieldparammap');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fieldparammap is select  instanceid ID from instance where OwnerPartName ='fieldparammap' and OwnerRowID=afieldparammapid;
row_fieldparammap  chld_fieldparammap%ROWTYPE;
begin
--open chld_fieldparammap;
for row_fieldparammap in chld_fieldparammap loop
 Kernel.INSTANCE_OWNER (acursession,row_fieldparammap.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fieldparammap.id);
end loop;
--close chld_fieldparammap;
end ;
  delete from  fieldparammap 
  where  fieldparammapID = afieldparammapID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение параметров*/
procedure fieldparammap_SAVE /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 afieldparammapid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,afieldname
 VARCHAR2/* Поле (значение) *//* Поле (значение) */
,aparamname
 VARCHAR2/* Параметр *//* Параметр */
,anoedit
 NUMBER/* Редактировать параметр нельзя *//* Редактировать параметр нельзя */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fieldparammap where fieldparammapID=afieldparammapID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fieldparammap where fieldparammapid=afieldparammapID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fieldparammap',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fieldparammap');
      return;
    end if;
  end if;
 --  verify lock  --
 fieldparammap_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afieldparammapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldparammap');
    return;
  end if;
 -- update row  --
 update  fieldparammap set ChangeStamp=sysdate
,
  fieldname=afieldname
,
  paramname=aparamname
,
  noedit=anoedit
  where  fieldparammapID = afieldparammapID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from fieldmenu where fieldmenuid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fieldparammap',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fieldparammap');
      return;
    end if;
 end if;
 fieldmenu_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fieldparammap');
    return;
  end if;
 insert into   fieldparammap
 (  fieldparammapID 
,ParentStructRowID
,fieldname

,paramname

,noedit

 ) values ( afieldparammapID 
,aParentStructRowID
,afieldname

,aparamname

,anoedit

 ); 
 fieldparammap_SINIT( aCURSESSION,afieldparammapid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fieldparammap_PARENT /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fieldparammap where  fieldparammapid=aRowID;
  aParentTable := 'fieldmenu';
 end; 

procedure fieldparammap_ISLOCKED /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fieldparammap where fieldparammapid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fieldparammap_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fieldparammap_LOCK /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fieldparammap_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fieldparammap_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fieldparammap where fieldparammapid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fieldparammap');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fieldparammap set LockUserID =auserID ,LockSessionID =null where fieldparammapid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fieldparammap set LockUserID =null,LockSessionID =aCURSESSION  where fieldparammapid=aRowID;
     return;
   end if;
 end ;

procedure fieldparammap_HCL /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fieldparammap_UNLOCK /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fieldparammap_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fieldparammap set LockUserID =null  where fieldparammapid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fieldparammap set LockSessionID =null  where fieldparammapid=aRowID;
     return;
   end if;
 end; 

procedure fieldparammap_SINIT /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fieldparammap where fieldparammapid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fieldparammap');
    return;
  end if;
if aSecurityStyleID is null then
 fieldparammap_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fieldparammap set securitystyleid =aStyleID where fieldparammapid = aRowID;
else 
 update fieldparammap set securitystyleid =aSecurityStyleID where fieldparammapid = aRowID;
end if; 
end ; 

procedure fieldparammap_propagate /*Отображение значений на параметры метода*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fieldparammap where fieldparammapid=aRowid;
end;


procedure mtzapp_BRIEF  (
 aCURSESSION CHAR,
 amtzappid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if amtzappid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from mtzapp where mtzappID=amtzappID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from mtzapp where mtzappid=amtzappID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=mtzapp');
    return;
  end if;
  aBRIEF:=func.mtzapp_BRIEF_F(amtzappid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure mtzapp_DELETE /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 amtzappid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from mtzapp where mtzappID=amtzappID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from mtzapp where mtzappid=amtzappID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:mtzapp',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=mtzapp');
      return;
    end if;
  end if;
 --  verify lock  --
 mtzapp_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtzappid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=mtzapp');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_parentpackage is select parentpackage.parentpackageid ID from parentpackage where  parentpackage.ParentStructRowID = amtzappid;
    child_parentpackage_rec  child_parentpackage%ROWTYPE;
    begin
    --open child_parentpackage;
      for child_parentpackage_rec in child_parentpackage loop
      parentpackage_DELETE (acursession,child_parentpackage_rec.id,aInstanceid);
      end loop;
      --close child_parentpackage;
    end ;
declare cursor chld_mtzapp is select  instanceid ID from instance where OwnerPartName ='mtzapp' and OwnerRowID=amtzappid;
row_mtzapp  chld_mtzapp%ROWTYPE;
begin
--open chld_mtzapp;
for row_mtzapp in chld_mtzapp loop
 Kernel.INSTANCE_OWNER (acursession,row_mtzapp.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_mtzapp.id);
end loop;
--close chld_mtzapp;
end ;
  delete from  mtzapp 
  where  mtzappID = amtzappID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Приложение*/
procedure mtzapp_SAVE /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 amtzappid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,adbname
 VARCHAR2 := null /* База данных *//* База данных */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from mtzapp where mtzappID=amtzappID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from mtzapp where mtzappid=amtzappID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:mtzapp',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=mtzapp');
      return;
    end if;
  end if;
 --  verify lock  --
 mtzapp_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtzappid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtzapp');
    return;
  end if;
 -- update row  --
 update  mtzapp set ChangeStamp=sysdate
,
  name=aname
,
  dbname=adbname
,
  thecomment=athecomment
  where  mtzappID = amtzappID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:mtzapp',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=mtzapp');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtzapp');
    return;
  end if;
 insert into   mtzapp
 (  mtzappID 
,InstanceID
,name

,dbname

,thecomment

 ) values ( amtzappID 
,aInstanceID
,aname

,adbname

,athecomment

 ); 
 mtzapp_SINIT( aCURSESSION,amtzappid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure mtzapp_PARENT /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from mtzapp where  mtzappid=aRowID;
 end; 

procedure mtzapp_ISLOCKED /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from mtzapp where mtzappid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  mtzapp_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure mtzapp_LOCK /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 mtzapp_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  mtzapp_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from mtzapp where mtzappid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=mtzapp');
    return;
  end if;
   if  aLockMode =2  
   then   
    update mtzapp set LockUserID =auserID ,LockSessionID =null where mtzappid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update mtzapp set LockUserID =null,LockSessionID =aCURSESSION  where mtzappid=aRowID;
     return;
   end if;
 end ;

procedure mtzapp_HCL /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_parentpackage is select parentpackage.parentpackageid ID from parentpackage where  parentpackage.ParentStructRowID = aRowid;
row_parentpackage lch_parentpackage%ROWTYPE;
begin  
--open lch_parentpackage;
for row_parentpackage in lch_parentpackage
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from parentpackage where parentpackageid=row_parentpackage.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_parentpackage;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_parentpackage;
     return;
   end if; 
 end if;  
 parentpackage_HCL (acursession,row_parentpackage.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_parentpackage;
   return;
 end if;
end loop;
--close lch_parentpackage;
end;
aIsLocked :=0;
end;

procedure mtzapp_UNLOCK /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 mtzapp_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update mtzapp set LockUserID =null  where mtzappid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update mtzapp set LockSessionID =null  where mtzappid=aRowID;
     return;
   end if;
 end; 

procedure mtzapp_SINIT /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from mtzapp where mtzappid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =mtzapp');
    return;
  end if;
if aSecurityStyleID is null then
 mtzapp_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update mtzapp set securitystyleid =aStyleID where mtzappid = aRowID;
else 
 update mtzapp set securitystyleid =aSecurityStyleID where mtzappid = aRowID;
end if; 
end ; 

procedure mtzapp_propagate /*Группа взаимосвязных документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from mtzapp where mtzappid=aRowid;
declare cursor pch_parentpackage  is select parentpackage.parentpackageid ID from parentpackage where  parentpackage.ParentStructRowID = aRowid;
row_parentpackage  pch_parentpackage%ROWTYPE;
begin
--open pch_parentpackage;
for row_parentpackage in pch_parentpackage loop
   parentpackage_SINIT( acursession,row_parentpackage.id,assid);
   parentpackage_propagate( acursession,row_parentpackage.id);
end loop;
--close pch_parentpackage;
end;
end;


procedure parentpackage_BRIEF  (
 aCURSESSION CHAR,
 aparentpackageid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aparentpackageid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from parentpackage where parentpackageID=aparentpackageID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from parentpackage where parentpackageid=aparentpackageID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=parentpackage');
    return;
  end if;
  aBRIEF:=func.parentpackage_BRIEF_F(aparentpackageid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure parentpackage_DELETE /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aparentpackageid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from parentpackage where parentpackageID=aparentpackageID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from parentpackage where parentpackageid=aparentpackageID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:parentpackage',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=parentpackage');
      return;
    end if;
  end if;
 --  verify lock  --
 parentpackage_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aparentpackageid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=parentpackage');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_parentpackage is select  instanceid ID from instance where OwnerPartName ='parentpackage' and OwnerRowID=aparentpackageid;
row_parentpackage  chld_parentpackage%ROWTYPE;
begin
--open chld_parentpackage;
for row_parentpackage in chld_parentpackage loop
 Kernel.INSTANCE_OWNER (acursession,row_parentpackage.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_parentpackage.id);
end loop;
--close chld_parentpackage;
end ;
  delete from  parentpackage 
  where  parentpackageID = aparentpackageID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Обязательные приложения*/
procedure parentpackage_SAVE /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aparentpackageid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,apackage CHAR/* Приложение *//* Приложение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from parentpackage where parentpackageID=aparentpackageID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from parentpackage where parentpackageid=aparentpackageID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:parentpackage',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=parentpackage');
      return;
    end if;
  end if;
 --  verify lock  --
 parentpackage_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aparentpackageid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=parentpackage');
    return;
  end if;
 -- update row  --
 update  parentpackage set ChangeStamp=sysdate
,
  package=apackage
  where  parentpackageID = aparentpackageID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from mtzapp where mtzappid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:parentpackage',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=parentpackage');
      return;
    end if;
 end if;
 mtzapp_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=parentpackage');
    return;
  end if;
 insert into   parentpackage
 (  parentpackageID 
,ParentStructRowID
,package

 ) values ( aparentpackageID 
,aParentStructRowID
,apackage

 ); 
 parentpackage_SINIT( aCURSESSION,aparentpackageid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure parentpackage_PARENT /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from parentpackage where  parentpackageid=aRowID;
  aParentTable := 'mtzapp';
 end; 

procedure parentpackage_ISLOCKED /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from parentpackage where parentpackageid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  parentpackage_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzmetamodel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure parentpackage_LOCK /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 parentpackage_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  parentpackage_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from parentpackage where parentpackageid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=parentpackage');
    return;
  end if;
   if  aLockMode =2  
   then   
    update parentpackage set LockUserID =auserID ,LockSessionID =null where parentpackageid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update parentpackage set LockUserID =null,LockSessionID =aCURSESSION  where parentpackageid=aRowID;
     return;
   end if;
 end ;

procedure parentpackage_HCL /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure parentpackage_UNLOCK /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 parentpackage_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update parentpackage set LockUserID =null  where parentpackageid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update parentpackage set LockSessionID =null  where parentpackageid=aRowID;
     return;
   end if;
 end; 

procedure parentpackage_SINIT /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from parentpackage where parentpackageid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =parentpackage');
    return;
  end if;
if aSecurityStyleID is null then
 parentpackage_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update parentpackage set securitystyleid =aStyleID where parentpackageid = aRowID;
else 
 update parentpackage set securitystyleid =aSecurityStyleID where parentpackageid = aRowID;
end if; 
end ; 

procedure parentpackage_propagate /*Приложения от которых зависит данное приложение*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from parentpackage where parentpackageid=aRowid;
end;
end mtzmetamodel;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzjrnl" BlockCode=" create or replace package body mtzjrnl as

procedure mtzjrnl_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzjrnl'
then
declare cursor child_journalcolumn is select journalcolumn.journalcolumnid ID from journalcolumn where  journalcolumn.InstanceID = ainstanceid;
row_journalcolumn  child_journalcolumn%ROWTYPE;
begin
--open child_journalcolumn;
for row_journalcolumn in child_journalcolumn loop
 journalcolumn_DELETE (acursession,row_journalcolumn.id,aInstanceID);
end loop;
--close child_journalcolumn;
end;
declare cursor child_journalsrc is select journalsrc.journalsrcid ID from journalsrc where  journalsrc.InstanceID = ainstanceid;
row_journalsrc  child_journalsrc%ROWTYPE;
begin
--open child_journalsrc;
for row_journalsrc in child_journalsrc loop
 journalsrc_DELETE (acursession,row_journalsrc.id,aInstanceID);
end loop;
--close child_journalsrc;
end;
declare cursor child_journal is select journal.journalid ID from journal where  journal.InstanceID = ainstanceid;
row_journal  child_journal%ROWTYPE;
begin
--open child_journal;
for row_journal in child_journal loop
 journal_DELETE (acursession,row_journal.id,aInstanceID);
end loop;
--close child_journal;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzjrnl_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzjrnl'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_journalcolumn is select journalcolumn.journalcolumnid ID from journalcolumn where  journalcolumn.InstanceID = arowid;
ROW_journalcolumn  lch_journalcolumn%ROWTYPE;
begin
--open lch_journalcolumn;
for row_journalcolumn in lch_journalcolumn loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from journalcolumn where journalcolumnid=row_journalcolumn.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_journalcolumn;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_journalcolumn;
     return;
   end if; 
 end if; 
 journalcolumn_HCL (acursession,ROW_journalcolumn.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_journalcolumn;
   return;
 end if;
 end loop;
--close lch_journalcolumn;
end;
declare cursor lch_journalsrc is select journalsrc.journalsrcid ID from journalsrc where  journalsrc.InstanceID = arowid;
ROW_journalsrc  lch_journalsrc%ROWTYPE;
begin
--open lch_journalsrc;
for row_journalsrc in lch_journalsrc loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from journalsrc where journalsrcid=row_journalsrc.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_journalsrc;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_journalsrc;
     return;
   end if; 
 end if; 
 journalsrc_HCL (acursession,ROW_journalsrc.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_journalsrc;
   return;
 end if;
 end loop;
--close lch_journalsrc;
end;
declare cursor lch_journal is select journal.journalid ID from journal where  journal.InstanceID = arowid;
ROW_journal  lch_journal%ROWTYPE;
begin
--open lch_journal;
for row_journal in lch_journal loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from journal where journalid=row_journal.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_journal;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_journal;
     return;
   end if; 
 end if; 
 journal_HCL (acursession,ROW_journal.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_journal;
   return;
 end if;
 end loop;
--close lch_journal;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzjrnl_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzjrnl'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_journalcolumn is select journalcolumn.journalcolumnid id from journalcolumn where  journalcolumn.InstanceID = arowid;
row_journalcolumn  pch_journalcolumn%ROWTYPE;
begin
--open pch_journalcolumn;
for row_journalcolumn in  pch_journalcolumn loop
 journalcolumn_SINIT( acursession,row_journalcolumn.id,assid);
 journalcolumn_propagate( acursession,row_journalcolumn.id);
end loop;
--close pch_journalcolumn;
end;
declare cursor pch_journalsrc is select journalsrc.journalsrcid id from journalsrc where  journalsrc.InstanceID = arowid;
row_journalsrc  pch_journalsrc%ROWTYPE;
begin
--open pch_journalsrc;
for row_journalsrc in  pch_journalsrc loop
 journalsrc_SINIT( acursession,row_journalsrc.id,assid);
 journalsrc_propagate( acursession,row_journalsrc.id);
end loop;
--close pch_journalsrc;
end;
declare cursor pch_journal is select journal.journalid id from journal where  journal.InstanceID = arowid;
row_journal  pch_journal%ROWTYPE;
begin
--open pch_journal;
for row_journal in  pch_journal loop
 journal_SINIT( acursession,row_journal.id,assid);
 journal_propagate( acursession,row_journal.id);
end loop;
--close pch_journal;
end;
 end if; 
end;


procedure journalcolumn_BRIEF  (
 aCURSESSION CHAR,
 ajournalcolumnid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ajournalcolumnid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from journalcolumn where journalcolumnID=ajournalcolumnID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from journalcolumn where journalcolumnid=ajournalcolumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=journalcolumn');
    return;
  end if;
  aBRIEF:=func.journalcolumn_BRIEF_F(ajournalcolumnid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure journalcolumn_DELETE /*Колонки журнала*/ (
 aCURSESSION CHAR,
 ajournalcolumnid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from journalcolumn where journalcolumnID=ajournalcolumnID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from journalcolumn where journalcolumnid=ajournalcolumnID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:journalcolumn',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=journalcolumn');
      return;
    end if;
  end if;
 --  verify lock  --
 journalcolumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajournalcolumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=journalcolumn');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_jcolumnsource is select jcolumnsource.jcolumnsourceid ID from jcolumnsource where  jcolumnsource.ParentStructRowID = ajournalcolumnid;
    child_jcolumnsource_rec  child_jcolumnsource%ROWTYPE;
    begin
    --open child_jcolumnsource;
      for child_jcolumnsource_rec in child_jcolumnsource loop
      jcolumnsource_DELETE (acursession,child_jcolumnsource_rec.id,aInstanceid);
      end loop;
      --close child_jcolumnsource;
    end ;
declare cursor chld_journalcolumn is select  instanceid ID from instance where OwnerPartName ='journalcolumn' and OwnerRowID=ajournalcolumnid;
row_journalcolumn  chld_journalcolumn%ROWTYPE;
begin
--open chld_journalcolumn;
for row_journalcolumn in chld_journalcolumn loop
 Kernel.INSTANCE_OWNER (acursession,row_journalcolumn.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_journalcolumn.id);
end loop;
--close chld_journalcolumn;
end ;
  delete from  journalcolumn 
  where  journalcolumnID = ajournalcolumnID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Колонки журнала*/
procedure journalcolumn_SAVE /*Колонки журнала*/ (
 aCURSESSION CHAR,
 ajournalcolumnid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER := null /* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acolumnalignment
 NUMBER/* Выравнивание *//* Выравнивание */
,acolsort
 NUMBER/* Сортировка колонки *//* Сортировка колонки */
,agroupaggregation
 NUMBER/* Аггрегация при группировке *//* Аггрегация при группировке */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from journalcolumn where journalcolumnID=ajournalcolumnID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from journalcolumn where journalcolumnid=ajournalcolumnID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:journalcolumn',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=journalcolumn');
      return;
    end if;
  end if;
 --  verify lock  --
 journalcolumn_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajournalcolumnid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=journalcolumn');
    return;
  end if;
 -- update row  --
 update  journalcolumn set ChangeStamp=sysdate
,
  sequence=asequence
,
  name=aname
,
  columnalignment=acolumnalignment
,
  colsort=acolsort
,
  groupaggregation=agroupaggregation
  where  journalcolumnID = ajournalcolumnID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:journalcolumn',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=journalcolumn');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=journalcolumn');
    return;
  end if;
 insert into   journalcolumn
 (  journalcolumnID 
,InstanceID
,sequence

,name

,columnalignment

,colsort

,groupaggregation

 ) values ( ajournalcolumnID 
,aInstanceID
,asequence

,aname

,acolumnalignment

,acolsort

,agroupaggregation

 ); 
 journalcolumn_SINIT( aCURSESSION,ajournalcolumnid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure journalcolumn_PARENT /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from journalcolumn where  journalcolumnid=aRowID;
 end; 

procedure journalcolumn_ISLOCKED /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from journalcolumn where journalcolumnid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  journalcolumn_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzjrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure journalcolumn_LOCK /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 journalcolumn_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  journalcolumn_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from journalcolumn where journalcolumnid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=journalcolumn');
    return;
  end if;
   if  aLockMode =2  
   then   
    update journalcolumn set LockUserID =auserID ,LockSessionID =null where journalcolumnid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update journalcolumn set LockUserID =null,LockSessionID =aCURSESSION  where journalcolumnid=aRowID;
     return;
   end if;
 end ;

procedure journalcolumn_HCL /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_jcolumnsource is select jcolumnsource.jcolumnsourceid ID from jcolumnsource where  jcolumnsource.ParentStructRowID = aRowid;
row_jcolumnsource lch_jcolumnsource%ROWTYPE;
begin  
--open lch_jcolumnsource;
for row_jcolumnsource in lch_jcolumnsource
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from jcolumnsource where jcolumnsourceid=row_jcolumnsource.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_jcolumnsource;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_jcolumnsource;
     return;
   end if; 
 end if;  
 jcolumnsource_HCL (acursession,row_jcolumnsource.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_jcolumnsource;
   return;
 end if;
end loop;
--close lch_jcolumnsource;
end;
aIsLocked :=0;
end;

procedure journalcolumn_UNLOCK /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 journalcolumn_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update journalcolumn set LockUserID =null  where journalcolumnid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update journalcolumn set LockSessionID =null  where journalcolumnid=aRowID;
     return;
   end if;
 end; 

procedure journalcolumn_SINIT /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from journalcolumn where journalcolumnid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =journalcolumn');
    return;
  end if;
if aSecurityStyleID is null then
 journalcolumn_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update journalcolumn set securitystyleid =aStyleID where journalcolumnid = aRowID;
else 
 update journalcolumn set securitystyleid =aSecurityStyleID where journalcolumnid = aRowID;
end if; 
end ; 

procedure journalcolumn_propagate /*Колонки журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from journalcolumn where journalcolumnid=aRowid;
declare cursor pch_jcolumnsource  is select jcolumnsource.jcolumnsourceid ID from jcolumnsource where  jcolumnsource.ParentStructRowID = aRowid;
row_jcolumnsource  pch_jcolumnsource%ROWTYPE;
begin
--open pch_jcolumnsource;
for row_jcolumnsource in pch_jcolumnsource loop
   jcolumnsource_SINIT( acursession,row_jcolumnsource.id,assid);
   jcolumnsource_propagate( acursession,row_jcolumnsource.id);
end loop;
--close pch_jcolumnsource;
end;
end;


procedure jcolumnsource_BRIEF  (
 aCURSESSION CHAR,
 ajcolumnsourceid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ajcolumnsourceid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from jcolumnsource where jcolumnsourceID=ajcolumnsourceID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from jcolumnsource where jcolumnsourceid=ajcolumnsourceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=jcolumnsource');
    return;
  end if;
  aBRIEF:=func.jcolumnsource_BRIEF_F(ajcolumnsourceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure jcolumnsource_DELETE /*Состав колонки*/ (
 aCURSESSION CHAR,
 ajcolumnsourceid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from jcolumnsource where jcolumnsourceID=ajcolumnsourceID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from jcolumnsource where jcolumnsourceid=ajcolumnsourceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:jcolumnsource',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=jcolumnsource');
      return;
    end if;
  end if;
 --  verify lock  --
 jcolumnsource_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajcolumnsourceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=jcolumnsource');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_jcolumnsource is select  instanceid ID from instance where OwnerPartName ='jcolumnsource' and OwnerRowID=ajcolumnsourceid;
row_jcolumnsource  chld_jcolumnsource%ROWTYPE;
begin
--open chld_jcolumnsource;
for row_jcolumnsource in chld_jcolumnsource loop
 Kernel.INSTANCE_OWNER (acursession,row_jcolumnsource.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_jcolumnsource.id);
end loop;
--close chld_jcolumnsource;
end ;
  delete from  jcolumnsource 
  where  jcolumnsourceID = ajcolumnsourceID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Состав колонки*/
procedure jcolumnsource_SAVE /*Состав колонки*/ (
 aCURSESSION CHAR,
 ajcolumnsourceid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asrcpartview CHAR/* Представление *//* Представление */
,aviewfield
 VARCHAR2/* Поле представления *//* Поле представления */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from jcolumnsource where jcolumnsourceID=ajcolumnsourceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from jcolumnsource where jcolumnsourceid=ajcolumnsourceID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:jcolumnsource',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=jcolumnsource');
      return;
    end if;
  end if;
 --  verify lock  --
 jcolumnsource_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajcolumnsourceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=jcolumnsource');
    return;
  end if;
 -- update row  --
 update  jcolumnsource set ChangeStamp=sysdate
,
  srcpartview=asrcpartview
,
  viewfield=aviewfield
  where  jcolumnsourceID = ajcolumnsourceID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from jcolumnsource where ParentStructRowID=aParentStructRowID 
 and srcpartview=asrcpartview;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=jcolumnsource');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from journalcolumn where journalcolumnid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:jcolumnsource',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=jcolumnsource');
      return;
    end if;
 end if;
 journalcolumn_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=jcolumnsource');
    return;
  end if;
 insert into   jcolumnsource
 (  jcolumnsourceID 
,ParentStructRowID
,srcpartview

,viewfield

 ) values ( ajcolumnsourceID 
,aParentStructRowID
,asrcpartview

,aviewfield

 ); 
 jcolumnsource_SINIT( aCURSESSION,ajcolumnsourceid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from jcolumnsource where ParentStructRowID=aParentStructRowID 
 and srcpartview=asrcpartview;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=jcolumnsource');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure jcolumnsource_PARENT /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from jcolumnsource where  jcolumnsourceid=aRowID;
  aParentTable := 'journalcolumn';
 end; 

procedure jcolumnsource_ISLOCKED /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from jcolumnsource where jcolumnsourceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  jcolumnsource_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzjrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure jcolumnsource_LOCK /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 jcolumnsource_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  jcolumnsource_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from jcolumnsource where jcolumnsourceid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=jcolumnsource');
    return;
  end if;
   if  aLockMode =2  
   then   
    update jcolumnsource set LockUserID =auserID ,LockSessionID =null where jcolumnsourceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update jcolumnsource set LockUserID =null,LockSessionID =aCURSESSION  where jcolumnsourceid=aRowID;
     return;
   end if;
 end ;

procedure jcolumnsource_HCL /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure jcolumnsource_UNLOCK /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 jcolumnsource_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update jcolumnsource set LockUserID =null  where jcolumnsourceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update jcolumnsource set LockSessionID =null  where jcolumnsourceid=aRowID;
     return;
   end if;
 end; 

procedure jcolumnsource_SINIT /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from jcolumnsource where jcolumnsourceid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =jcolumnsource');
    return;
  end if;
if aSecurityStyleID is null then
 jcolumnsource_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update jcolumnsource set securitystyleid =aStyleID where jcolumnsourceid = aRowID;
else 
 update jcolumnsource set securitystyleid =aSecurityStyleID where jcolumnsourceid = aRowID;
end if; 
end ; 

procedure jcolumnsource_propagate /*Состав колонки*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from jcolumnsource where jcolumnsourceid=aRowid;
end;


procedure journalsrc_BRIEF  (
 aCURSESSION CHAR,
 ajournalsrcid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ajournalsrcid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from journalsrc where journalsrcID=ajournalsrcID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from journalsrc where journalsrcid=ajournalsrcID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=journalsrc');
    return;
  end if;
  aBRIEF:=func.journalsrc_BRIEF_F(ajournalsrcid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure journalsrc_DELETE /*Источники журнала*/ (
 aCURSESSION CHAR,
 ajournalsrcid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from journalsrc where journalsrcID=ajournalsrcID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from journalsrc where journalsrcid=ajournalsrcID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:journalsrc',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=journalsrc');
      return;
    end if;
  end if;
 --  verify lock  --
 journalsrc_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajournalsrcid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=journalsrc');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_journalsrc is select  instanceid ID from instance where OwnerPartName ='journalsrc' and OwnerRowID=ajournalsrcid;
row_journalsrc  chld_journalsrc%ROWTYPE;
begin
--open chld_journalsrc;
for row_journalsrc in chld_journalsrc loop
 Kernel.INSTANCE_OWNER (acursession,row_journalsrc.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_journalsrc.id);
end loop;
--close chld_journalsrc;
end ;
  delete from  journalsrc 
  where  journalsrcID = ajournalsrcID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Источники журнала*/
procedure journalsrc_SAVE /*Источники журнала*/ (
 aCURSESSION CHAR,
 ajournalsrcid CHAR,
aInstanceID CHAR 
,aspartview
 VARCHAR2/* Представление *//* Представление */
,aonrun
 NUMBER/* При открытии *//* При открытии */
,aopenmode
 VARCHAR2 := null /* Режим открытия *//* Режим открытия */
,aviewalias
 VARCHAR2 := null /* Псевдоним представления *//* Псевдоним представления */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from journalsrc where journalsrcID=ajournalsrcID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from journalsrc where journalsrcid=ajournalsrcID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:journalsrc',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=journalsrc');
      return;
    end if;
  end if;
 --  verify lock  --
 journalsrc_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajournalsrcid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=journalsrc');
    return;
  end if;
 -- update row  --
 update  journalsrc set ChangeStamp=sysdate
,
  spartview=aspartview
,
  onrun=aonrun
,
  openmode=aopenmode
,
  viewalias=aviewalias
  where  journalsrcID = ajournalsrcID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from journalsrc where InstanceID=aInstanceID 
 and spartview=aspartview;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journalsrc');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:journalsrc',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=journalsrc');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=journalsrc');
    return;
  end if;
 insert into   journalsrc
 (  journalsrcID 
,InstanceID
,spartview

,onrun

,openmode

,viewalias

 ) values ( ajournalsrcID 
,aInstanceID
,aspartview

,aonrun

,aopenmode

,aviewalias

 ); 
 journalsrc_SINIT( aCURSESSION,ajournalsrcid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from journalsrc where InstanceID=aInstanceID 
 and spartview=aspartview;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journalsrc');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure journalsrc_PARENT /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from journalsrc where  journalsrcid=aRowID;
 end; 

procedure journalsrc_ISLOCKED /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from journalsrc where journalsrcid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  journalsrc_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzjrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure journalsrc_LOCK /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 journalsrc_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  journalsrc_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from journalsrc where journalsrcid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=journalsrc');
    return;
  end if;
   if  aLockMode =2  
   then   
    update journalsrc set LockUserID =auserID ,LockSessionID =null where journalsrcid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update journalsrc set LockUserID =null,LockSessionID =aCURSESSION  where journalsrcid=aRowID;
     return;
   end if;
 end ;

procedure journalsrc_HCL /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure journalsrc_UNLOCK /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 journalsrc_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update journalsrc set LockUserID =null  where journalsrcid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update journalsrc set LockSessionID =null  where journalsrcid=aRowID;
     return;
   end if;
 end; 

procedure journalsrc_SINIT /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from journalsrc where journalsrcid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =journalsrc');
    return;
  end if;
if aSecurityStyleID is null then
 journalsrc_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update journalsrc set securitystyleid =aStyleID where journalsrcid = aRowID;
else 
 update journalsrc set securitystyleid =aSecurityStyleID where journalsrcid = aRowID;
end if; 
end ; 

procedure journalsrc_propagate /*Источники журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from journalsrc where journalsrcid=aRowid;
end;


procedure journal_BRIEF  (
 aCURSESSION CHAR,
 ajournalid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ajournalid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from journal where journalID=ajournalID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from journal where journalid=ajournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=journal');
    return;
  end if;
  aBRIEF:=func.journal_BRIEF_F(ajournalid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure journal_DELETE /*Журнал*/ (
 aCURSESSION CHAR,
 ajournalid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from journal where journalID=ajournalID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from journal where journalid=ajournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:journal',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=journal');
      return;
    end if;
  end if;
 --  verify lock  --
 journal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=journal');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_journal is select  instanceid ID from instance where OwnerPartName ='journal' and OwnerRowID=ajournalid;
row_journal  chld_journal%ROWTYPE;
begin
--open chld_journal;
for row_journal in chld_journal loop
 Kernel.INSTANCE_OWNER (acursession,row_journal.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_journal.id);
end loop;
--close chld_journal;
end ;
  delete from  journal 
  where  journalID = ajournalID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Журнал*/
procedure journal_SAVE /*Журнал*/ (
 aCURSESSION CHAR,
 ajournalid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athe_alias
 VARCHAR2 := null /* Псевдоним *//* Псевдоним */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,ajrnliconcls
 VARCHAR2 := null /* Иконка журнала *//* Иконка журнала */
,ausefavorites
 NUMBER/* Массовое выделение *//* Массовое выделение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from journal where journalID=ajournalID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from journal where journalid=ajournalID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:journal',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=journal');
      return;
    end if;
  end if;
 --  verify lock  --
 journal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ajournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=journal');
    return;
  end if;
 -- update row  --
 update  journal set ChangeStamp=sysdate
,
  name=aname
,
  the_alias=athe_alias
,
  thecomment=athecomment
,
  jrnliconcls=ajrnliconcls
,
  usefavorites=ausefavorites
  where  journalID = ajournalID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from journal where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journal');
 return;
end if;
select Count(*) into aUniqueRowCount from journal where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journal');
 return;
end if;
select Count(*) into aUniqueRowCount from journal where 1=1  
 and the_alias=athe_alias;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journal');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:journal',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=journal');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=journal');
    return;
  end if;
select Count(*) into existsCnt from journal where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;journal&gt;');
    return;
 End if;
 insert into   journal
 (  journalID 
,InstanceID
,name

,the_alias

,thecomment

,jrnliconcls

,usefavorites

 ) values ( ajournalID 
,aInstanceID
,aname

,athe_alias

,athecomment

,ajrnliconcls

,ausefavorites

 ); 
 journal_SINIT( aCURSESSION,ajournalid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from journal where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journal');
 return;
end if;
select Count(*) into aUniqueRowCount from journal where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journal');
 return;
end if;
select Count(*) into aUniqueRowCount from journal where 1=1  
 and the_alias=athe_alias;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=journal');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure journal_PARENT /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from journal where  journalid=aRowID;
 end; 

procedure journal_ISLOCKED /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from journal where journalid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  journal_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzjrnl.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure journal_LOCK /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 journal_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  journal_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from journal where journalid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=journal');
    return;
  end if;
   if  aLockMode =2  
   then   
    update journal set LockUserID =auserID ,LockSessionID =null where journalid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update journal set LockUserID =null,LockSessionID =aCURSESSION  where journalid=aRowID;
     return;
   end if;
 end ;

procedure journal_HCL /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure journal_UNLOCK /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 journal_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update journal set LockUserID =null  where journalid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update journal set LockSessionID =null  where journalid=aRowID;
     return;
   end if;
 end; 

procedure journal_SINIT /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from journal where journalid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =journal');
    return;
  end if;
if aSecurityStyleID is null then
 journal_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update journal set securitystyleid =aStyleID where journalid = aRowID;
else 
 update journal set securitystyleid =aSecurityStyleID where journalid = aRowID;
end if; 
end ; 

procedure journal_propagate /*Журнал*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from journal where journalid=aRowid;
end;
end mtzjrnl;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tod" BlockCode=" create or replace package body tod as

procedure tod_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='tod'
then
declare cursor child_tod_factory is select tod_factory.tod_factoryid ID from tod_factory where  tod_factory.InstanceID = ainstanceid;
row_tod_factory  child_tod_factory%ROWTYPE;
begin
--open child_tod_factory;
for row_tod_factory in child_tod_factory loop
 tod_factory_DELETE (acursession,row_tod_factory.id,aInstanceID);
end loop;
--close child_tod_factory;
end;
declare cursor child_tod_bug is select tod_bug.tod_bugid ID from tod_bug where  tod_bug.InstanceID = ainstanceid;
row_tod_bug  child_tod_bug%ROWTYPE;
begin
--open child_tod_bug;
for row_tod_bug in child_tod_bug loop
 tod_bug_DELETE (acursession,row_tod_bug.id,aInstanceID);
end loop;
--close child_tod_bug;
end;
declare cursor child_tod_building is select tod_building.tod_buildingid ID from tod_building where  tod_building.InstanceID = ainstanceid;
row_tod_building  child_tod_building%ROWTYPE;
begin
--open child_tod_building;
for row_tod_building in child_tod_building loop
 tod_building_DELETE (acursession,row_tod_building.id,aInstanceID);
end loop;
--close child_tod_building;
end;
declare cursor child_tod_valtype is select tod_valtype.tod_valtypeid ID from tod_valtype where  tod_valtype.InstanceID = ainstanceid;
row_tod_valtype  child_tod_valtype%ROWTYPE;
begin
--open child_tod_valtype;
for row_tod_valtype in child_tod_valtype loop
 tod_valtype_DELETE (acursession,row_tod_valtype.id,aInstanceID);
end loop;
--close child_tod_valtype;
end;
declare cursor child_tod_model is select tod_model.tod_modelid ID from tod_model where  tod_model.InstanceID = ainstanceid;
row_tod_model  child_tod_model%ROWTYPE;
begin
--open child_tod_model;
for row_tod_model in child_tod_model loop
 tod_model_DELETE (acursession,row_tod_model.id,aInstanceID);
end loop;
--close child_tod_model;
end;
declare cursor child_tod_system is select tod_system.tod_systemid ID from tod_system where  tod_system.InstanceID = ainstanceid;
row_tod_system  child_tod_system%ROWTYPE;
begin
--open child_tod_system;
for row_tod_system in child_tod_system loop
 tod_system_DELETE (acursession,row_tod_system.id,aInstanceID);
end loop;
--close child_tod_system;
end;
declare cursor child_tod_oprole is select tod_oprole.tod_oproleid ID from tod_oprole where  tod_oprole.InstanceID = ainstanceid;
row_tod_oprole  child_tod_oprole%ROWTYPE;
begin
--open child_tod_oprole;
for row_tod_oprole in child_tod_oprole loop
 tod_oprole_DELETE (acursession,row_tod_oprole.id,aInstanceID);
end loop;
--close child_tod_oprole;
end;
declare cursor child_tod_trand is select tod_trand.tod_trandid ID from tod_trand where  tod_trand.InstanceID = ainstanceid;
row_tod_trand  child_tod_trand%ROWTYPE;
begin
--open child_tod_trand;
for row_tod_trand in child_tod_trand loop
 tod_trand_DELETE (acursession,row_tod_trand.id,aInstanceID);
end loop;
--close child_tod_trand;
end;
declare cursor child_tod_st is select tod_st.tod_stid ID from tod_st where  tod_st.InstanceID = ainstanceid;
row_tod_st  child_tod_st%ROWTYPE;
begin
--open child_tod_st;
for row_tod_st in child_tod_st loop
 tod_st_DELETE (acursession,row_tod_st.id,aInstanceID);
end loop;
--close child_tod_st;
end;
declare cursor child_tod_material is select tod_material.tod_materialid ID from tod_material where  tod_material.InstanceID = ainstanceid;
row_tod_material  child_tod_material%ROWTYPE;
begin
--open child_tod_material;
for row_tod_material in child_tod_material loop
 tod_material_DELETE (acursession,row_tod_material.id,aInstanceID);
end loop;
--close child_tod_material;
end;
declare cursor child_tod_edizm is select tod_edizm.tod_edizmid ID from tod_edizm where  tod_edizm.InstanceID = ainstanceid;
row_tod_edizm  child_tod_edizm%ROWTYPE;
begin
--open child_tod_edizm;
for row_tod_edizm in child_tod_edizm loop
 tod_edizm_DELETE (acursession,row_tod_edizm.id,aInstanceID);
end loop;
--close child_tod_edizm;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure tod_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'tod'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_tod_factory is select tod_factory.tod_factoryid ID from tod_factory where  tod_factory.InstanceID = arowid;
ROW_tod_factory  lch_tod_factory%ROWTYPE;
begin
--open lch_tod_factory;
for row_tod_factory in lch_tod_factory loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_factory where tod_factoryid=row_tod_factory.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_factory;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_factory;
     return;
   end if; 
 end if; 
 tod_factory_HCL (acursession,ROW_tod_factory.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_factory;
   return;
 end if;
 end loop;
--close lch_tod_factory;
end;
declare cursor lch_tod_bug is select tod_bug.tod_bugid ID from tod_bug where  tod_bug.InstanceID = arowid;
ROW_tod_bug  lch_tod_bug%ROWTYPE;
begin
--open lch_tod_bug;
for row_tod_bug in lch_tod_bug loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_bug where tod_bugid=row_tod_bug.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_bug;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_bug;
     return;
   end if; 
 end if; 
 tod_bug_HCL (acursession,ROW_tod_bug.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_bug;
   return;
 end if;
 end loop;
--close lch_tod_bug;
end;
declare cursor lch_tod_building is select tod_building.tod_buildingid ID from tod_building where  tod_building.InstanceID = arowid;
ROW_tod_building  lch_tod_building%ROWTYPE;
begin
--open lch_tod_building;
for row_tod_building in lch_tod_building loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_building where tod_buildingid=row_tod_building.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_building;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_building;
     return;
   end if; 
 end if; 
 tod_building_HCL (acursession,ROW_tod_building.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_building;
   return;
 end if;
 end loop;
--close lch_tod_building;
end;
declare cursor lch_tod_valtype is select tod_valtype.tod_valtypeid ID from tod_valtype where  tod_valtype.InstanceID = arowid;
ROW_tod_valtype  lch_tod_valtype%ROWTYPE;
begin
--open lch_tod_valtype;
for row_tod_valtype in lch_tod_valtype loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_valtype where tod_valtypeid=row_tod_valtype.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_valtype;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_valtype;
     return;
   end if; 
 end if; 
 tod_valtype_HCL (acursession,ROW_tod_valtype.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_valtype;
   return;
 end if;
 end loop;
--close lch_tod_valtype;
end;
declare cursor lch_tod_model is select tod_model.tod_modelid ID from tod_model where  tod_model.InstanceID = arowid;
ROW_tod_model  lch_tod_model%ROWTYPE;
begin
--open lch_tod_model;
for row_tod_model in lch_tod_model loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_model where tod_modelid=row_tod_model.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_model;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_model;
     return;
   end if; 
 end if; 
 tod_model_HCL (acursession,ROW_tod_model.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_model;
   return;
 end if;
 end loop;
--close lch_tod_model;
end;
declare cursor lch_tod_system is select tod_system.tod_systemid ID from tod_system where  tod_system.InstanceID = arowid;
ROW_tod_system  lch_tod_system%ROWTYPE;
begin
--open lch_tod_system;
for row_tod_system in lch_tod_system loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_system where tod_systemid=row_tod_system.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_system;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_system;
     return;
   end if; 
 end if; 
 tod_system_HCL (acursession,ROW_tod_system.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_system;
   return;
 end if;
 end loop;
--close lch_tod_system;
end;
declare cursor lch_tod_oprole is select tod_oprole.tod_oproleid ID from tod_oprole where  tod_oprole.InstanceID = arowid;
ROW_tod_oprole  lch_tod_oprole%ROWTYPE;
begin
--open lch_tod_oprole;
for row_tod_oprole in lch_tod_oprole loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_oprole where tod_oproleid=row_tod_oprole.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_oprole;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_oprole;
     return;
   end if; 
 end if; 
 tod_oprole_HCL (acursession,ROW_tod_oprole.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_oprole;
   return;
 end if;
 end loop;
--close lch_tod_oprole;
end;
declare cursor lch_tod_trand is select tod_trand.tod_trandid ID from tod_trand where  tod_trand.InstanceID = arowid;
ROW_tod_trand  lch_tod_trand%ROWTYPE;
begin
--open lch_tod_trand;
for row_tod_trand in lch_tod_trand loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_trand where tod_trandid=row_tod_trand.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_trand;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_trand;
     return;
   end if; 
 end if; 
 tod_trand_HCL (acursession,ROW_tod_trand.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_trand;
   return;
 end if;
 end loop;
--close lch_tod_trand;
end;
declare cursor lch_tod_st is select tod_st.tod_stid ID from tod_st where  tod_st.InstanceID = arowid;
ROW_tod_st  lch_tod_st%ROWTYPE;
begin
--open lch_tod_st;
for row_tod_st in lch_tod_st loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_st where tod_stid=row_tod_st.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_st;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_st;
     return;
   end if; 
 end if; 
 tod_st_HCL (acursession,ROW_tod_st.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_st;
   return;
 end if;
 end loop;
--close lch_tod_st;
end;
declare cursor lch_tod_material is select tod_material.tod_materialid ID from tod_material where  tod_material.InstanceID = arowid;
ROW_tod_material  lch_tod_material%ROWTYPE;
begin
--open lch_tod_material;
for row_tod_material in lch_tod_material loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_material where tod_materialid=row_tod_material.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_material;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_material;
     return;
   end if; 
 end if; 
 tod_material_HCL (acursession,ROW_tod_material.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_material;
   return;
 end if;
 end loop;
--close lch_tod_material;
end;
declare cursor lch_tod_edizm is select tod_edizm.tod_edizmid ID from tod_edizm where  tod_edizm.InstanceID = arowid;
ROW_tod_edizm  lch_tod_edizm%ROWTYPE;
begin
--open lch_tod_edizm;
for row_tod_edizm in lch_tod_edizm loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tod_edizm where tod_edizmid=row_tod_edizm.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tod_edizm;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tod_edizm;
     return;
   end if; 
 end if; 
 tod_edizm_HCL (acursession,ROW_tod_edizm.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tod_edizm;
   return;
 end if;
 end loop;
--close lch_tod_edizm;
end;
 end if;
aIsLocked:=0;
end;
procedure tod_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'tod'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_tod_factory is select tod_factory.tod_factoryid id from tod_factory where  tod_factory.InstanceID = arowid;
row_tod_factory  pch_tod_factory%ROWTYPE;
begin
--open pch_tod_factory;
for row_tod_factory in  pch_tod_factory loop
 tod_factory_SINIT( acursession,row_tod_factory.id,assid);
 tod_factory_propagate( acursession,row_tod_factory.id);
end loop;
--close pch_tod_factory;
end;
declare cursor pch_tod_bug is select tod_bug.tod_bugid id from tod_bug where  tod_bug.InstanceID = arowid;
row_tod_bug  pch_tod_bug%ROWTYPE;
begin
--open pch_tod_bug;
for row_tod_bug in  pch_tod_bug loop
 tod_bug_SINIT( acursession,row_tod_bug.id,assid);
 tod_bug_propagate( acursession,row_tod_bug.id);
end loop;
--close pch_tod_bug;
end;
declare cursor pch_tod_building is select tod_building.tod_buildingid id from tod_building where  tod_building.InstanceID = arowid;
row_tod_building  pch_tod_building%ROWTYPE;
begin
--open pch_tod_building;
for row_tod_building in  pch_tod_building loop
 tod_building_SINIT( acursession,row_tod_building.id,assid);
 tod_building_propagate( acursession,row_tod_building.id);
end loop;
--close pch_tod_building;
end;
declare cursor pch_tod_valtype is select tod_valtype.tod_valtypeid id from tod_valtype where  tod_valtype.InstanceID = arowid;
row_tod_valtype  pch_tod_valtype%ROWTYPE;
begin
--open pch_tod_valtype;
for row_tod_valtype in  pch_tod_valtype loop
 tod_valtype_SINIT( acursession,row_tod_valtype.id,assid);
 tod_valtype_propagate( acursession,row_tod_valtype.id);
end loop;
--close pch_tod_valtype;
end;
declare cursor pch_tod_model is select tod_model.tod_modelid id from tod_model where  tod_model.InstanceID = arowid;
row_tod_model  pch_tod_model%ROWTYPE;
begin
--open pch_tod_model;
for row_tod_model in  pch_tod_model loop
 tod_model_SINIT( acursession,row_tod_model.id,assid);
 tod_model_propagate( acursession,row_tod_model.id);
end loop;
--close pch_tod_model;
end;
declare cursor pch_tod_system is select tod_system.tod_systemid id from tod_system where  tod_system.InstanceID = arowid;
row_tod_system  pch_tod_system%ROWTYPE;
begin
--open pch_tod_system;
for row_tod_system in  pch_tod_system loop
 tod_system_SINIT( acursession,row_tod_system.id,assid);
 tod_system_propagate( acursession,row_tod_system.id);
end loop;
--close pch_tod_system;
end;
declare cursor pch_tod_oprole is select tod_oprole.tod_oproleid id from tod_oprole where  tod_oprole.InstanceID = arowid;
row_tod_oprole  pch_tod_oprole%ROWTYPE;
begin
--open pch_tod_oprole;
for row_tod_oprole in  pch_tod_oprole loop
 tod_oprole_SINIT( acursession,row_tod_oprole.id,assid);
 tod_oprole_propagate( acursession,row_tod_oprole.id);
end loop;
--close pch_tod_oprole;
end;
declare cursor pch_tod_trand is select tod_trand.tod_trandid id from tod_trand where  tod_trand.InstanceID = arowid;
row_tod_trand  pch_tod_trand%ROWTYPE;
begin
--open pch_tod_trand;
for row_tod_trand in  pch_tod_trand loop
 tod_trand_SINIT( acursession,row_tod_trand.id,assid);
 tod_trand_propagate( acursession,row_tod_trand.id);
end loop;
--close pch_tod_trand;
end;
declare cursor pch_tod_st is select tod_st.tod_stid id from tod_st where  tod_st.InstanceID = arowid;
row_tod_st  pch_tod_st%ROWTYPE;
begin
--open pch_tod_st;
for row_tod_st in  pch_tod_st loop
 tod_st_SINIT( acursession,row_tod_st.id,assid);
 tod_st_propagate( acursession,row_tod_st.id);
end loop;
--close pch_tod_st;
end;
declare cursor pch_tod_material is select tod_material.tod_materialid id from tod_material where  tod_material.InstanceID = arowid;
row_tod_material  pch_tod_material%ROWTYPE;
begin
--open pch_tod_material;
for row_tod_material in  pch_tod_material loop
 tod_material_SINIT( acursession,row_tod_material.id,assid);
 tod_material_propagate( acursession,row_tod_material.id);
end loop;
--close pch_tod_material;
end;
declare cursor pch_tod_edizm is select tod_edizm.tod_edizmid id from tod_edizm where  tod_edizm.InstanceID = arowid;
row_tod_edizm  pch_tod_edizm%ROWTYPE;
begin
--open pch_tod_edizm;
for row_tod_edizm in  pch_tod_edizm loop
 tod_edizm_SINIT( acursession,row_tod_edizm.id,assid);
 tod_edizm_propagate( acursession,row_tod_edizm.id);
end loop;
--close pch_tod_edizm;
end;
 end if; 
end;


procedure tod_factory_BRIEF  (
 aCURSESSION CHAR,
 atod_factoryid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_factoryid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_factory where tod_factoryID=atod_factoryID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_factory where tod_factoryid=atod_factoryID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_factory');
    return;
  end if;
  aBRIEF:=func.tod_factory_BRIEF_F(atod_factoryid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_factory_DELETE /**/ (
 aCURSESSION CHAR,
 atod_factoryid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_factory where tod_factoryID=atod_factoryID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_factory where tod_factoryid=atod_factoryID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_factory',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_factory');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_factory_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_factoryid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_factory');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_factory',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_factoryid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_factory is select  instanceid ID from instance where OwnerPartName ='tod_factory' and OwnerRowID=atod_factoryid;
row_tod_factory  chld_tod_factory%ROWTYPE;
begin
--open chld_tod_factory;
for row_tod_factory in chld_tod_factory loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_factory.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_factory.id);
end loop;
--close chld_tod_factory;
end ;
  delete from  tod_factory 
  where  tod_factoryID = atod_factoryID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Завод*/
procedure tod_factory_SAVE /**/ (
 aCURSESSION CHAR,
 atod_factoryid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Завод *//* Завод */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_factory where tod_factoryID=atod_factoryID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_factory where tod_factoryid=atod_factoryID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_factory',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_factory');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_factory_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_factoryid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_factory');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_factory',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_factoryid,aLogInstanceID=&gt;aInstanceID);
 update  tod_factory set ChangeStamp=sysdate
,
  name=aname
  where  tod_factoryID = atod_factoryID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_factory',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_factory');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_factory');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_factory',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_factoryid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_factory
 (  tod_factoryID 
,InstanceID
,name

 ) values ( atod_factoryID 
,aInstanceID
,aname

 ); 
 tod_factory_SINIT( aCURSESSION,atod_factoryid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_factory_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_factory where  tod_factoryid=aRowID;
 end; 

procedure tod_factory_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_factory where tod_factoryid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_factory_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_factory_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_factory_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_factory_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_factory where tod_factoryid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_factory');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_factory set LockUserID =auserID ,LockSessionID =null where tod_factoryid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_factory set LockUserID =null,LockSessionID =aCURSESSION  where tod_factoryid=aRowID;
     return;
   end if;
 end ;

procedure tod_factory_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_factory_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_factory_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_factory set LockUserID =null  where tod_factoryid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_factory set LockSessionID =null  where tod_factoryid=aRowID;
     return;
   end if;
 end; 

procedure tod_factory_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_factory where tod_factoryid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_factory');
    return;
  end if;
if aSecurityStyleID is null then
 tod_factory_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_factory set securitystyleid =aStyleID where tod_factoryid = aRowID;
else 
 update tod_factory set securitystyleid =aSecurityStyleID where tod_factoryid = aRowID;
end if; 
end ; 

procedure tod_factory_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_factory where tod_factoryid=aRowid;
end;


procedure tod_bug_BRIEF  (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_bugid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_bug where tod_bugID=atod_bugID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_bug where tod_bugid=atod_bugID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_bug');
    return;
  end if;
  aBRIEF:=func.tod_bug_BRIEF_F(atod_bugid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_bug_DELETE /**/ (
 aCURSESSION CHAR,
 atod_bugid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_bug where tod_bugID=atod_bugID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_bug where tod_bugid=atod_bugID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_bug',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_bug');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_bug_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_bugid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_bug');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_bug',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_bugid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_bug is select  instanceid ID from instance where OwnerPartName ='tod_bug' and OwnerRowID=atod_bugid;
row_tod_bug  chld_tod_bug%ROWTYPE;
begin
--open chld_tod_bug;
for row_tod_bug in chld_tod_bug loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_bug.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_bug.id);
end loop;
--close chld_tod_bug;
end ;
  delete from  tod_bug 
  where  tod_bugID = atod_bugID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Типичные проблемы*/
procedure tod_bug_SAVE /**/ (
 aCURSESSION CHAR,
 atod_bugid CHAR,
aInstanceID CHAR 
,athe_system CHAR := null /* Узел *//* Узел */
,aname
 VARCHAR2/* Название  *//* Название  */
,athe_comment VARCHAR2 := null /* Примечание *//* Примечание */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_bug where tod_bugID=atod_bugID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_bug where tod_bugid=atod_bugID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_bug',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_bug');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_bug_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_bugid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_bug');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_bug',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_bugid,aLogInstanceID=&gt;aInstanceID);
 update  tod_bug set ChangeStamp=sysdate
,
  the_system=athe_system
,
  name=aname
,
  the_comment=athe_comment
  where  tod_bugID = atod_bugID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_bug',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_bug');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_bug');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_bug',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_bugid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_bug
 (  tod_bugID 
,InstanceID
,the_system

,name

,the_comment

 ) values ( atod_bugID 
,aInstanceID
,athe_system

,aname

,athe_comment

 ); 
 tod_bug_SINIT( aCURSESSION,atod_bugid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_bug_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_bug where  tod_bugid=aRowID;
 end; 

procedure tod_bug_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_bug where tod_bugid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_bug_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_bug_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_bug_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_bug_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_bug where tod_bugid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_bug');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_bug set LockUserID =auserID ,LockSessionID =null where tod_bugid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_bug set LockUserID =null,LockSessionID =aCURSESSION  where tod_bugid=aRowID;
     return;
   end if;
 end ;

procedure tod_bug_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_bug_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_bug_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_bug set LockUserID =null  where tod_bugid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_bug set LockSessionID =null  where tod_bugid=aRowID;
     return;
   end if;
 end; 

procedure tod_bug_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_bug where tod_bugid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_bug');
    return;
  end if;
if aSecurityStyleID is null then
 tod_bug_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_bug set securitystyleid =aStyleID where tod_bugid = aRowID;
else 
 update tod_bug set securitystyleid =aSecurityStyleID where tod_bugid = aRowID;
end if; 
end ; 

procedure tod_bug_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_bug where tod_bugid=aRowid;
end;


procedure tod_building_BRIEF  (
 aCURSESSION CHAR,
 atod_buildingid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_buildingid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_building where tod_buildingID=atod_buildingID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_building where tod_buildingid=atod_buildingID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_building');
    return;
  end if;
  aBRIEF:=func.tod_building_BRIEF_F(atod_buildingid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_building_DELETE /**/ (
 aCURSESSION CHAR,
 atod_buildingid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_building where tod_buildingID=atod_buildingID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_building where tod_buildingid=atod_buildingID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_building',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_building');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_building_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_buildingid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_building');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_building',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_buildingid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_building is select  instanceid ID from instance where OwnerPartName ='tod_building' and OwnerRowID=atod_buildingid;
row_tod_building  chld_tod_building%ROWTYPE;
begin
--open chld_tod_building;
for row_tod_building in chld_tod_building loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_building.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_building.id);
end loop;
--close chld_tod_building;
end ;
  delete from  tod_building 
  where  tod_buildingID = atod_buildingID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Цех*/
procedure tod_building_SAVE /**/ (
 aCURSESSION CHAR,
 atod_buildingid CHAR,
aInstanceID CHAR 
,athefactory CHAR/* Завод *//* Завод */
,aname
 VARCHAR2/* Цех *//* Цех */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_building where tod_buildingID=atod_buildingID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_building where tod_buildingid=atod_buildingID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_building',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_building');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_building_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_buildingid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_building');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_building',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_buildingid,aLogInstanceID=&gt;aInstanceID);
 update  tod_building set ChangeStamp=sysdate
,
  thefactory=athefactory
,
  name=aname
  where  tod_buildingID = atod_buildingID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_building',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_building');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_building');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_building',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_buildingid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_building
 (  tod_buildingID 
,InstanceID
,thefactory

,name

 ) values ( atod_buildingID 
,aInstanceID
,athefactory

,aname

 ); 
 tod_building_SINIT( aCURSESSION,atod_buildingid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_building_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_building where  tod_buildingid=aRowID;
 end; 

procedure tod_building_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_building where tod_buildingid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_building_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_building_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_building_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_building_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_building where tod_buildingid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_building');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_building set LockUserID =auserID ,LockSessionID =null where tod_buildingid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_building set LockUserID =null,LockSessionID =aCURSESSION  where tod_buildingid=aRowID;
     return;
   end if;
 end ;

procedure tod_building_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_building_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_building_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_building set LockUserID =null  where tod_buildingid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_building set LockSessionID =null  where tod_buildingid=aRowID;
     return;
   end if;
 end; 

procedure tod_building_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_building where tod_buildingid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_building');
    return;
  end if;
if aSecurityStyleID is null then
 tod_building_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_building set securitystyleid =aStyleID where tod_buildingid = aRowID;
else 
 update tod_building set securitystyleid =aSecurityStyleID where tod_buildingid = aRowID;
end if; 
end ; 

procedure tod_building_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_building where tod_buildingid=aRowid;
end;


procedure tod_valtype_BRIEF  (
 aCURSESSION CHAR,
 atod_valtypeid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_valtypeid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_valtype where tod_valtypeID=atod_valtypeID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_valtype where tod_valtypeid=atod_valtypeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_valtype');
    return;
  end if;
  aBRIEF:=func.tod_valtype_BRIEF_F(atod_valtypeid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_valtype_DELETE /**/ (
 aCURSESSION CHAR,
 atod_valtypeid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_valtype where tod_valtypeID=atod_valtypeID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_valtype where tod_valtypeid=atod_valtypeID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_valtype',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_valtype');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_valtype_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_valtypeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_valtype');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_valtype',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_valtypeid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_valtype is select  instanceid ID from instance where OwnerPartName ='tod_valtype' and OwnerRowID=atod_valtypeid;
row_tod_valtype  chld_tod_valtype%ROWTYPE;
begin
--open chld_tod_valtype;
for row_tod_valtype in chld_tod_valtype loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_valtype.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_valtype.id);
end loop;
--close chld_tod_valtype;
end ;
  delete from  tod_valtype 
  where  tod_valtypeID = atod_valtypeID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Тип измерения*/
procedure tod_valtype_SAVE /**/ (
 aCURSESSION CHAR,
 atod_valtypeid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aedizm CHAR := null /* Ед. изм. *//* Ед. изм. */
,afieldtype CHAR := null /* Трактовка *//* Трактовка */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_valtype where tod_valtypeID=atod_valtypeID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_valtype where tod_valtypeid=atod_valtypeID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_valtype',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_valtype');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_valtype_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_valtypeid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_valtype');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_valtype',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_valtypeid,aLogInstanceID=&gt;aInstanceID);
 update  tod_valtype set ChangeStamp=sysdate
,
  name=aname
,
  edizm=aedizm
,
  fieldtype=afieldtype
  where  tod_valtypeID = atod_valtypeID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_valtype',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_valtype');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_valtype');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_valtype',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_valtypeid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_valtype
 (  tod_valtypeID 
,InstanceID
,name

,edizm

,fieldtype

 ) values ( atod_valtypeID 
,aInstanceID
,aname

,aedizm

,afieldtype

 ); 
 tod_valtype_SINIT( aCURSESSION,atod_valtypeid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_valtype_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_valtype where  tod_valtypeid=aRowID;
 end; 

procedure tod_valtype_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_valtype where tod_valtypeid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_valtype_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_valtype_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_valtype_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_valtype_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_valtype where tod_valtypeid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_valtype');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_valtype set LockUserID =auserID ,LockSessionID =null where tod_valtypeid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_valtype set LockUserID =null,LockSessionID =aCURSESSION  where tod_valtypeid=aRowID;
     return;
   end if;
 end ;

procedure tod_valtype_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_valtype_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_valtype_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_valtype set LockUserID =null  where tod_valtypeid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_valtype set LockSessionID =null  where tod_valtypeid=aRowID;
     return;
   end if;
 end; 

procedure tod_valtype_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_valtype where tod_valtypeid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_valtype');
    return;
  end if;
if aSecurityStyleID is null then
 tod_valtype_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_valtype set securitystyleid =aStyleID where tod_valtypeid = aRowID;
else 
 update tod_valtype set securitystyleid =aSecurityStyleID where tod_valtypeid = aRowID;
end if; 
end ; 

procedure tod_valtype_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_valtype where tod_valtypeid=aRowid;
end;


procedure tod_model_BRIEF  (
 aCURSESSION CHAR,
 atod_modelid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_modelid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_model where tod_modelID=atod_modelID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_model where tod_modelid=atod_modelID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_model');
    return;
  end if;
  aBRIEF:=func.tod_model_BRIEF_F(atod_modelid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_model_DELETE /**/ (
 aCURSESSION CHAR,
 atod_modelid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_model where tod_modelID=atod_modelID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_model where tod_modelid=atod_modelID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_model',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_model');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_model_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_modelid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_model');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_model',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_modelid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_model is select  instanceid ID from instance where OwnerPartName ='tod_model' and OwnerRowID=atod_modelid;
row_tod_model  chld_tod_model%ROWTYPE;
begin
--open chld_tod_model;
for row_tod_model in chld_tod_model loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_model.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_model.id);
end loop;
--close chld_tod_model;
end ;
  delete from  tod_model 
  where  tod_modelID = atod_modelID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Модели станков*/
procedure tod_model_SAVE /**/ (
 aCURSESSION CHAR,
 atod_modelid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_model where tod_modelID=atod_modelID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_model where tod_modelid=atod_modelID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_model',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_model');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_model_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_modelid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_model');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_model',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_modelid,aLogInstanceID=&gt;aInstanceID);
 update  tod_model set ChangeStamp=sysdate
,
  name=aname
  where  tod_modelID = atod_modelID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_model',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_model');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_model');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_model',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_modelid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_model
 (  tod_modelID 
,InstanceID
,name

 ) values ( atod_modelID 
,aInstanceID
,aname

 ); 
 tod_model_SINIT( aCURSESSION,atod_modelid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_model_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_model where  tod_modelid=aRowID;
 end; 

procedure tod_model_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_model where tod_modelid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_model_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_model_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_model_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_model_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_model where tod_modelid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_model');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_model set LockUserID =auserID ,LockSessionID =null where tod_modelid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_model set LockUserID =null,LockSessionID =aCURSESSION  where tod_modelid=aRowID;
     return;
   end if;
 end ;

procedure tod_model_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_model_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_model_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_model set LockUserID =null  where tod_modelid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_model set LockSessionID =null  where tod_modelid=aRowID;
     return;
   end if;
 end; 

procedure tod_model_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_model where tod_modelid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_model');
    return;
  end if;
if aSecurityStyleID is null then
 tod_model_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_model set securitystyleid =aStyleID where tod_modelid = aRowID;
else 
 update tod_model set securitystyleid =aSecurityStyleID where tod_modelid = aRowID;
end if; 
end ; 

procedure tod_model_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_model where tod_modelid=aRowid;
end;


procedure tod_system_BRIEF  (
 aCURSESSION CHAR,
 atod_systemid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_systemid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_system where tod_systemID=atod_systemID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_system where tod_systemid=atod_systemID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_system');
    return;
  end if;
  aBRIEF:=func.tod_system_BRIEF_F(atod_systemid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_system_DELETE /**/ (
 aCURSESSION CHAR,
 atod_systemid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_system where tod_systemID=atod_systemID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_system where tod_systemid=atod_systemID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_system',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_system');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_system_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_systemid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_system');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_system',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_systemid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_system is select  instanceid ID from instance where OwnerPartName ='tod_system' and OwnerRowID=atod_systemid;
row_tod_system  chld_tod_system%ROWTYPE;
begin
--open chld_tod_system;
for row_tod_system in chld_tod_system loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_system.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_system.id);
end loop;
--close chld_tod_system;
end ;
  delete from  tod_system 
  where  tod_systemID = atod_systemID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Группы узлов*/
procedure tod_system_SAVE /**/ (
 aCURSESSION CHAR,
 atod_systemid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_system where tod_systemID=atod_systemID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_system where tod_systemid=atod_systemID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_system',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_system');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_system_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_systemid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_system');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_system',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_systemid,aLogInstanceID=&gt;aInstanceID);
 update  tod_system set ChangeStamp=sysdate
,
  name=aname
  where  tod_systemID = atod_systemID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_system',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_system');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_system');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_system',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_systemid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_system
 (  tod_systemID 
,InstanceID
,name

 ) values ( atod_systemID 
,aInstanceID
,aname

 ); 
 tod_system_SINIT( aCURSESSION,atod_systemid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_system_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_system where  tod_systemid=aRowID;
 end; 

procedure tod_system_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_system where tod_systemid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_system_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_system_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_system_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_system_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_system where tod_systemid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_system');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_system set LockUserID =auserID ,LockSessionID =null where tod_systemid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_system set LockUserID =null,LockSessionID =aCURSESSION  where tod_systemid=aRowID;
     return;
   end if;
 end ;

procedure tod_system_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_system_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_system_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_system set LockUserID =null  where tod_systemid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_system set LockSessionID =null  where tod_systemid=aRowID;
     return;
   end if;
 end; 

procedure tod_system_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_system where tod_systemid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_system');
    return;
  end if;
if aSecurityStyleID is null then
 tod_system_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_system set securitystyleid =aStyleID where tod_systemid = aRowID;
else 
 update tod_system set securitystyleid =aSecurityStyleID where tod_systemid = aRowID;
end if; 
end ; 

procedure tod_system_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_system where tod_systemid=aRowid;
end;


procedure tod_oprole_BRIEF  (
 aCURSESSION CHAR,
 atod_oproleid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_oproleid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_oprole where tod_oproleID=atod_oproleID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_oprole where tod_oproleid=atod_oproleID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_oprole');
    return;
  end if;
  aBRIEF:=func.tod_oprole_BRIEF_F(atod_oproleid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_oprole_DELETE /**/ (
 aCURSESSION CHAR,
 atod_oproleid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_oprole where tod_oproleID=atod_oproleID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_oprole where tod_oproleid=atod_oproleID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_oprole',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_oprole');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_oprole_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_oproleid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_oprole');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_oprole',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_oproleid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_oprole is select  instanceid ID from instance where OwnerPartName ='tod_oprole' and OwnerRowID=atod_oproleid;
row_tod_oprole  chld_tod_oprole%ROWTYPE;
begin
--open chld_tod_oprole;
for row_tod_oprole in chld_tod_oprole loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_oprole.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_oprole.id);
end loop;
--close chld_tod_oprole;
end ;
  delete from  tod_oprole 
  where  tod_oproleID = atod_oproleID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Роль*/
procedure tod_oprole_SAVE /**/ (
 aCURSESSION CHAR,
 atod_oproleid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,adocmode
 VARCHAR2 := null /* Режим документов *//* Режим документов */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_oprole where tod_oproleID=atod_oproleID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_oprole where tod_oproleid=atod_oproleID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_oprole',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_oprole');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_oprole_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_oproleid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_oprole');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_oprole',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_oproleid,aLogInstanceID=&gt;aInstanceID);
 update  tod_oprole set ChangeStamp=sysdate
,
  name=aname
,
  docmode=adocmode
  where  tod_oproleID = atod_oproleID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_oprole',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_oprole');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_oprole');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_oprole',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_oproleid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_oprole
 (  tod_oproleID 
,InstanceID
,name

,docmode

 ) values ( atod_oproleID 
,aInstanceID
,aname

,adocmode

 ); 
 tod_oprole_SINIT( aCURSESSION,atod_oproleid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_oprole_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_oprole where  tod_oproleid=aRowID;
 end; 

procedure tod_oprole_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_oprole where tod_oproleid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_oprole_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_oprole_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_oprole_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_oprole_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_oprole where tod_oproleid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_oprole');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_oprole set LockUserID =auserID ,LockSessionID =null where tod_oproleid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_oprole set LockUserID =null,LockSessionID =aCURSESSION  where tod_oproleid=aRowID;
     return;
   end if;
 end ;

procedure tod_oprole_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_oprole_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_oprole_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_oprole set LockUserID =null  where tod_oproleid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_oprole set LockSessionID =null  where tod_oproleid=aRowID;
     return;
   end if;
 end; 

procedure tod_oprole_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_oprole where tod_oproleid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_oprole');
    return;
  end if;
if aSecurityStyleID is null then
 tod_oprole_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_oprole set securitystyleid =aStyleID where tod_oproleid = aRowID;
else 
 update tod_oprole set securitystyleid =aSecurityStyleID where tod_oproleid = aRowID;
end if; 
end ; 

procedure tod_oprole_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_oprole where tod_oproleid=aRowid;
end;


procedure tod_trand_BRIEF  (
 aCURSESSION CHAR,
 atod_trandid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_trandid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_trand where tod_trandID=atod_trandID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_trand where tod_trandid=atod_trandID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_trand');
    return;
  end if;
  aBRIEF:=func.tod_trand_BRIEF_F(atod_trandid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_trand_DELETE /**/ (
 aCURSESSION CHAR,
 atod_trandid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_trand where tod_trandID=atod_trandID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_trand where tod_trandid=atod_trandID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_trand',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_trand');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_trand_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_trandid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_trand');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_trand',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_trandid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_trand is select  instanceid ID from instance where OwnerPartName ='tod_trand' and OwnerRowID=atod_trandid;
row_tod_trand  chld_tod_trand%ROWTYPE;
begin
--open chld_tod_trand;
for row_tod_trand in chld_tod_trand loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_trand.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_trand.id);
end loop;
--close chld_tod_trand;
end ;
  delete from  tod_trand 
  where  tod_trandID = atod_trandID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Тип тренда*/
procedure tod_trand_SAVE /**/ (
 aCURSESSION CHAR,
 atod_trandid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_trand where tod_trandID=atod_trandID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_trand where tod_trandid=atod_trandID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_trand',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_trand');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_trand_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_trandid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_trand');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_trand',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_trandid,aLogInstanceID=&gt;aInstanceID);
 update  tod_trand set ChangeStamp=sysdate
,
  name=aname
  where  tod_trandID = atod_trandID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_trand',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_trand');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_trand');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_trand',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_trandid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_trand
 (  tod_trandID 
,InstanceID
,name

 ) values ( atod_trandID 
,aInstanceID
,aname

 ); 
 tod_trand_SINIT( aCURSESSION,atod_trandid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_trand_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_trand where  tod_trandid=aRowID;
 end; 

procedure tod_trand_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_trand where tod_trandid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_trand_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_trand_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_trand_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_trand_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_trand where tod_trandid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_trand');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_trand set LockUserID =auserID ,LockSessionID =null where tod_trandid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_trand set LockUserID =null,LockSessionID =aCURSESSION  where tod_trandid=aRowID;
     return;
   end if;
 end ;

procedure tod_trand_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_trand_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_trand_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_trand set LockUserID =null  where tod_trandid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_trand set LockSessionID =null  where tod_trandid=aRowID;
     return;
   end if;
 end; 

procedure tod_trand_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_trand where tod_trandid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_trand');
    return;
  end if;
if aSecurityStyleID is null then
 tod_trand_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_trand set securitystyleid =aStyleID where tod_trandid = aRowID;
else 
 update tod_trand set securitystyleid =aSecurityStyleID where tod_trandid = aRowID;
end if; 
end ; 

procedure tod_trand_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_trand where tod_trandid=aRowid;
end;


procedure tod_st_BRIEF  (
 aCURSESSION CHAR,
 atod_stid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_stid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_st where tod_stID=atod_stID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_st where tod_stid=atod_stID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_st');
    return;
  end if;
  aBRIEF:=func.tod_st_BRIEF_F(atod_stid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_st_DELETE /**/ (
 aCURSESSION CHAR,
 atod_stid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_st where tod_stID=atod_stID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_st where tod_stid=atod_stID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_st',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_st');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_st_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_stid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_st');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_st',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_stid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_st is select  instanceid ID from instance where OwnerPartName ='tod_st' and OwnerRowID=atod_stid;
row_tod_st  chld_tod_st%ROWTYPE;
begin
--open chld_tod_st;
for row_tod_st in chld_tod_st loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_st.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_st.id);
end loop;
--close chld_tod_st;
end ;
  delete from  tod_st 
  where  tod_stID = atod_stID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Станки*/
procedure tod_st_SAVE /**/ (
 aCURSESSION CHAR,
 atod_stid CHAR,
aInstanceID CHAR 
,ainvn
 VARCHAR2/* Инвентарный номер *//* Инвентарный номер */
,aname
 VARCHAR2/* Название *//* Название */
,athe_model CHAR := null /* Модель станка *//* Модель станка */
,athebuilding CHAR := null /* Цех *//* Цех */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_st where tod_stID=atod_stID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_st where tod_stid=atod_stID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_st',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_st');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_st_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_stid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_st');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_st',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_stid,aLogInstanceID=&gt;aInstanceID);
 update  tod_st set ChangeStamp=sysdate
,
  invn=ainvn
,
  name=aname
,
  the_model=athe_model
,
  thebuilding=athebuilding
  where  tod_stID = atod_stID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_st',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_st');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_st');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_st',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_stid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_st
 (  tod_stID 
,InstanceID
,invn

,name

,the_model

,thebuilding

 ) values ( atod_stID 
,aInstanceID
,ainvn

,aname

,athe_model

,athebuilding

 ); 
 tod_st_SINIT( aCURSESSION,atod_stid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_st_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_st where  tod_stid=aRowID;
 end; 

procedure tod_st_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_st where tod_stid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_st_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_st_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_st_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_st_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_st where tod_stid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_st');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_st set LockUserID =auserID ,LockSessionID =null where tod_stid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_st set LockUserID =null,LockSessionID =aCURSESSION  where tod_stid=aRowID;
     return;
   end if;
 end ;

procedure tod_st_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_st_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_st_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_st set LockUserID =null  where tod_stid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_st set LockSessionID =null  where tod_stid=aRowID;
     return;
   end if;
 end; 

procedure tod_st_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_st where tod_stid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_st');
    return;
  end if;
if aSecurityStyleID is null then
 tod_st_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_st set securitystyleid =aStyleID where tod_stid = aRowID;
else 
 update tod_st set securitystyleid =aSecurityStyleID where tod_stid = aRowID;
end if; 
end ; 

procedure tod_st_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_st where tod_stid=aRowid;
end;


procedure tod_material_BRIEF  (
 aCURSESSION CHAR,
 atod_materialid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_materialid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_material where tod_materialID=atod_materialID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_material where tod_materialid=atod_materialID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_material');
    return;
  end if;
  aBRIEF:=func.tod_material_BRIEF_F(atod_materialid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_material_DELETE /**/ (
 aCURSESSION CHAR,
 atod_materialid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_material where tod_materialID=atod_materialID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_material where tod_materialid=atod_materialID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_material',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_material');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_material_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_materialid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_material');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_material',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_materialid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_material is select  instanceid ID from instance where OwnerPartName ='tod_material' and OwnerRowID=atod_materialid;
row_tod_material  chld_tod_material%ROWTYPE;
begin
--open chld_tod_material;
for row_tod_material in chld_tod_material loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_material.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_material.id);
end loop;
--close chld_tod_material;
end ;
  delete from  tod_material 
  where  tod_materialID = atod_materialID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Материалы и инструменты*/
procedure tod_material_SAVE /**/ (
 aCURSESSION CHAR,
 atod_materialid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_material where tod_materialID=atod_materialID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_material where tod_materialid=atod_materialID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_material',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_material');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_material_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_materialid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_material');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_material',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_materialid,aLogInstanceID=&gt;aInstanceID);
 update  tod_material set ChangeStamp=sysdate
,
  name=aname
  where  tod_materialID = atod_materialID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_material',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_material');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_material');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_material',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_materialid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_material
 (  tod_materialID 
,InstanceID
,name

 ) values ( atod_materialID 
,aInstanceID
,aname

 ); 
 tod_material_SINIT( aCURSESSION,atod_materialid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_material_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_material where  tod_materialid=aRowID;
 end; 

procedure tod_material_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_material where tod_materialid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_material_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_material_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_material_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_material_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_material where tod_materialid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_material');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_material set LockUserID =auserID ,LockSessionID =null where tod_materialid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_material set LockUserID =null,LockSessionID =aCURSESSION  where tod_materialid=aRowID;
     return;
   end if;
 end ;

procedure tod_material_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_material_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_material_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_material set LockUserID =null  where tod_materialid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_material set LockSessionID =null  where tod_materialid=aRowID;
     return;
   end if;
 end; 

procedure tod_material_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_material where tod_materialid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_material');
    return;
  end if;
if aSecurityStyleID is null then
 tod_material_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_material set securitystyleid =aStyleID where tod_materialid = aRowID;
else 
 update tod_material set securitystyleid =aSecurityStyleID where tod_materialid = aRowID;
end if; 
end ; 

procedure tod_material_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_material where tod_materialid=aRowid;
end;


procedure tod_edizm_BRIEF  (
 aCURSESSION CHAR,
 atod_edizmid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atod_edizmid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tod_edizm where tod_edizmID=atod_edizmID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tod_edizm where tod_edizmid=atod_edizmID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tod_edizm');
    return;
  end if;
  aBRIEF:=func.tod_edizm_BRIEF_F(atod_edizmid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tod_edizm_DELETE /**/ (
 aCURSESSION CHAR,
 atod_edizmid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tod_edizm where tod_edizmID=atod_edizmID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tod_edizm where tod_edizmid=atod_edizmID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tod_edizm',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tod_edizm');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_edizm_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_edizmid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tod_edizm');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_edizm',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atod_edizmid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tod_edizm is select  instanceid ID from instance where OwnerPartName ='tod_edizm' and OwnerRowID=atod_edizmid;
row_tod_edizm  chld_tod_edizm%ROWTYPE;
begin
--open chld_tod_edizm;
for row_tod_edizm in chld_tod_edizm loop
 Kernel.INSTANCE_OWNER (acursession,row_tod_edizm.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tod_edizm.id);
end loop;
--close chld_tod_edizm;
end ;
  delete from  tod_edizm 
  where  tod_edizmID = atod_edizmID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Единицы измерения*/
procedure tod_edizm_SAVE /**/ (
 aCURSESSION CHAR,
 atod_edizmid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,afullname
 VARCHAR2 := null /* Полное наименование *//* Полное наименование */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tod_edizm where tod_edizmID=atod_edizmID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tod_edizm where tod_edizmid=atod_edizmID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tod_edizm',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tod_edizm');
      return;
    end if;
  end if;
 --  verify lock  --
 tod_edizm_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atod_edizmid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_edizm');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_edizm',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atod_edizmid,aLogInstanceID=&gt;aInstanceID);
 update  tod_edizm set ChangeStamp=sysdate
,
  name=aname
,
  fullname=afullname
  where  tod_edizmID = atod_edizmID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tod_edizm',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tod_edizm');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tod_edizm');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tod_edizm',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atod_edizmid,aLogInstanceID=&gt;aInstanceID);
 insert into   tod_edizm
 (  tod_edizmID 
,InstanceID
,name

,fullname

 ) values ( atod_edizmID 
,aInstanceID
,aname

,afullname

 ); 
 tod_edizm_SINIT( aCURSESSION,atod_edizmid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tod_edizm_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tod_edizm where  tod_edizmid=aRowID;
 end; 

procedure tod_edizm_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tod_edizm where tod_edizmid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tod_edizm_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tod.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tod_edizm_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tod_edizm_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tod_edizm_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tod_edizm where tod_edizmid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tod_edizm');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tod_edizm set LockUserID =auserID ,LockSessionID =null where tod_edizmid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tod_edizm set LockUserID =null,LockSessionID =aCURSESSION  where tod_edizmid=aRowID;
     return;
   end if;
 end ;

procedure tod_edizm_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tod_edizm_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tod_edizm_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tod_edizm set LockUserID =null  where tod_edizmid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tod_edizm set LockSessionID =null  where tod_edizmid=aRowID;
     return;
   end if;
 end; 

procedure tod_edizm_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tod_edizm where tod_edizmid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tod_edizm');
    return;
  end if;
if aSecurityStyleID is null then
 tod_edizm_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tod_edizm set securitystyleid =aStyleID where tod_edizmid = aRowID;
else 
 update tod_edizm set securitystyleid =aSecurityStyleID where tod_edizmid = aRowID;
end if; 
end ; 

procedure tod_edizm_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tod_edizm where tod_edizmid=aRowid;
end;
end tod;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--stdinfostore" BlockCode=" create or replace package body stdinfostore as

procedure stdinfostore_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='stdinfostore'
then
declare cursor child_folder is select folder.folderid ID from folder where  folder.InstanceID = ainstanceid;
row_folder  child_folder%ROWTYPE;
begin
--open child_folder;
for row_folder in child_folder loop
 folder_DELETE (acursession,row_folder.id,aInstanceID);
end loop;
--close child_folder;
end;
declare cursor child_infostoredef is select infostoredef.infostoredefid ID from infostoredef where  infostoredef.InstanceID = ainstanceid;
row_infostoredef  child_infostoredef%ROWTYPE;
begin
--open child_infostoredef;
for row_infostoredef in child_infostoredef loop
 infostoredef_DELETE (acursession,row_infostoredef.id,aInstanceID);
end loop;
--close child_infostoredef;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure stdinfostore_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'stdinfostore'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_folder is select folder.folderid ID from folder where  folder.InstanceID = arowid;
ROW_folder  lch_folder%ROWTYPE;
begin
--open lch_folder;
for row_folder in lch_folder loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from folder where folderid=row_folder.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_folder;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_folder;
     return;
   end if; 
 end if; 
 folder_HCL (acursession,ROW_folder.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_folder;
   return;
 end if;
 end loop;
--close lch_folder;
end;
declare cursor lch_infostoredef is select infostoredef.infostoredefid ID from infostoredef where  infostoredef.InstanceID = arowid;
ROW_infostoredef  lch_infostoredef%ROWTYPE;
begin
--open lch_infostoredef;
for row_infostoredef in lch_infostoredef loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from infostoredef where infostoredefid=row_infostoredef.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_infostoredef;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_infostoredef;
     return;
   end if; 
 end if; 
 infostoredef_HCL (acursession,ROW_infostoredef.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_infostoredef;
   return;
 end if;
 end loop;
--close lch_infostoredef;
end;
 end if;
aIsLocked:=0;
end;
procedure stdinfostore_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'stdinfostore'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_folder is select folder.folderid id from folder where  folder.InstanceID = arowid;
row_folder  pch_folder%ROWTYPE;
begin
--open pch_folder;
for row_folder in  pch_folder loop
 folder_SINIT( acursession,row_folder.id,assid);
 folder_propagate( acursession,row_folder.id);
end loop;
--close pch_folder;
end;
declare cursor pch_infostoredef is select infostoredef.infostoredefid id from infostoredef where  infostoredef.InstanceID = arowid;
row_infostoredef  pch_infostoredef%ROWTYPE;
begin
--open pch_infostoredef;
for row_infostoredef in  pch_infostoredef loop
 infostoredef_SINIT( acursession,row_infostoredef.id,assid);
 infostoredef_propagate( acursession,row_infostoredef.id);
end loop;
--close pch_infostoredef;
end;
 end if; 
end;


procedure folder_BRIEF  (
 aCURSESSION CHAR,
 afolderid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afolderid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from folder where folderID=afolderID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from folder where folderid=afolderID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=folder');
    return;
  end if;
  aBRIEF:=func.folder_BRIEF_F(afolderid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure folder_DELETE /*Папка каталога*/ (
 aCURSESSION CHAR,
 afolderid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from folder where folderID=afolderID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from folder where folderid=afolderID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:folder',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=folder');
      return;
    end if;
  end if;
 --  verify lock  --
 folder_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afolderid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=folder');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_shortcut is select shortcut.shortcutid ID from shortcut where  shortcut.ParentStructRowID = afolderid;
    child_shortcut_rec  child_shortcut%ROWTYPE;
    begin
    --open child_shortcut;
      for child_shortcut_rec in child_shortcut loop
      shortcut_DELETE (acursession,child_shortcut_rec.id,aInstanceid);
      end loop;
      --close child_shortcut;
    end ;
declare cursor chld_folder is select  instanceid ID from instance where OwnerPartName ='folder' and OwnerRowID=afolderid;
row_folder  chld_folder%ROWTYPE;
begin
--open chld_folder;
for row_folder in chld_folder loop
 Kernel.INSTANCE_OWNER (acursession,row_folder.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_folder.id);
end loop;
--close chld_folder;
end ;
  delete from  folder 
  where  folderID = afolderID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Папка*/
procedure folder_SAVE /*Папка каталога*/ (
 aCURSESSION CHAR,
 afolderid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aname
 VARCHAR2/* Название *//* Название */
,afoldertype
 NUMBER/* Тип папки *//* Тип папки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from folder where folderID=afolderID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from folder where folderid=afolderID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:folder',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=folder');
      return;
    end if;
  end if;
 --  verify lock  --
 folder_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afolderid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=folder');
    return;
  end if;
 -- update row  --
 update  folder set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  name=aname
,
  foldertype=afoldertype
  where  folderID = afolderID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:folder',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=folder');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=folder');
    return;
  end if;
 insert into   folder
 (  folderID 
,ParentRowid
,InstanceID
,name

,foldertype

 ) values ( afolderID 
,aParentRowid
,aInstanceID
,aname

,afoldertype

 ); 
 folder_SINIT( aCURSESSION,afolderid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure folder_PARENT /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from folder where  folderid=aRowID;
 end; 

procedure folder_ISLOCKED /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from folder where folderid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  folder_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin stdinfostore.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure folder_LOCK /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 folder_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  folder_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from folder where folderid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=folder');
    return;
  end if;
   if  aLockMode =2  
   then   
    update folder set LockUserID =auserID ,LockSessionID =null where folderid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update folder set LockUserID =null,LockSessionID =aCURSESSION  where folderid=aRowID;
     return;
   end if;
 end ;

procedure folder_HCL /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_shortcut is select shortcut.shortcutid ID from shortcut where  shortcut.ParentStructRowID = aRowid;
row_shortcut lch_shortcut%ROWTYPE;
begin  
--open lch_shortcut;
for row_shortcut in lch_shortcut
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from shortcut where shortcutid=row_shortcut.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_shortcut;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_shortcut;
     return;
   end if; 
 end if;  
 shortcut_HCL (acursession,row_shortcut.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_shortcut;
   return;
 end if;
end loop;
--close lch_shortcut;
end;
aIsLocked :=0;
end;

procedure folder_UNLOCK /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 folder_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update folder set LockUserID =null  where folderid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update folder set LockSessionID =null  where folderid=aRowID;
     return;
   end if;
 end; 

procedure folder_SINIT /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from folder where folderid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =folder');
    return;
  end if;
if aSecurityStyleID is null then
 folder_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update folder set securitystyleid =aStyleID where folderid = aRowID;
else 
 update folder set securitystyleid =aSecurityStyleID where folderid = aRowID;
end if; 
end ; 

procedure folder_propagate /*Папка каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from folder where folderid=aRowid;
declare cursor pch_shortcut  is select shortcut.shortcutid ID from shortcut where  shortcut.ParentStructRowID = aRowid;
row_shortcut  pch_shortcut%ROWTYPE;
begin
--open pch_shortcut;
for row_shortcut in pch_shortcut loop
   shortcut_SINIT( acursession,row_shortcut.id,assid);
   shortcut_propagate( acursession,row_shortcut.id);
end loop;
--close pch_shortcut;
end;
end;


procedure shortcut_BRIEF  (
 aCURSESSION CHAR,
 ashortcutid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ashortcutid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from shortcut where shortcutID=ashortcutID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from shortcut where shortcutid=ashortcutID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=shortcut');
    return;
  end if;
  aBRIEF:=func.shortcut_BRIEF_F(ashortcutid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure shortcut_DELETE /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 ashortcutid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from shortcut where shortcutID=ashortcutID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from shortcut where shortcutid=ashortcutID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:shortcut',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=shortcut');
      return;
    end if;
  end if;
 --  verify lock  --
 shortcut_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ashortcutid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=shortcut');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_shortcut is select  instanceid ID from instance where OwnerPartName ='shortcut' and OwnerRowID=ashortcutid;
row_shortcut  chld_shortcut%ROWTYPE;
begin
--open chld_shortcut;
for row_shortcut in chld_shortcut loop
 Kernel.INSTANCE_OWNER (acursession,row_shortcut.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_shortcut.id);
end loop;
--close chld_shortcut;
end ;
  delete from  shortcut 
  where  shortcutID = ashortcutID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Документы*/
procedure shortcut_SAVE /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 ashortcutid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,adocitem CHAR/* Документ *//* Документ */
,astartmode
 VARCHAR2 := null /* Режим *//* Режим */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from shortcut where shortcutID=ashortcutID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from shortcut where shortcutid=ashortcutID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:shortcut',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=shortcut');
      return;
    end if;
  end if;
 --  verify lock  --
 shortcut_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ashortcutid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=shortcut');
    return;
  end if;
 -- update row  --
 update  shortcut set ChangeStamp=sysdate
,
  docitem=adocitem
,
  startmode=astartmode
  where  shortcutID = ashortcutID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from folder where folderid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:shortcut',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=shortcut');
      return;
    end if;
 end if;
 folder_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=shortcut');
    return;
  end if;
 insert into   shortcut
 (  shortcutID 
,ParentStructRowID
,docitem

,startmode

 ) values ( ashortcutID 
,aParentStructRowID
,adocitem

,astartmode

 ); 
 shortcut_SINIT( aCURSESSION,ashortcutid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure shortcut_PARENT /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from shortcut where  shortcutid=aRowID;
  aParentTable := 'folder';
 end; 

procedure shortcut_ISLOCKED /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from shortcut where shortcutid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  shortcut_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin stdinfostore.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure shortcut_LOCK /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 shortcut_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  shortcut_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from shortcut where shortcutid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=shortcut');
    return;
  end if;
   if  aLockMode =2  
   then   
    update shortcut set LockUserID =auserID ,LockSessionID =null where shortcutid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update shortcut set LockUserID =null,LockSessionID =aCURSESSION  where shortcutid=aRowID;
     return;
   end if;
 end ;

procedure shortcut_HCL /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure shortcut_UNLOCK /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 shortcut_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update shortcut set LockUserID =null  where shortcutid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update shortcut set LockSessionID =null  where shortcutid=aRowID;
     return;
   end if;
 end; 

procedure shortcut_SINIT /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from shortcut where shortcutid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =shortcut');
    return;
  end if;
if aSecurityStyleID is null then
 shortcut_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update shortcut set securitystyleid =aStyleID where shortcutid = aRowID;
else 
 update shortcut set securitystyleid =aSecurityStyleID where shortcutid = aRowID;
end if; 
end ; 

procedure shortcut_propagate /*Ярлыки документов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from shortcut where shortcutid=aRowid;
end;


procedure infostoredef_BRIEF  (
 aCURSESSION CHAR,
 ainfostoredefid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ainfostoredefid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from infostoredef where infostoredefID=ainfostoredefID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from infostoredef where infostoredefid=ainfostoredefID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=infostoredef');
    return;
  end if;
  aBRIEF:=func.infostoredef_BRIEF_F(ainfostoredefid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure infostoredef_DELETE /*Описание каталога*/ (
 aCURSESSION CHAR,
 ainfostoredefid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from infostoredef where infostoredefID=ainfostoredefID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from infostoredef where infostoredefid=ainfostoredefID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:infostoredef',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=infostoredef');
      return;
    end if;
  end if;
 --  verify lock  --
 infostoredef_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ainfostoredefid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=infostoredef');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_infostoredef is select  instanceid ID from instance where OwnerPartName ='infostoredef' and OwnerRowID=ainfostoredefid;
row_infostoredef  chld_infostoredef%ROWTYPE;
begin
--open chld_infostoredef;
for row_infostoredef in chld_infostoredef loop
 Kernel.INSTANCE_OWNER (acursession,row_infostoredef.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_infostoredef.id);
end loop;
--close chld_infostoredef;
end ;
  delete from  infostoredef 
  where  infostoredefID = ainfostoredefID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure infostoredef_SAVE /*Описание каталога*/ (
 aCURSESSION CHAR,
 ainfostoredefid CHAR,
aInstanceID CHAR 
,athegroup CHAR := null /* Группа *//* Группа */
,aname
 VARCHAR2/* Название *//* Название */
,ainfostoretype
 NUMBER/* Тип каталога *//* Тип каталога */
,atheuser CHAR := null /* Пользователь *//* Пользователь */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from infostoredef where infostoredefID=ainfostoredefID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from infostoredef where infostoredefid=ainfostoredefID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:infostoredef',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=infostoredef');
      return;
    end if;
  end if;
 --  verify lock  --
 infostoredef_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ainfostoredefid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=infostoredef');
    return;
  end if;
 -- update row  --
 update  infostoredef set ChangeStamp=sysdate
,
  thegroup=athegroup
,
  name=aname
,
  infostoretype=ainfostoretype
,
  theuser=atheuser
  where  infostoredefID = ainfostoredefID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:infostoredef',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=infostoredef');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=infostoredef');
    return;
  end if;
select Count(*) into existsCnt from infostoredef where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;infostoredef&gt;');
    return;
 End if;
 insert into   infostoredef
 (  infostoredefID 
,InstanceID
,thegroup

,name

,infostoretype

,theuser

 ) values ( ainfostoredefID 
,aInstanceID
,athegroup

,aname

,ainfostoretype

,atheuser

 ); 
 infostoredef_SINIT( aCURSESSION,ainfostoredefid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure infostoredef_PARENT /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from infostoredef where  infostoredefid=aRowID;
 end; 

procedure infostoredef_ISLOCKED /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from infostoredef where infostoredefid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  infostoredef_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin stdinfostore.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure infostoredef_LOCK /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 infostoredef_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  infostoredef_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from infostoredef where infostoredefid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=infostoredef');
    return;
  end if;
   if  aLockMode =2  
   then   
    update infostoredef set LockUserID =auserID ,LockSessionID =null where infostoredefid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update infostoredef set LockUserID =null,LockSessionID =aCURSESSION  where infostoredefid=aRowID;
     return;
   end if;
 end ;

procedure infostoredef_HCL /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure infostoredef_UNLOCK /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 infostoredef_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update infostoredef set LockUserID =null  where infostoredefid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update infostoredef set LockSessionID =null  where infostoredefid=aRowID;
     return;
   end if;
 end; 

procedure infostoredef_SINIT /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from infostoredef where infostoredefid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =infostoredef');
    return;
  end if;
if aSecurityStyleID is null then
 infostoredef_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update infostoredef set securitystyleid =aStyleID where infostoredefid = aRowID;
else 
 update infostoredef set securitystyleid =aSecurityStyleID where infostoredefid = aRowID;
end if; 
end ; 

procedure infostoredef_propagate /*Описание каталога*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from infostoredef where infostoredefid=aRowid;
end;
end stdinfostore;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzsystem" BlockCode=" create or replace package body mtzsystem as

procedure mtzsystem_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzsystem'
then
declare cursor child_the_session is select the_session.the_sessionid ID from the_session where  the_session.InstanceID = ainstanceid;
row_the_session  child_the_session%ROWTYPE;
begin
--open child_the_session;
for row_the_session in child_the_session loop
 the_session_DELETE (acursession,row_the_session.id,aInstanceID);
end loop;
--close child_the_session;
end;
declare cursor child_sysrefcache is select sysrefcache.sysrefcacheid ID from sysrefcache where  sysrefcache.InstanceID = ainstanceid;
row_sysrefcache  child_sysrefcache%ROWTYPE;
begin
--open child_sysrefcache;
for row_sysrefcache in child_sysrefcache loop
 sysrefcache_DELETE (acursession,row_sysrefcache.id,aInstanceID);
end loop;
--close child_sysrefcache;
end;
declare cursor child_syslog is select syslog.syslogid ID from syslog where  syslog.InstanceID = ainstanceid;
row_syslog  child_syslog%ROWTYPE;
begin
--open child_syslog;
for row_syslog in child_syslog loop
 syslog_DELETE (acursession,row_syslog.id,aInstanceID);
end loop;
--close child_syslog;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzsystem_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzsystem'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_the_session is select the_session.the_sessionid ID from the_session where  the_session.InstanceID = arowid;
ROW_the_session  lch_the_session%ROWTYPE;
begin
--open lch_the_session;
for row_the_session in lch_the_session loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from the_session where the_sessionid=row_the_session.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_the_session;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_the_session;
     return;
   end if; 
 end if; 
 the_session_HCL (acursession,ROW_the_session.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_the_session;
   return;
 end if;
 end loop;
--close lch_the_session;
end;
declare cursor lch_sysrefcache is select sysrefcache.sysrefcacheid ID from sysrefcache where  sysrefcache.InstanceID = arowid;
ROW_sysrefcache  lch_sysrefcache%ROWTYPE;
begin
--open lch_sysrefcache;
for row_sysrefcache in lch_sysrefcache loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from sysrefcache where sysrefcacheid=row_sysrefcache.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_sysrefcache;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_sysrefcache;
     return;
   end if; 
 end if; 
 sysrefcache_HCL (acursession,ROW_sysrefcache.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_sysrefcache;
   return;
 end if;
 end loop;
--close lch_sysrefcache;
end;
declare cursor lch_syslog is select syslog.syslogid ID from syslog where  syslog.InstanceID = arowid;
ROW_syslog  lch_syslog%ROWTYPE;
begin
--open lch_syslog;
for row_syslog in lch_syslog loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from syslog where syslogid=row_syslog.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_syslog;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_syslog;
     return;
   end if; 
 end if; 
 syslog_HCL (acursession,ROW_syslog.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_syslog;
   return;
 end if;
 end loop;
--close lch_syslog;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzsystem_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzsystem'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_the_session is select the_session.the_sessionid id from the_session where  the_session.InstanceID = arowid;
row_the_session  pch_the_session%ROWTYPE;
begin
--open pch_the_session;
for row_the_session in  pch_the_session loop
 the_session_SINIT( acursession,row_the_session.id,assid);
 the_session_propagate( acursession,row_the_session.id);
end loop;
--close pch_the_session;
end;
declare cursor pch_sysrefcache is select sysrefcache.sysrefcacheid id from sysrefcache where  sysrefcache.InstanceID = arowid;
row_sysrefcache  pch_sysrefcache%ROWTYPE;
begin
--open pch_sysrefcache;
for row_sysrefcache in  pch_sysrefcache loop
 sysrefcache_SINIT( acursession,row_sysrefcache.id,assid);
 sysrefcache_propagate( acursession,row_sysrefcache.id);
end loop;
--close pch_sysrefcache;
end;
declare cursor pch_syslog is select syslog.syslogid id from syslog where  syslog.InstanceID = arowid;
row_syslog  pch_syslog%ROWTYPE;
begin
--open pch_syslog;
for row_syslog in  pch_syslog loop
 syslog_SINIT( acursession,row_syslog.id,assid);
 syslog_propagate( acursession,row_syslog.id);
end loop;
--close pch_syslog;
end;
 end if; 
end;


procedure the_session_BRIEF  (
 aCURSESSION CHAR,
 athe_sessionid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if athe_sessionid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from the_session where the_sessionID=athe_sessionID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from the_session where the_sessionid=athe_sessionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=the_session');
    return;
  end if;
  aBRIEF:=func.the_session_BRIEF_F(athe_sessionid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure the_session_DELETE /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 athe_sessionid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from the_session where the_sessionID=athe_sessionID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from the_session where the_sessionid=athe_sessionID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:the_session',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=the_session');
      return;
    end if;
  end if;
 --  verify lock  --
 the_session_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;athe_sessionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=the_session');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_the_session is select  instanceid ID from instance where OwnerPartName ='the_session' and OwnerRowID=athe_sessionid;
row_the_session  chld_the_session%ROWTYPE;
begin
--open chld_the_session;
for row_the_session in chld_the_session loop
 Kernel.INSTANCE_OWNER (acursession,row_the_session.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_the_session.id);
end loop;
--close chld_the_session;
end ;
  delete from  the_session 
  where  the_sessionID = athe_sessionID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Сессия пользователя*/
procedure the_session_SAVE /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 athe_sessionid CHAR,
aInstanceID CHAR 
,aapplicationid CHAR := null /* Приложение *//* Приложение */
,auserrole CHAR/* Текущая роль пользователя *//* Текущая роль пользователя */
,aclosedat
 DATE := null /* Момент закрытия *//* Момент закрытия */
,aclosed
 NUMBER/* Закрыта *//* Закрыта */
,ausersid CHAR/* Пользователь *//* Пользователь */
,alastaccess
 DATE := null /* Последнее подтверждение *//* Последнее подтверждение */
,astartat
 DATE/* Момент открытия *//* Момент открытия */
,alang
 VARCHAR2 := null /* Локализация *//* Локализация */
,alogin
 VARCHAR2 := null /* Login *//* Login */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from the_session where the_sessionID=athe_sessionID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from the_session where the_sessionid=athe_sessionID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:the_session',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=the_session');
      return;
    end if;
  end if;
 --  verify lock  --
 the_session_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;athe_sessionid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=the_session');
    return;
  end if;
 -- update row  --
 update  the_session set ChangeStamp=sysdate
,
  applicationid=aapplicationid
,
  userrole=auserrole
,
  closedat=aclosedat
,
  closed=aclosed
,
  usersid=ausersid
,
  lastaccess=alastaccess
,
  startat=astartat
,
  lang=alang
,
  login=alogin
  where  the_sessionID = athe_sessionID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:the_session',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=the_session');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=the_session');
    return;
  end if;
 insert into   the_session
 (  the_sessionID 
,InstanceID
,applicationid

,userrole

,closedat

,closed

,usersid

,lastaccess

,startat

,lang

,login

 ) values ( athe_sessionID 
,aInstanceID
,aapplicationid

,auserrole

,aclosedat

,aclosed

,ausersid

,alastaccess

,astartat

,alang

,alogin

 ); 
 the_session_SINIT( aCURSESSION,athe_sessionid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure the_session_PARENT /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from the_session where  the_sessionid=aRowID;
 end; 

procedure the_session_ISLOCKED /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from the_session where the_sessionid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  the_session_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzsystem.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure the_session_LOCK /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 the_session_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  the_session_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from the_session where the_sessionid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=the_session');
    return;
  end if;
   if  aLockMode =2  
   then   
    update the_session set LockUserID =auserID ,LockSessionID =null where the_sessionid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update the_session set LockUserID =null,LockSessionID =aCURSESSION  where the_sessionid=aRowID;
     return;
   end if;
 end ;

procedure the_session_HCL /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure the_session_UNLOCK /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 the_session_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update the_session set LockUserID =null  where the_sessionid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update the_session set LockSessionID =null  where the_sessionid=aRowID;
     return;
   end if;
 end; 

procedure the_session_SINIT /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from the_session where the_sessionid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =the_session');
    return;
  end if;
if aSecurityStyleID is null then
 the_session_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update the_session set securitystyleid =aStyleID where the_sessionid = aRowID;
else 
 update the_session set securitystyleid =aSecurityStyleID where the_sessionid = aRowID;
end if; 
end ; 

procedure the_session_propagate /*Зарегистрированные сессии пользователей*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from the_session where the_sessionid=aRowid;
end;


procedure sysrefcache_BRIEF  (
 aCURSESSION CHAR,
 asysrefcacheid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if asysrefcacheid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from sysrefcache where sysrefcacheID=asysrefcacheID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from sysrefcache where sysrefcacheid=asysrefcacheID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=sysrefcache');
    return;
  end if;
  aBRIEF:=func.sysrefcache_BRIEF_F(asysrefcacheid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure sysrefcache_DELETE /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 asysrefcacheid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from sysrefcache where sysrefcacheID=asysrefcacheID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from sysrefcache where sysrefcacheid=asysrefcacheID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:sysrefcache',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=sysrefcache');
      return;
    end if;
  end if;
 --  verify lock  --
 sysrefcache_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;asysrefcacheid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=sysrefcache');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_sysrefcache is select  instanceid ID from instance where OwnerPartName ='sysrefcache' and OwnerRowID=asysrefcacheid;
row_sysrefcache  chld_sysrefcache%ROWTYPE;
begin
--open chld_sysrefcache;
for row_sysrefcache in chld_sysrefcache loop
 Kernel.INSTANCE_OWNER (acursession,row_sysrefcache.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_sysrefcache.id);
end loop;
--close chld_sysrefcache;
end ;
  delete from  sysrefcache 
  where  sysrefcacheID = asysrefcacheID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Разрешенные владельцы*/
procedure sysrefcache_SAVE /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 asysrefcacheid CHAR,
aInstanceID CHAR 
,acachetype
 NUMBER/* Тип кеширования *//* Тип кеширования */
,aobjectownerid CHAR/* Идентификатор владельца *//* Идентификатор владельца */
,asessionid CHAR/* Сессия *//* Сессия */
,amodulename
 VARCHAR2 := null /* модуль *//* модуль */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from sysrefcache where sysrefcacheID=asysrefcacheID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from sysrefcache where sysrefcacheid=asysrefcacheID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:sysrefcache',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=sysrefcache');
      return;
    end if;
  end if;
 --  verify lock  --
 sysrefcache_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;asysrefcacheid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=sysrefcache');
    return;
  end if;
 -- update row  --
 update  sysrefcache set ChangeStamp=sysdate
,
  cachetype=acachetype
,
  objectownerid=aobjectownerid
,
  sessionid=asessionid
,
  modulename=amodulename
  where  sysrefcacheID = asysrefcacheID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:sysrefcache',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=sysrefcache');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=sysrefcache');
    return;
  end if;
 insert into   sysrefcache
 (  sysrefcacheID 
,InstanceID
,cachetype

,objectownerid

,sessionid

,modulename

 ) values ( asysrefcacheID 
,aInstanceID
,acachetype

,aobjectownerid

,asessionid

,amodulename

 ); 
 sysrefcache_SINIT( aCURSESSION,asysrefcacheid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure sysrefcache_PARENT /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from sysrefcache where  sysrefcacheid=aRowID;
 end; 

procedure sysrefcache_ISLOCKED /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from sysrefcache where sysrefcacheid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  sysrefcache_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzsystem.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure sysrefcache_LOCK /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 sysrefcache_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  sysrefcache_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from sysrefcache where sysrefcacheid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=sysrefcache');
    return;
  end if;
   if  aLockMode =2  
   then   
    update sysrefcache set LockUserID =auserID ,LockSessionID =null where sysrefcacheid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update sysrefcache set LockUserID =null,LockSessionID =aCURSESSION  where sysrefcacheid=aRowID;
     return;
   end if;
 end ;

procedure sysrefcache_HCL /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure sysrefcache_UNLOCK /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 sysrefcache_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update sysrefcache set LockUserID =null  where sysrefcacheid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update sysrefcache set LockSessionID =null  where sysrefcacheid=aRowID;
     return;
   end if;
 end; 

procedure sysrefcache_SINIT /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from sysrefcache where sysrefcacheid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =sysrefcache');
    return;
  end if;
if aSecurityStyleID is null then
 sysrefcache_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update sysrefcache set securitystyleid =aStyleID where sysrefcacheid = aRowID;
else 
 update sysrefcache set securitystyleid =aSecurityStyleID where sysrefcacheid = aRowID;
end if; 
end ; 

procedure sysrefcache_propagate /*владельцы информации для к объектам которых
разрешен достуа для  текущей сесии*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from sysrefcache where sysrefcacheid=aRowid;
end;


procedure syslog_BRIEF  (
 aCURSESSION CHAR,
 asyslogid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if asyslogid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from syslog where syslogID=asyslogID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from syslog where syslogid=asyslogID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=syslog');
    return;
  end if;
  aBRIEF:=func.syslog_BRIEF_F(asyslogid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure syslog_DELETE /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 asyslogid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from syslog where syslogID=asyslogID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from syslog where syslogid=asyslogID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:syslog',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=syslog');
      return;
    end if;
  end if;
 --  verify lock  --
 syslog_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;asyslogid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=syslog');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_syslog is select  instanceid ID from instance where OwnerPartName ='syslog' and OwnerRowID=asyslogid;
row_syslog  chld_syslog%ROWTYPE;
begin
--open chld_syslog;
for row_syslog in chld_syslog loop
 Kernel.INSTANCE_OWNER (acursession,row_syslog.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_syslog.id);
end loop;
--close chld_syslog;
end ;
  delete from  syslog 
  where  syslogID = asyslogID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Журнал событий*/
procedure syslog_SAVE /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 asyslogid CHAR,
aInstanceID CHAR 
,athesession CHAR/* Сессия *//* Сессия */
,athe_resource
 VARCHAR2/* Ресурс *//* Ресурс */
,alogstructid
 VARCHAR2/* Раздел с которым происхоит действие *//* Раздел с которым происхоит действие */
,averb
 VARCHAR2/* Действие *//* Действие */
,aloginstanceid CHAR := null /* Идентификатор документа *//* Идентификатор документа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from syslog where syslogID=asyslogID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from syslog where syslogid=asyslogID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:syslog',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=syslog');
      return;
    end if;
  end if;
 --  verify lock  --
 syslog_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;asyslogid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=syslog');
    return;
  end if;
 -- update row  --
 update  syslog set ChangeStamp=sysdate
,
  thesession=athesession
,
  the_resource=athe_resource
,
  logstructid=alogstructid
,
  verb=averb
,
  loginstanceid=aloginstanceid
  where  syslogID = asyslogID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:syslog',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=syslog');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=syslog');
    return;
  end if;
 insert into   syslog
 (  syslogID 
,InstanceID
,thesession

,the_resource

,logstructid

,verb

,loginstanceid

 ) values ( asyslogID 
,aInstanceID
,athesession

,athe_resource

,alogstructid

,averb

,aloginstanceid

 ); 
 syslog_SINIT( aCURSESSION,asyslogid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure syslog_PARENT /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from syslog where  syslogid=aRowID;
 end; 

procedure syslog_ISLOCKED /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from syslog where syslogid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  syslog_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzsystem.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure syslog_LOCK /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 syslog_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  syslog_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from syslog where syslogid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=syslog');
    return;
  end if;
   if  aLockMode =2  
   then   
    update syslog set LockUserID =auserID ,LockSessionID =null where syslogid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update syslog set LockUserID =null,LockSessionID =aCURSESSION  where syslogid=aRowID;
     return;
   end if;
 end ;

procedure syslog_HCL /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure syslog_UNLOCK /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 syslog_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update syslog set LockUserID =null  where syslogid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update syslog set LockSessionID =null  where syslogid=aRowID;
     return;
   end if;
 end; 

procedure syslog_SINIT /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from syslog where syslogid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =syslog');
    return;
  end if;
if aSecurityStyleID is null then
 syslog_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update syslog set securitystyleid =aStyleID where syslogid = aRowID;
else 
 update syslog set securitystyleid =aSecurityStyleID where syslogid = aRowID;
end if; 
end ; 

procedure syslog_propagate /*Журнал событий, которые произошли в системе*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from syslog where syslogid=aRowid;
end;
end mtzsystem;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzwp" BlockCode=" create or replace package body mtzwp as

procedure mtzwp_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzwp'
then
declare cursor child_armjournal is select armjournal.armjournalid ID from armjournal where  armjournal.InstanceID = ainstanceid;
row_armjournal  child_armjournal%ROWTYPE;
begin
--open child_armjournal;
for row_armjournal in child_armjournal loop
 armjournal_DELETE (acursession,row_armjournal.id,aInstanceID);
end loop;
--close child_armjournal;
end;
declare cursor child_entrypoints is select entrypoints.entrypointsid ID from entrypoints where  entrypoints.InstanceID = ainstanceid;
row_entrypoints  child_entrypoints%ROWTYPE;
begin
--open child_entrypoints;
for row_entrypoints in child_entrypoints loop
 entrypoints_DELETE (acursession,row_entrypoints.id,aInstanceID);
end loop;
--close child_entrypoints;
end;
declare cursor child_workplace is select workplace.workplaceid ID from workplace where  workplace.InstanceID = ainstanceid;
row_workplace  child_workplace%ROWTYPE;
begin
--open child_workplace;
for row_workplace in child_workplace loop
 workplace_DELETE (acursession,row_workplace.id,aInstanceID);
end loop;
--close child_workplace;
end;
declare cursor child_armtypes is select armtypes.armtypesid ID from armtypes where  armtypes.InstanceID = ainstanceid;
row_armtypes  child_armtypes%ROWTYPE;
begin
--open child_armtypes;
for row_armtypes in child_armtypes loop
 armtypes_DELETE (acursession,row_armtypes.id,aInstanceID);
end loop;
--close child_armtypes;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzwp_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzwp'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_armjournal is select armjournal.armjournalid ID from armjournal where  armjournal.InstanceID = arowid;
ROW_armjournal  lch_armjournal%ROWTYPE;
begin
--open lch_armjournal;
for row_armjournal in lch_armjournal loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from armjournal where armjournalid=row_armjournal.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_armjournal;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_armjournal;
     return;
   end if; 
 end if; 
 armjournal_HCL (acursession,ROW_armjournal.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_armjournal;
   return;
 end if;
 end loop;
--close lch_armjournal;
end;
declare cursor lch_entrypoints is select entrypoints.entrypointsid ID from entrypoints where  entrypoints.InstanceID = arowid;
ROW_entrypoints  lch_entrypoints%ROWTYPE;
begin
--open lch_entrypoints;
for row_entrypoints in lch_entrypoints loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from entrypoints where entrypointsid=row_entrypoints.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_entrypoints;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_entrypoints;
     return;
   end if; 
 end if; 
 entrypoints_HCL (acursession,ROW_entrypoints.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_entrypoints;
   return;
 end if;
 end loop;
--close lch_entrypoints;
end;
declare cursor lch_workplace is select workplace.workplaceid ID from workplace where  workplace.InstanceID = arowid;
ROW_workplace  lch_workplace%ROWTYPE;
begin
--open lch_workplace;
for row_workplace in lch_workplace loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from workplace where workplaceid=row_workplace.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_workplace;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_workplace;
     return;
   end if; 
 end if; 
 workplace_HCL (acursession,ROW_workplace.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_workplace;
   return;
 end if;
 end loop;
--close lch_workplace;
end;
declare cursor lch_armtypes is select armtypes.armtypesid ID from armtypes where  armtypes.InstanceID = arowid;
ROW_armtypes  lch_armtypes%ROWTYPE;
begin
--open lch_armtypes;
for row_armtypes in lch_armtypes loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from armtypes where armtypesid=row_armtypes.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_armtypes;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_armtypes;
     return;
   end if; 
 end if; 
 armtypes_HCL (acursession,ROW_armtypes.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_armtypes;
   return;
 end if;
 end loop;
--close lch_armtypes;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzwp_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzwp'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_armjournal is select armjournal.armjournalid id from armjournal where  armjournal.InstanceID = arowid;
row_armjournal  pch_armjournal%ROWTYPE;
begin
--open pch_armjournal;
for row_armjournal in  pch_armjournal loop
 armjournal_SINIT( acursession,row_armjournal.id,assid);
 armjournal_propagate( acursession,row_armjournal.id);
end loop;
--close pch_armjournal;
end;
declare cursor pch_entrypoints is select entrypoints.entrypointsid id from entrypoints where  entrypoints.InstanceID = arowid;
row_entrypoints  pch_entrypoints%ROWTYPE;
begin
--open pch_entrypoints;
for row_entrypoints in  pch_entrypoints loop
 entrypoints_SINIT( acursession,row_entrypoints.id,assid);
 entrypoints_propagate( acursession,row_entrypoints.id);
end loop;
--close pch_entrypoints;
end;
declare cursor pch_workplace is select workplace.workplaceid id from workplace where  workplace.InstanceID = arowid;
row_workplace  pch_workplace%ROWTYPE;
begin
--open pch_workplace;
for row_workplace in  pch_workplace loop
 workplace_SINIT( acursession,row_workplace.id,assid);
 workplace_propagate( acursession,row_workplace.id);
end loop;
--close pch_workplace;
end;
declare cursor pch_armtypes is select armtypes.armtypesid id from armtypes where  armtypes.InstanceID = arowid;
row_armtypes  pch_armtypes%ROWTYPE;
begin
--open pch_armtypes;
for row_armtypes in  pch_armtypes loop
 armtypes_SINIT( acursession,row_armtypes.id,assid);
 armtypes_propagate( acursession,row_armtypes.id);
end loop;
--close pch_armtypes;
end;
 end if; 
end;


procedure armjournal_BRIEF  (
 aCURSESSION CHAR,
 aarmjournalid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aarmjournalid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from armjournal where armjournalID=aarmjournalID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from armjournal where armjournalid=aarmjournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=armjournal');
    return;
  end if;
  aBRIEF:=func.armjournal_BRIEF_F(aarmjournalid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure armjournal_DELETE /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aarmjournalid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from armjournal where armjournalID=aarmjournalID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from armjournal where armjournalid=aarmjournalID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:armjournal',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=armjournal');
      return;
    end if;
  end if;
 --  verify lock  --
 armjournal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=armjournal');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_armjrnlrep is select armjrnlrep.armjrnlrepid ID from armjrnlrep where  armjrnlrep.ParentStructRowID = aarmjournalid;
    child_armjrnlrep_rec  child_armjrnlrep%ROWTYPE;
    begin
    --open child_armjrnlrep;
      for child_armjrnlrep_rec in child_armjrnlrep loop
      armjrnlrep_DELETE (acursession,child_armjrnlrep_rec.id,aInstanceid);
      end loop;
      --close child_armjrnlrep;
    end ;
    declare cursor child_armjrnlrun is select armjrnlrun.armjrnlrunid ID from armjrnlrun where  armjrnlrun.ParentStructRowID = aarmjournalid;
    child_armjrnlrun_rec  child_armjrnlrun%ROWTYPE;
    begin
    --open child_armjrnlrun;
      for child_armjrnlrun_rec in child_armjrnlrun loop
      armjrnlrun_DELETE (acursession,child_armjrnlrun_rec.id,aInstanceid);
      end loop;
      --close child_armjrnlrun;
    end ;
    declare cursor child_armjrnladd is select armjrnladd.armjrnladdid ID from armjrnladd where  armjrnladd.ParentStructRowID = aarmjournalid;
    child_armjrnladd_rec  child_armjrnladd%ROWTYPE;
    begin
    --open child_armjrnladd;
      for child_armjrnladd_rec in child_armjrnladd loop
      armjrnladd_DELETE (acursession,child_armjrnladd_rec.id,aInstanceid);
      end loop;
      --close child_armjrnladd;
    end ;
declare cursor chld_armjournal is select  instanceid ID from instance where OwnerPartName ='armjournal' and OwnerRowID=aarmjournalid;
row_armjournal  chld_armjournal%ROWTYPE;
begin
--open chld_armjournal;
for row_armjournal in chld_armjournal loop
 Kernel.INSTANCE_OWNER (acursession,row_armjournal.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_armjournal.id);
end loop;
--close chld_armjournal;
end ;
  delete from  armjournal 
  where  armjournalID = aarmjournalID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поведение журналов*/
procedure armjournal_SAVE /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aarmjournalid CHAR,
aInstanceID CHAR 
,athejournal CHAR/* Журнал *//* Журнал */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from armjournal where armjournalID=aarmjournalID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from armjournal where armjournalid=aarmjournalID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:armjournal',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=armjournal');
      return;
    end if;
  end if;
 --  verify lock  --
 armjournal_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjournalid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjournal');
    return;
  end if;
 -- update row  --
 update  armjournal set ChangeStamp=sysdate
,
  thejournal=athejournal
  where  armjournalID = aarmjournalID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:armjournal',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=armjournal');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjournal');
    return;
  end if;
 insert into   armjournal
 (  armjournalID 
,InstanceID
,thejournal

 ) values ( aarmjournalID 
,aInstanceID
,athejournal

 ); 
 armjournal_SINIT( aCURSESSION,aarmjournalid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure armjournal_PARENT /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from armjournal where  armjournalid=aRowID;
 end; 

procedure armjournal_ISLOCKED /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from armjournal where armjournalid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  armjournal_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure armjournal_LOCK /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 armjournal_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  armjournal_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from armjournal where armjournalid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=armjournal');
    return;
  end if;
   if  aLockMode =2  
   then   
    update armjournal set LockUserID =auserID ,LockSessionID =null where armjournalid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update armjournal set LockUserID =null,LockSessionID =aCURSESSION  where armjournalid=aRowID;
     return;
   end if;
 end ;

procedure armjournal_HCL /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_armjrnlrep is select armjrnlrep.armjrnlrepid ID from armjrnlrep where  armjrnlrep.ParentStructRowID = aRowid;
row_armjrnlrep lch_armjrnlrep%ROWTYPE;
begin  
--open lch_armjrnlrep;
for row_armjrnlrep in lch_armjrnlrep
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from armjrnlrep where armjrnlrepid=row_armjrnlrep.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_armjrnlrep;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_armjrnlrep;
     return;
   end if; 
 end if;  
 armjrnlrep_HCL (acursession,row_armjrnlrep.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_armjrnlrep;
   return;
 end if;
end loop;
--close lch_armjrnlrep;
end;
declare cursor lch_armjrnlrun is select armjrnlrun.armjrnlrunid ID from armjrnlrun where  armjrnlrun.ParentStructRowID = aRowid;
row_armjrnlrun lch_armjrnlrun%ROWTYPE;
begin  
--open lch_armjrnlrun;
for row_armjrnlrun in lch_armjrnlrun
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from armjrnlrun where armjrnlrunid=row_armjrnlrun.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_armjrnlrun;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_armjrnlrun;
     return;
   end if; 
 end if;  
 armjrnlrun_HCL (acursession,row_armjrnlrun.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_armjrnlrun;
   return;
 end if;
end loop;
--close lch_armjrnlrun;
end;
declare cursor lch_armjrnladd is select armjrnladd.armjrnladdid ID from armjrnladd where  armjrnladd.ParentStructRowID = aRowid;
row_armjrnladd lch_armjrnladd%ROWTYPE;
begin  
--open lch_armjrnladd;
for row_armjrnladd in lch_armjrnladd
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from armjrnladd where armjrnladdid=row_armjrnladd.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_armjrnladd;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_armjrnladd;
     return;
   end if; 
 end if;  
 armjrnladd_HCL (acursession,row_armjrnladd.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_armjrnladd;
   return;
 end if;
end loop;
--close lch_armjrnladd;
end;
aIsLocked :=0;
end;

procedure armjournal_UNLOCK /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 armjournal_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update armjournal set LockUserID =null  where armjournalid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update armjournal set LockSessionID =null  where armjournalid=aRowID;
     return;
   end if;
 end; 

procedure armjournal_SINIT /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from armjournal where armjournalid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =armjournal');
    return;
  end if;
if aSecurityStyleID is null then
 armjournal_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update armjournal set securitystyleid =aStyleID where armjournalid = aRowID;
else 
 update armjournal set securitystyleid =aSecurityStyleID where armjournalid = aRowID;
end if; 
end ; 

procedure armjournal_propagate /*Описание действий журанлов*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from armjournal where armjournalid=aRowid;
declare cursor pch_armjrnlrep  is select armjrnlrep.armjrnlrepid ID from armjrnlrep where  armjrnlrep.ParentStructRowID = aRowid;
row_armjrnlrep  pch_armjrnlrep%ROWTYPE;
begin
--open pch_armjrnlrep;
for row_armjrnlrep in pch_armjrnlrep loop
   armjrnlrep_SINIT( acursession,row_armjrnlrep.id,assid);
   armjrnlrep_propagate( acursession,row_armjrnlrep.id);
end loop;
--close pch_armjrnlrep;
end;
declare cursor pch_armjrnlrun  is select armjrnlrun.armjrnlrunid ID from armjrnlrun where  armjrnlrun.ParentStructRowID = aRowid;
row_armjrnlrun  pch_armjrnlrun%ROWTYPE;
begin
--open pch_armjrnlrun;
for row_armjrnlrun in pch_armjrnlrun loop
   armjrnlrun_SINIT( acursession,row_armjrnlrun.id,assid);
   armjrnlrun_propagate( acursession,row_armjrnlrun.id);
end loop;
--close pch_armjrnlrun;
end;
declare cursor pch_armjrnladd  is select armjrnladd.armjrnladdid ID from armjrnladd where  armjrnladd.ParentStructRowID = aRowid;
row_armjrnladd  pch_armjrnladd%ROWTYPE;
begin
--open pch_armjrnladd;
for row_armjrnladd in pch_armjrnladd loop
   armjrnladd_SINIT( acursession,row_armjrnladd.id,assid);
   armjrnladd_propagate( acursession,row_armjrnladd.id);
end loop;
--close pch_armjrnladd;
end;
end;


procedure armjrnlrep_BRIEF  (
 aCURSESSION CHAR,
 aarmjrnlrepid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aarmjrnlrepid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from armjrnlrep where armjrnlrepID=aarmjrnlrepID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from armjrnlrep where armjrnlrepid=aarmjrnlrepID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=armjrnlrep');
    return;
  end if;
  aBRIEF:=func.armjrnlrep_BRIEF_F(aarmjrnlrepid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure armjrnlrep_DELETE /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aarmjrnlrepid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from armjrnlrep where armjrnlrepID=aarmjrnlrepID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from armjrnlrep where armjrnlrepid=aarmjrnlrepID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:armjrnlrep',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=armjrnlrep');
      return;
    end if;
  end if;
 --  verify lock  --
 armjrnlrep_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjrnlrepid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=armjrnlrep');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_armjrnlrep is select  instanceid ID from instance where OwnerPartName ='armjrnlrep' and OwnerRowID=aarmjrnlrepid;
row_armjrnlrep  chld_armjrnlrep%ROWTYPE;
begin
--open chld_armjrnlrep;
for row_armjrnlrep in chld_armjrnlrep loop
 Kernel.INSTANCE_OWNER (acursession,row_armjrnlrep.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_armjrnlrep.id);
end loop;
--close chld_armjrnlrep;
end ;
  delete from  armjrnlrep 
  where  armjrnlrepID = aarmjrnlrepID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отчеты*/
procedure armjrnlrep_SAVE /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aarmjrnlrepid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,arepname
 VARCHAR2/* Название отчета *//* Название отчета */
,athereport CHAR/* Отчет *//* Отчет */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from armjrnlrep where armjrnlrepID=aarmjrnlrepID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from armjrnlrep where armjrnlrepid=aarmjrnlrepID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:armjrnlrep',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=armjrnlrep');
      return;
    end if;
  end if;
 --  verify lock  --
 armjrnlrep_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjrnlrepid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjrnlrep');
    return;
  end if;
 -- update row  --
 update  armjrnlrep set ChangeStamp=sysdate
,
  repname=arepname
,
  thereport=athereport
  where  armjrnlrepID = aarmjrnlrepID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from armjournal where armjournalid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:armjrnlrep',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=armjrnlrep');
      return;
    end if;
 end if;
 armjournal_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjrnlrep');
    return;
  end if;
 insert into   armjrnlrep
 (  armjrnlrepID 
,ParentStructRowID
,repname

,thereport

 ) values ( aarmjrnlrepID 
,aParentStructRowID
,arepname

,athereport

 ); 
 armjrnlrep_SINIT( aCURSESSION,aarmjrnlrepid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure armjrnlrep_PARENT /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from armjrnlrep where  armjrnlrepid=aRowID;
  aParentTable := 'armjournal';
 end; 

procedure armjrnlrep_ISLOCKED /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from armjrnlrep where armjrnlrepid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  armjrnlrep_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure armjrnlrep_LOCK /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 armjrnlrep_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  armjrnlrep_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from armjrnlrep where armjrnlrepid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=armjrnlrep');
    return;
  end if;
   if  aLockMode =2  
   then   
    update armjrnlrep set LockUserID =auserID ,LockSessionID =null where armjrnlrepid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update armjrnlrep set LockUserID =null,LockSessionID =aCURSESSION  where armjrnlrepid=aRowID;
     return;
   end if;
 end ;

procedure armjrnlrep_HCL /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure armjrnlrep_UNLOCK /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 armjrnlrep_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update armjrnlrep set LockUserID =null  where armjrnlrepid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update armjrnlrep set LockSessionID =null  where armjrnlrepid=aRowID;
     return;
   end if;
 end; 

procedure armjrnlrep_SINIT /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from armjrnlrep where armjrnlrepid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =armjrnlrep');
    return;
  end if;
if aSecurityStyleID is null then
 armjrnlrep_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update armjrnlrep set securitystyleid =aStyleID where armjrnlrepid = aRowID;
else 
 update armjrnlrep set securitystyleid =aSecurityStyleID where armjrnlrepid = aRowID;
end if; 
end ; 

procedure armjrnlrep_propagate /*Отчеты из журнала*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from armjrnlrep where armjrnlrepid=aRowid;
end;


procedure armjrnlrun_BRIEF  (
 aCURSESSION CHAR,
 aarmjrnlrunid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aarmjrnlrunid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from armjrnlrun where armjrnlrunID=aarmjrnlrunID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from armjrnlrun where armjrnlrunid=aarmjrnlrunID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=armjrnlrun');
    return;
  end if;
  aBRIEF:=func.armjrnlrun_BRIEF_F(aarmjrnlrunid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure armjrnlrun_DELETE /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aarmjrnlrunid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from armjrnlrun where armjrnlrunID=aarmjrnlrunID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from armjrnlrun where armjrnlrunid=aarmjrnlrunID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:armjrnlrun',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=armjrnlrun');
      return;
    end if;
  end if;
 --  verify lock  --
 armjrnlrun_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjrnlrunid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=armjrnlrun');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_armjrnlrun is select  instanceid ID from instance where OwnerPartName ='armjrnlrun' and OwnerRowID=aarmjrnlrunid;
row_armjrnlrun  chld_armjrnlrun%ROWTYPE;
begin
--open chld_armjrnlrun;
for row_armjrnlrun in chld_armjrnlrun loop
 Kernel.INSTANCE_OWNER (acursession,row_armjrnlrun.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_armjrnlrun.id);
end loop;
--close chld_armjrnlrun;
end ;
  delete from  armjrnlrun 
  where  armjrnlrunID = aarmjrnlrunID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Действия*/
procedure armjrnlrun_SAVE /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aarmjrnlrunid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atheextention CHAR/* Расширение *//* Расширение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from armjrnlrun where armjrnlrunID=aarmjrnlrunID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from armjrnlrun where armjrnlrunid=aarmjrnlrunID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:armjrnlrun',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=armjrnlrun');
      return;
    end if;
  end if;
 --  verify lock  --
 armjrnlrun_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjrnlrunid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjrnlrun');
    return;
  end if;
 -- update row  --
 update  armjrnlrun set ChangeStamp=sysdate
,
  name=aname
,
  theextention=atheextention
  where  armjrnlrunID = aarmjrnlrunID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from armjournal where armjournalid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:armjrnlrun',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=armjrnlrun');
      return;
    end if;
 end if;
 armjournal_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjrnlrun');
    return;
  end if;
 insert into   armjrnlrun
 (  armjrnlrunID 
,ParentStructRowID
,name

,theextention

 ) values ( aarmjrnlrunID 
,aParentStructRowID
,aname

,atheextention

 ); 
 armjrnlrun_SINIT( aCURSESSION,aarmjrnlrunid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure armjrnlrun_PARENT /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from armjrnlrun where  armjrnlrunid=aRowID;
  aParentTable := 'armjournal';
 end; 

procedure armjrnlrun_ISLOCKED /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from armjrnlrun where armjrnlrunid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  armjrnlrun_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure armjrnlrun_LOCK /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 armjrnlrun_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  armjrnlrun_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from armjrnlrun where armjrnlrunid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=armjrnlrun');
    return;
  end if;
   if  aLockMode =2  
   then   
    update armjrnlrun set LockUserID =auserID ,LockSessionID =null where armjrnlrunid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update armjrnlrun set LockUserID =null,LockSessionID =aCURSESSION  where armjrnlrunid=aRowID;
     return;
   end if;
 end ;

procedure armjrnlrun_HCL /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure armjrnlrun_UNLOCK /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 armjrnlrun_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update armjrnlrun set LockUserID =null  where armjrnlrunid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update armjrnlrun set LockSessionID =null  where armjrnlrunid=aRowID;
     return;
   end if;
 end; 

procedure armjrnlrun_SINIT /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from armjrnlrun where armjrnlrunid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =armjrnlrun');
    return;
  end if;
if aSecurityStyleID is null then
 armjrnlrun_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update armjrnlrun set securitystyleid =aStyleID where armjrnlrunid = aRowID;
else 
 update armjrnlrun set securitystyleid =aSecurityStyleID where armjrnlrunid = aRowID;
end if; 
end ; 

procedure armjrnlrun_propagate /*Дополнительные действия в журнале*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from armjrnlrun where armjrnlrunid=aRowid;
end;


procedure armjrnladd_BRIEF  (
 aCURSESSION CHAR,
 aarmjrnladdid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aarmjrnladdid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from armjrnladd where armjrnladdID=aarmjrnladdID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from armjrnladd where armjrnladdid=aarmjrnladdID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=armjrnladd');
    return;
  end if;
  aBRIEF:=func.armjrnladd_BRIEF_F(aarmjrnladdid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure armjrnladd_DELETE /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aarmjrnladdid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from armjrnladd where armjrnladdID=aarmjrnladdID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from armjrnladd where armjrnladdid=aarmjrnladdID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:armjrnladd',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=armjrnladd');
      return;
    end if;
  end if;
 --  verify lock  --
 armjrnladd_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjrnladdid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=armjrnladd');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_armjrnladd is select  instanceid ID from instance where OwnerPartName ='armjrnladd' and OwnerRowID=aarmjrnladdid;
row_armjrnladd  chld_armjrnladd%ROWTYPE;
begin
--open chld_armjrnladd;
for row_armjrnladd in chld_armjrnladd loop
 Kernel.INSTANCE_OWNER (acursession,row_armjrnladd.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_armjrnladd.id);
end loop;
--close chld_armjrnladd;
end ;
  delete from  armjrnladd 
  where  armjrnladdID = aarmjrnladdID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Добавление*/
procedure armjrnladd_SAVE /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aarmjrnladdid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,atheextention CHAR/* Расширение *//* Расширение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from armjrnladd where armjrnladdID=aarmjrnladdID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from armjrnladd where armjrnladdid=aarmjrnladdID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:armjrnladd',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=armjrnladd');
      return;
    end if;
  end if;
 --  verify lock  --
 armjrnladd_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmjrnladdid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjrnladd');
    return;
  end if;
 -- update row  --
 update  armjrnladd set ChangeStamp=sysdate
,
  name=aname
,
  theextention=atheextention
  where  armjrnladdID = aarmjrnladdID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from armjournal where armjournalid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:armjrnladd',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=armjrnladd');
      return;
    end if;
 end if;
 armjournal_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armjrnladd');
    return;
  end if;
 insert into   armjrnladd
 (  armjrnladdID 
,ParentStructRowID
,name

,theextention

 ) values ( aarmjrnladdID 
,aParentStructRowID
,aname

,atheextention

 ); 
 armjrnladd_SINIT( aCURSESSION,aarmjrnladdid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure armjrnladd_PARENT /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from armjrnladd where  armjrnladdid=aRowID;
  aParentTable := 'armjournal';
 end; 

procedure armjrnladd_ISLOCKED /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from armjrnladd where armjrnladdid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  armjrnladd_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure armjrnladd_LOCK /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 armjrnladd_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  armjrnladd_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from armjrnladd where armjrnladdid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=armjrnladd');
    return;
  end if;
   if  aLockMode =2  
   then   
    update armjrnladd set LockUserID =auserID ,LockSessionID =null where armjrnladdid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update armjrnladd set LockUserID =null,LockSessionID =aCURSESSION  where armjrnladdid=aRowID;
     return;
   end if;
 end ;

procedure armjrnladd_HCL /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure armjrnladd_UNLOCK /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 armjrnladd_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update armjrnladd set LockUserID =null  where armjrnladdid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update armjrnladd set LockSessionID =null  where armjrnladdid=aRowID;
     return;
   end if;
 end; 

procedure armjrnladd_SINIT /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from armjrnladd where armjrnladdid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =armjrnladd');
    return;
  end if;
if aSecurityStyleID is null then
 armjrnladd_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update armjrnladd set securitystyleid =aStyleID where armjrnladdid = aRowID;
else 
 update armjrnladd set securitystyleid =aSecurityStyleID where armjrnladdid = aRowID;
end if; 
end ; 

procedure armjrnladd_propagate /*Варианты обработки добавления*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from armjrnladd where armjrnladdid=aRowid;
end;


procedure entrypoints_BRIEF  (
 aCURSESSION CHAR,
 aentrypointsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aentrypointsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from entrypoints where entrypointsID=aentrypointsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from entrypoints where entrypointsid=aentrypointsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=entrypoints');
    return;
  end if;
  aBRIEF:=func.entrypoints_BRIEF_F(aentrypointsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure entrypoints_DELETE /*Меню*/ (
 aCURSESSION CHAR,
 aentrypointsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from entrypoints where entrypointsID=aentrypointsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from entrypoints where entrypointsid=aentrypointsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:entrypoints',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=entrypoints');
      return;
    end if;
  end if;
 --  verify lock  --
 entrypoints_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aentrypointsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=entrypoints');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_epfilterlink is select epfilterlink.epfilterlinkid ID from epfilterlink where  epfilterlink.ParentStructRowID = aentrypointsid;
    child_epfilterlink_rec  child_epfilterlink%ROWTYPE;
    begin
    --open child_epfilterlink;
      for child_epfilterlink_rec in child_epfilterlink loop
      epfilterlink_DELETE (acursession,child_epfilterlink_rec.id,aInstanceid);
      end loop;
      --close child_epfilterlink;
    end ;
declare cursor chld_entrypoints is select  instanceid ID from instance where OwnerPartName ='entrypoints' and OwnerRowID=aentrypointsid;
row_entrypoints  chld_entrypoints%ROWTYPE;
begin
--open chld_entrypoints;
for row_entrypoints in chld_entrypoints loop
 Kernel.INSTANCE_OWNER (acursession,row_entrypoints.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_entrypoints.id);
end loop;
--close chld_entrypoints;
end ;
  delete from  entrypoints 
  where  entrypointsID = aentrypointsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Меню*/
procedure entrypoints_SAVE /*Меню*/ (
 aCURSESSION CHAR,
 aentrypointsid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,aastoolbaritem
 NUMBER/* Включить в тулбар *//* Включить в тулбар */
,aactiontype
 NUMBER/* Вариант действия *//* Вариант действия */
,athefilter CHAR := null /* Фильтр *//* Фильтр */
,ajournal CHAR := null /* Журнал *//* Журнал */
,areport CHAR := null /* Отчет *//* Отчет */
,adocument CHAR := null /* Документ *//* Документ */
,amethod CHAR := null /* Метод *//* Метод */
,aiconfile
 VARCHAR2 := null /* Файл картинки *//* Файл картинки */
,atheextention CHAR := null /* Расширение *//* Расширение */
,aarm CHAR := null /* АРМ *//* АРМ */
,athecomment VARCHAR2 := null /* Примечание *//* Примечание */
,aobjecttype CHAR := null /* Тип документа *//* Тип документа */
,ajournalfixedquery VARCHAR2 := null /* Ограничения к журналу *//* Ограничения к журналу */
,aallowadd
 NUMBER/* Разрешено добавление *//* Разрешено добавление */
,aallowedit
 NUMBER/* Разрешено редактирование *//* Разрешено редактирование */
,aallowdel
 NUMBER/* Рарешено удаление *//* Рарешено удаление */
,aallowfilter
 NUMBER/* Разрешен фильтр *//* Разрешен фильтр */
,aallowprint
 NUMBER/* Разрешена печать *//* Разрешена печать */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from entrypoints where entrypointsID=aentrypointsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from entrypoints where entrypointsid=aentrypointsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:entrypoints',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=entrypoints');
      return;
    end if;
  end if;
 --  verify lock  --
 entrypoints_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aentrypointsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=entrypoints');
    return;
  end if;
 -- update row  --
 update  entrypoints set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  astoolbaritem=aastoolbaritem
,
  actiontype=aactiontype
,
  thefilter=athefilter
,
  journal=ajournal
,
  report=areport
,
  document=adocument
,
  method=amethod
,
  iconfile=aiconfile
,
  theextention=atheextention
,
  arm=aarm
,
  thecomment=athecomment
,
  objecttype=aobjecttype
,
  journalfixedquery=ajournalfixedquery
,
  allowadd=aallowadd
,
  allowedit=aallowedit
,
  allowdel=aallowdel
,
  allowfilter=aallowfilter
,
  allowprint=aallowprint
  where  entrypointsID = aentrypointsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:entrypoints',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=entrypoints');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=entrypoints');
    return;
  end if;
 insert into   entrypoints
 (  entrypointsID 
,ParentRowid
,InstanceID
,sequence

,name

,caption

,astoolbaritem

,actiontype

,thefilter

,journal

,report

,document

,method

,iconfile

,theextention

,arm

,thecomment

,objecttype

,journalfixedquery

,allowadd

,allowedit

,allowdel

,allowfilter

,allowprint

 ) values ( aentrypointsID 
,aParentRowid
,aInstanceID
,asequence

,aname

,acaption

,aastoolbaritem

,aactiontype

,athefilter

,ajournal

,areport

,adocument

,amethod

,aiconfile

,atheextention

,aarm

,athecomment

,aobjecttype

,ajournalfixedquery

,aallowadd

,aallowedit

,aallowdel

,aallowfilter

,aallowprint

 ); 
 entrypoints_SINIT( aCURSESSION,aentrypointsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure entrypoints_PARENT /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from entrypoints where  entrypointsid=aRowID;
 end; 

procedure entrypoints_ISLOCKED /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from entrypoints where entrypointsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  entrypoints_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure entrypoints_LOCK /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 entrypoints_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  entrypoints_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from entrypoints where entrypointsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=entrypoints');
    return;
  end if;
   if  aLockMode =2  
   then   
    update entrypoints set LockUserID =auserID ,LockSessionID =null where entrypointsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update entrypoints set LockUserID =null,LockSessionID =aCURSESSION  where entrypointsid=aRowID;
     return;
   end if;
 end ;

procedure entrypoints_HCL /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_epfilterlink is select epfilterlink.epfilterlinkid ID from epfilterlink where  epfilterlink.ParentStructRowID = aRowid;
row_epfilterlink lch_epfilterlink%ROWTYPE;
begin  
--open lch_epfilterlink;
for row_epfilterlink in lch_epfilterlink
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from epfilterlink where epfilterlinkid=row_epfilterlink.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_epfilterlink;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_epfilterlink;
     return;
   end if; 
 end if;  
 epfilterlink_HCL (acursession,row_epfilterlink.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_epfilterlink;
   return;
 end if;
end loop;
--close lch_epfilterlink;
end;
aIsLocked :=0;
end;

procedure entrypoints_UNLOCK /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 entrypoints_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update entrypoints set LockUserID =null  where entrypointsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update entrypoints set LockSessionID =null  where entrypointsid=aRowID;
     return;
   end if;
 end; 

procedure entrypoints_SINIT /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from entrypoints where entrypointsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =entrypoints');
    return;
  end if;
if aSecurityStyleID is null then
 entrypoints_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update entrypoints set securitystyleid =aStyleID where entrypointsid = aRowID;
else 
 update entrypoints set securitystyleid =aSecurityStyleID where entrypointsid = aRowID;
end if; 
end ; 

procedure entrypoints_propagate /*Меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from entrypoints where entrypointsid=aRowid;
declare cursor pch_epfilterlink  is select epfilterlink.epfilterlinkid ID from epfilterlink where  epfilterlink.ParentStructRowID = aRowid;
row_epfilterlink  pch_epfilterlink%ROWTYPE;
begin
--open pch_epfilterlink;
for row_epfilterlink in pch_epfilterlink loop
   epfilterlink_SINIT( acursession,row_epfilterlink.id,assid);
   epfilterlink_propagate( acursession,row_epfilterlink.id);
end loop;
--close pch_epfilterlink;
end;
end;


procedure epfilterlink_BRIEF  (
 aCURSESSION CHAR,
 aepfilterlinkid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aepfilterlinkid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from epfilterlink where epfilterlinkID=aepfilterlinkID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from epfilterlink where epfilterlinkid=aepfilterlinkID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=epfilterlink');
    return;
  end if;
  aBRIEF:=func.epfilterlink_BRIEF_F(aepfilterlinkid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure epfilterlink_DELETE /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aepfilterlinkid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from epfilterlink where epfilterlinkID=aepfilterlinkID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from epfilterlink where epfilterlinkid=aepfilterlinkID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:epfilterlink',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=epfilterlink');
      return;
    end if;
  end if;
 --  verify lock  --
 epfilterlink_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aepfilterlinkid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=epfilterlink');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_epfilterlink is select  instanceid ID from instance where OwnerPartName ='epfilterlink' and OwnerRowID=aepfilterlinkid;
row_epfilterlink  chld_epfilterlink%ROWTYPE;
begin
--open chld_epfilterlink;
for row_epfilterlink in chld_epfilterlink loop
 Kernel.INSTANCE_OWNER (acursession,row_epfilterlink.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_epfilterlink.id);
end loop;
--close chld_epfilterlink;
end ;
  delete from  epfilterlink 
  where  epfilterlinkID = aepfilterlinkID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Привязка фильтра*/
procedure epfilterlink_SAVE /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aepfilterlinkid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,arowsource
 VARCHAR2/* Источник *//* Источник */
,atheexpression VARCHAR2/* Выражение *//* Выражение */
,afilterfield
 VARCHAR2 := null /* Поле фильтра *//* Поле фильтра */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from epfilterlink where epfilterlinkID=aepfilterlinkID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from epfilterlink where epfilterlinkid=aepfilterlinkID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:epfilterlink',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=epfilterlink');
      return;
    end if;
  end if;
 --  verify lock  --
 epfilterlink_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aepfilterlinkid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=epfilterlink');
    return;
  end if;
 -- update row  --
 update  epfilterlink set ChangeStamp=sysdate
,
  rowsource=arowsource
,
  theexpression=atheexpression
,
  filterfield=afilterfield
  where  epfilterlinkID = aepfilterlinkID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from entrypoints where entrypointsid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:epfilterlink',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=epfilterlink');
      return;
    end if;
 end if;
 entrypoints_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=epfilterlink');
    return;
  end if;
 insert into   epfilterlink
 (  epfilterlinkID 
,ParentStructRowID
,rowsource

,theexpression

,filterfield

 ) values ( aepfilterlinkID 
,aParentStructRowID
,arowsource

,atheexpression

,afilterfield

 ); 
 epfilterlink_SINIT( aCURSESSION,aepfilterlinkid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure epfilterlink_PARENT /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from epfilterlink where  epfilterlinkid=aRowID;
  aParentTable := 'entrypoints';
 end; 

procedure epfilterlink_ISLOCKED /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from epfilterlink where epfilterlinkid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  epfilterlink_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure epfilterlink_LOCK /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 epfilterlink_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  epfilterlink_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from epfilterlink where epfilterlinkid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=epfilterlink');
    return;
  end if;
   if  aLockMode =2  
   then   
    update epfilterlink set LockUserID =auserID ,LockSessionID =null where epfilterlinkid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update epfilterlink set LockUserID =null,LockSessionID =aCURSESSION  where epfilterlinkid=aRowID;
     return;
   end if;
 end ;

procedure epfilterlink_HCL /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure epfilterlink_UNLOCK /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 epfilterlink_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update epfilterlink set LockUserID =null  where epfilterlinkid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update epfilterlink set LockSessionID =null  where epfilterlinkid=aRowID;
     return;
   end if;
 end; 

procedure epfilterlink_SINIT /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from epfilterlink where epfilterlinkid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =epfilterlink');
    return;
  end if;
if aSecurityStyleID is null then
 epfilterlink_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update epfilterlink set securitystyleid =aStyleID where epfilterlinkid = aRowID;
else 
 update epfilterlink set securitystyleid =aSecurityStyleID where epfilterlinkid = aRowID;
end if; 
end ; 

procedure epfilterlink_propagate /*Привязка фильтра к журналу*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from epfilterlink where epfilterlinkid=aRowid;
end;


procedure workplace_BRIEF  (
 aCURSESSION CHAR,
 aworkplaceid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aworkplaceid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from workplace where workplaceID=aworkplaceID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from workplace where workplaceid=aworkplaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=workplace');
    return;
  end if;
  aBRIEF:=func.workplace_BRIEF_F(aworkplaceid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure workplace_DELETE /*Арм*/ (
 aCURSESSION CHAR,
 aworkplaceid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from workplace where workplaceID=aworkplaceID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from workplace where workplaceid=aworkplaceID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:workplace',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=workplace');
      return;
    end if;
  end if;
 --  verify lock  --
 workplace_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aworkplaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=workplace');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_workplace is select  instanceid ID from instance where OwnerPartName ='workplace' and OwnerRowID=aworkplaceid;
row_workplace  chld_workplace%ROWTYPE;
begin
--open chld_workplace;
for row_workplace in chld_workplace loop
 Kernel.INSTANCE_OWNER (acursession,row_workplace.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_workplace.id);
end loop;
--close chld_workplace;
end ;
  delete from  workplace 
  where  workplaceID = aworkplaceID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Арм*/
procedure workplace_SAVE /*Арм*/ (
 aCURSESSION CHAR,
 aworkplaceid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2/* Заголовок *//* Заголовок */
,atheversion
 VARCHAR2 := null /* Версия *//* Версия */
,atheplatform
 NUMBER := null /* Платформа реализации *//* Платформа реализации */
,athecomment VARCHAR2 := null /* Примечание *//* Примечание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from workplace where workplaceID=aworkplaceID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from workplace where workplaceid=aworkplaceID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:workplace',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=workplace');
      return;
    end if;
  end if;
 --  verify lock  --
 workplace_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aworkplaceid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=workplace');
    return;
  end if;
 -- update row  --
 update  workplace set ChangeStamp=sysdate
,
  name=aname
,
  caption=acaption
,
  theversion=atheversion
,
  theplatform=atheplatform
,
  thecomment=athecomment
  where  workplaceID = aworkplaceID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from workplace where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=workplace');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:workplace',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=workplace');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=workplace');
    return;
  end if;
select Count(*) into existsCnt from workplace where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;workplace&gt;');
    return;
 End if;
 insert into   workplace
 (  workplaceID 
,InstanceID
,name

,caption

,theversion

,theplatform

,thecomment

 ) values ( aworkplaceID 
,aInstanceID
,aname

,acaption

,atheversion

,atheplatform

,athecomment

 ); 
 workplace_SINIT( aCURSESSION,aworkplaceid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from workplace where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=workplace');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure workplace_PARENT /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from workplace where  workplaceid=aRowID;
 end; 

procedure workplace_ISLOCKED /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from workplace where workplaceid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  workplace_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure workplace_LOCK /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 workplace_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  workplace_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from workplace where workplaceid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=workplace');
    return;
  end if;
   if  aLockMode =2  
   then   
    update workplace set LockUserID =auserID ,LockSessionID =null where workplaceid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update workplace set LockUserID =null,LockSessionID =aCURSESSION  where workplaceid=aRowID;
     return;
   end if;
 end ;

procedure workplace_HCL /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure workplace_UNLOCK /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 workplace_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update workplace set LockUserID =null  where workplaceid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update workplace set LockSessionID =null  where workplaceid=aRowID;
     return;
   end if;
 end; 

procedure workplace_SINIT /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from workplace where workplaceid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =workplace');
    return;
  end if;
if aSecurityStyleID is null then
 workplace_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update workplace set securitystyleid =aStyleID where workplaceid = aRowID;
else 
 update workplace set securitystyleid =aSecurityStyleID where workplaceid = aRowID;
end if; 
end ; 

procedure workplace_propagate /*Арм*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from workplace where workplaceid=aRowid;
end;


procedure armtypes_BRIEF  (
 aCURSESSION CHAR,
 aarmtypesid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aarmtypesid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from armtypes where armtypesID=aarmtypesID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from armtypes where armtypesid=aarmtypesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=armtypes');
    return;
  end if;
  aBRIEF:=func.armtypes_BRIEF_F(aarmtypesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure armtypes_DELETE /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aarmtypesid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from armtypes where armtypesID=aarmtypesID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from armtypes where armtypesid=aarmtypesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:armtypes',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=armtypes');
      return;
    end if;
  end if;
 --  verify lock  --
 armtypes_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmtypesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=armtypes');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_armtypes is select  instanceid ID from instance where OwnerPartName ='armtypes' and OwnerRowID=aarmtypesid;
row_armtypes  chld_armtypes%ROWTYPE;
begin
--open chld_armtypes;
for row_armtypes in chld_armtypes loop
 Kernel.INSTANCE_OWNER (acursession,row_armtypes.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_armtypes.id);
end loop;
--close chld_armtypes;
end ;
  delete from  armtypes 
  where  armtypesID = aarmtypesID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Список типов*/
procedure armtypes_SAVE /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aarmtypesid CHAR,
aInstanceID CHAR 
,athedocumenttype CHAR/* Тип документа *//* Тип документа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from armtypes where armtypesID=aarmtypesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from armtypes where armtypesid=aarmtypesID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:armtypes',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=armtypes');
      return;
    end if;
  end if;
 --  verify lock  --
 armtypes_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aarmtypesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armtypes');
    return;
  end if;
 -- update row  --
 update  armtypes set ChangeStamp=sysdate
,
  thedocumenttype=athedocumenttype
  where  armtypesID = aarmtypesID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:armtypes',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=armtypes');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=armtypes');
    return;
  end if;
 insert into   armtypes
 (  armtypesID 
,InstanceID
,thedocumenttype

 ) values ( aarmtypesID 
,aInstanceID
,athedocumenttype

 ); 
 armtypes_SINIT( aCURSESSION,aarmtypesid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure armtypes_PARENT /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from armtypes where  armtypesid=aRowID;
 end; 

procedure armtypes_ISLOCKED /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from armtypes where armtypesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  armtypes_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzwp.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure armtypes_LOCK /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 armtypes_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  armtypes_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from armtypes where armtypesid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=armtypes');
    return;
  end if;
   if  aLockMode =2  
   then   
    update armtypes set LockUserID =auserID ,LockSessionID =null where armtypesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update armtypes set LockUserID =null,LockSessionID =aCURSESSION  where armtypesid=aRowID;
     return;
   end if;
 end ;

procedure armtypes_HCL /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure armtypes_UNLOCK /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 armtypes_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update armtypes set LockUserID =null  where armtypesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update armtypes set LockSessionID =null  where armtypesid=aRowID;
     return;
   end if;
 end; 

procedure armtypes_SINIT /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from armtypes where armtypesid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =armtypes');
    return;
  end if;
if aSecurityStyleID is null then
 armtypes_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update armtypes set securitystyleid =aStyleID where armtypesid = aRowID;
else 
 update armtypes set securitystyleid =aSecurityStyleID where armtypesid = aRowID;
end if; 
end ; 

procedure armtypes_propagate /*Типы документов, которые подключаются в MDI режиме*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from armtypes where armtypesid=aRowid;
end;
end mtzwp;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--roles" BlockCode=" create or replace package body roles as

procedure roles_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='roles'
then
declare cursor child_roles_operations is select roles_operations.roles_operationsid ID from roles_operations where  roles_operations.InstanceID = ainstanceid;
row_roles_operations  child_roles_operations%ROWTYPE;
begin
--open child_roles_operations;
for row_roles_operations in child_roles_operations loop
 roles_operations_DELETE (acursession,row_roles_operations.id,aInstanceID);
end loop;
--close child_roles_operations;
end;
declare cursor child_roles_wp is select roles_wp.roles_wpid ID from roles_wp where  roles_wp.InstanceID = ainstanceid;
row_roles_wp  child_roles_wp%ROWTYPE;
begin
--open child_roles_wp;
for row_roles_wp in child_roles_wp loop
 roles_wp_DELETE (acursession,row_roles_wp.id,aInstanceID);
end loop;
--close child_roles_wp;
end;
declare cursor child_roles2_module is select roles2_module.roles2_moduleid ID from roles2_module where  roles2_module.InstanceID = ainstanceid;
row_roles2_module  child_roles2_module%ROWTYPE;
begin
--open child_roles2_module;
for row_roles2_module in child_roles2_module loop
 roles2_module_DELETE (acursession,row_roles2_module.id,aInstanceID);
end loop;
--close child_roles2_module;
end;
declare cursor child_roles_doc is select roles_doc.roles_docid ID from roles_doc where  roles_doc.InstanceID = ainstanceid;
row_roles_doc  child_roles_doc%ROWTYPE;
begin
--open child_roles_doc;
for row_roles_doc in child_roles_doc loop
 roles_doc_DELETE (acursession,row_roles_doc.id,aInstanceID);
end loop;
--close child_roles_doc;
end;
declare cursor child_roles_reports is select roles_reports.roles_reportsid ID from roles_reports where  roles_reports.InstanceID = ainstanceid;
row_roles_reports  child_roles_reports%ROWTYPE;
begin
--open child_roles_reports;
for row_roles_reports in child_roles_reports loop
 roles_reports_DELETE (acursession,row_roles_reports.id,aInstanceID);
end loop;
--close child_roles_reports;
end;
declare cursor child_roles_user is select roles_user.roles_userid ID from roles_user where  roles_user.InstanceID = ainstanceid;
row_roles_user  child_roles_user%ROWTYPE;
begin
--open child_roles_user;
for row_roles_user in child_roles_user loop
 roles_user_DELETE (acursession,row_roles_user.id,aInstanceID);
end loop;
--close child_roles_user;
end;
declare cursor child_roles_map is select roles_map.roles_mapid ID from roles_map where  roles_map.InstanceID = ainstanceid;
row_roles_map  child_roles_map%ROWTYPE;
begin
--open child_roles_map;
for row_roles_map in child_roles_map loop
 roles_map_DELETE (acursession,row_roles_map.id,aInstanceID);
end loop;
--close child_roles_map;
end;
declare cursor child_roles_def is select roles_def.roles_defid ID from roles_def where  roles_def.InstanceID = ainstanceid;
row_roles_def  child_roles_def%ROWTYPE;
begin
--open child_roles_def;
for row_roles_def in child_roles_def loop
 roles_def_DELETE (acursession,row_roles_def.id,aInstanceID);
end loop;
--close child_roles_def;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure roles_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'roles'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_roles_operations is select roles_operations.roles_operationsid ID from roles_operations where  roles_operations.InstanceID = arowid;
ROW_roles_operations  lch_roles_operations%ROWTYPE;
begin
--open lch_roles_operations;
for row_roles_operations in lch_roles_operations loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles_operations where roles_operationsid=row_roles_operations.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_operations;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles_operations;
     return;
   end if; 
 end if; 
 roles_operations_HCL (acursession,ROW_roles_operations.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_operations;
   return;
 end if;
 end loop;
--close lch_roles_operations;
end;
declare cursor lch_roles_wp is select roles_wp.roles_wpid ID from roles_wp where  roles_wp.InstanceID = arowid;
ROW_roles_wp  lch_roles_wp%ROWTYPE;
begin
--open lch_roles_wp;
for row_roles_wp in lch_roles_wp loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles_wp where roles_wpid=row_roles_wp.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_wp;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles_wp;
     return;
   end if; 
 end if; 
 roles_wp_HCL (acursession,ROW_roles_wp.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_wp;
   return;
 end if;
 end loop;
--close lch_roles_wp;
end;
declare cursor lch_roles2_module is select roles2_module.roles2_moduleid ID from roles2_module where  roles2_module.InstanceID = arowid;
ROW_roles2_module  lch_roles2_module%ROWTYPE;
begin
--open lch_roles2_module;
for row_roles2_module in lch_roles2_module loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles2_module where roles2_moduleid=row_roles2_module.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles2_module;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles2_module;
     return;
   end if; 
 end if; 
 roles2_module_HCL (acursession,ROW_roles2_module.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles2_module;
   return;
 end if;
 end loop;
--close lch_roles2_module;
end;
declare cursor lch_roles_doc is select roles_doc.roles_docid ID from roles_doc where  roles_doc.InstanceID = arowid;
ROW_roles_doc  lch_roles_doc%ROWTYPE;
begin
--open lch_roles_doc;
for row_roles_doc in lch_roles_doc loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles_doc where roles_docid=row_roles_doc.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_doc;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles_doc;
     return;
   end if; 
 end if; 
 roles_doc_HCL (acursession,ROW_roles_doc.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_doc;
   return;
 end if;
 end loop;
--close lch_roles_doc;
end;
declare cursor lch_roles_reports is select roles_reports.roles_reportsid ID from roles_reports where  roles_reports.InstanceID = arowid;
ROW_roles_reports  lch_roles_reports%ROWTYPE;
begin
--open lch_roles_reports;
for row_roles_reports in lch_roles_reports loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles_reports where roles_reportsid=row_roles_reports.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_reports;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles_reports;
     return;
   end if; 
 end if; 
 roles_reports_HCL (acursession,ROW_roles_reports.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_reports;
   return;
 end if;
 end loop;
--close lch_roles_reports;
end;
declare cursor lch_roles_user is select roles_user.roles_userid ID from roles_user where  roles_user.InstanceID = arowid;
ROW_roles_user  lch_roles_user%ROWTYPE;
begin
--open lch_roles_user;
for row_roles_user in lch_roles_user loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles_user where roles_userid=row_roles_user.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_user;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles_user;
     return;
   end if; 
 end if; 
 roles_user_HCL (acursession,ROW_roles_user.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_user;
   return;
 end if;
 end loop;
--close lch_roles_user;
end;
declare cursor lch_roles_map is select roles_map.roles_mapid ID from roles_map where  roles_map.InstanceID = arowid;
ROW_roles_map  lch_roles_map%ROWTYPE;
begin
--open lch_roles_map;
for row_roles_map in lch_roles_map loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles_map where roles_mapid=row_roles_map.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_map;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles_map;
     return;
   end if; 
 end if; 
 roles_map_HCL (acursession,ROW_roles_map.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_map;
   return;
 end if;
 end loop;
--close lch_roles_map;
end;
declare cursor lch_roles_def is select roles_def.roles_defid ID from roles_def where  roles_def.InstanceID = arowid;
ROW_roles_def  lch_roles_def%ROWTYPE;
begin
--open lch_roles_def;
for row_roles_def in lch_roles_def loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from roles_def where roles_defid=row_roles_def.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_def;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_roles_def;
     return;
   end if; 
 end if; 
 roles_def_HCL (acursession,ROW_roles_def.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_def;
   return;
 end if;
 end loop;
--close lch_roles_def;
end;
 end if;
aIsLocked:=0;
end;
procedure roles_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'roles'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_roles_operations is select roles_operations.roles_operationsid id from roles_operations where  roles_operations.InstanceID = arowid;
row_roles_operations  pch_roles_operations%ROWTYPE;
begin
--open pch_roles_operations;
for row_roles_operations in  pch_roles_operations loop
 roles_operations_SINIT( acursession,row_roles_operations.id,assid);
 roles_operations_propagate( acursession,row_roles_operations.id);
end loop;
--close pch_roles_operations;
end;
declare cursor pch_roles_wp is select roles_wp.roles_wpid id from roles_wp where  roles_wp.InstanceID = arowid;
row_roles_wp  pch_roles_wp%ROWTYPE;
begin
--open pch_roles_wp;
for row_roles_wp in  pch_roles_wp loop
 roles_wp_SINIT( acursession,row_roles_wp.id,assid);
 roles_wp_propagate( acursession,row_roles_wp.id);
end loop;
--close pch_roles_wp;
end;
declare cursor pch_roles2_module is select roles2_module.roles2_moduleid id from roles2_module where  roles2_module.InstanceID = arowid;
row_roles2_module  pch_roles2_module%ROWTYPE;
begin
--open pch_roles2_module;
for row_roles2_module in  pch_roles2_module loop
 roles2_module_SINIT( acursession,row_roles2_module.id,assid);
 roles2_module_propagate( acursession,row_roles2_module.id);
end loop;
--close pch_roles2_module;
end;
declare cursor pch_roles_doc is select roles_doc.roles_docid id from roles_doc where  roles_doc.InstanceID = arowid;
row_roles_doc  pch_roles_doc%ROWTYPE;
begin
--open pch_roles_doc;
for row_roles_doc in  pch_roles_doc loop
 roles_doc_SINIT( acursession,row_roles_doc.id,assid);
 roles_doc_propagate( acursession,row_roles_doc.id);
end loop;
--close pch_roles_doc;
end;
declare cursor pch_roles_reports is select roles_reports.roles_reportsid id from roles_reports where  roles_reports.InstanceID = arowid;
row_roles_reports  pch_roles_reports%ROWTYPE;
begin
--open pch_roles_reports;
for row_roles_reports in  pch_roles_reports loop
 roles_reports_SINIT( acursession,row_roles_reports.id,assid);
 roles_reports_propagate( acursession,row_roles_reports.id);
end loop;
--close pch_roles_reports;
end;
declare cursor pch_roles_user is select roles_user.roles_userid id from roles_user where  roles_user.InstanceID = arowid;
row_roles_user  pch_roles_user%ROWTYPE;
begin
--open pch_roles_user;
for row_roles_user in  pch_roles_user loop
 roles_user_SINIT( acursession,row_roles_user.id,assid);
 roles_user_propagate( acursession,row_roles_user.id);
end loop;
--close pch_roles_user;
end;
declare cursor pch_roles_map is select roles_map.roles_mapid id from roles_map where  roles_map.InstanceID = arowid;
row_roles_map  pch_roles_map%ROWTYPE;
begin
--open pch_roles_map;
for row_roles_map in  pch_roles_map loop
 roles_map_SINIT( acursession,row_roles_map.id,assid);
 roles_map_propagate( acursession,row_roles_map.id);
end loop;
--close pch_roles_map;
end;
declare cursor pch_roles_def is select roles_def.roles_defid id from roles_def where  roles_def.InstanceID = arowid;
row_roles_def  pch_roles_def%ROWTYPE;
begin
--open pch_roles_def;
for row_roles_def in  pch_roles_def loop
 roles_def_SINIT( acursession,row_roles_def.id,assid);
 roles_def_propagate( acursession,row_roles_def.id);
end loop;
--close pch_roles_def;
end;
 end if; 
end;


procedure roles_operations_BRIEF  (
 aCURSESSION CHAR,
 aroles_operationsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_operationsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_operations where roles_operationsID=aroles_operationsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_operations where roles_operationsid=aroles_operationsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_operations');
    return;
  end if;
  aBRIEF:=func.roles_operations_BRIEF_F(aroles_operationsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_operations_DELETE /*Именованные операции*/ (
 aCURSESSION CHAR,
 aroles_operationsid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_operations where roles_operationsID=aroles_operationsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_operations where roles_operationsid=aroles_operationsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_operations',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_operations');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_operations_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_operationsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_operations');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles_operations',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;aroles_operationsid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_roles_operations is select  instanceid ID from instance where OwnerPartName ='roles_operations' and OwnerRowID=aroles_operationsid;
row_roles_operations  chld_roles_operations%ROWTYPE;
begin
--open chld_roles_operations;
for row_roles_operations in chld_roles_operations loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_operations.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_operations.id);
end loop;
--close chld_roles_operations;
end ;
  delete from  roles_operations 
  where  roles_operationsID = aroles_operationsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные действия*/
procedure roles_operations_SAVE /*Именованные операции*/ (
 aCURSESSION CHAR,
 aroles_operationsid CHAR,
aInstanceID CHAR 
,ainfo
 VARCHAR2/* Описание *//* Описание */
,aallowaction
 NUMBER/* Разрешено *//* Разрешено */
,aname
 VARCHAR2/* Код *//* Код */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_operations where roles_operationsID=aroles_operationsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_operations where roles_operationsid=aroles_operationsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_operations',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_operations');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_operations_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_operationsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_operations');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles_operations',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;aroles_operationsid,aLogInstanceID=&gt;aInstanceID);
 update  roles_operations set ChangeStamp=sysdate
,
  info=ainfo
,
  allowaction=aallowaction
,
  name=aname
  where  roles_operationsID = aroles_operationsID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_operations where InstanceID=aInstanceID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_operations');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_operations',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_operations');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_operations');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles_operations',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;aroles_operationsid,aLogInstanceID=&gt;aInstanceID);
 insert into   roles_operations
 (  roles_operationsID 
,InstanceID
,info

,allowaction

,name

 ) values ( aroles_operationsID 
,aInstanceID
,ainfo

,aallowaction

,aname

 ); 
 roles_operations_SINIT( aCURSESSION,aroles_operationsid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_operations where InstanceID=aInstanceID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_operations');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure roles_operations_PARENT /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles_operations where  roles_operationsid=aRowID;
 end; 

procedure roles_operations_ISLOCKED /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_operations where roles_operationsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_operations_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_operations_LOCK /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_operations_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_operations_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_operations where roles_operationsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_operations');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_operations set LockUserID =auserID ,LockSessionID =null where roles_operationsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_operations set LockUserID =null,LockSessionID =aCURSESSION  where roles_operationsid=aRowID;
     return;
   end if;
 end ;

procedure roles_operations_HCL /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles_operations_UNLOCK /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_operations_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_operations set LockUserID =null  where roles_operationsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_operations set LockSessionID =null  where roles_operationsid=aRowID;
     return;
   end if;
 end; 

procedure roles_operations_SINIT /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_operations where roles_operationsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_operations');
    return;
  end if;
if aSecurityStyleID is null then
 roles_operations_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_operations set securitystyleid =aStyleID where roles_operationsid = aRowID;
else 
 update roles_operations set securitystyleid =aSecurityStyleID where roles_operationsid = aRowID;
end if; 
end ; 

procedure roles_operations_propagate /*Именованные операции*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_operations where roles_operationsid=aRowid;
end;


procedure roles_wp_BRIEF  (
 aCURSESSION CHAR,
 aroles_wpid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_wpid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_wp where roles_wpID=aroles_wpID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_wp where roles_wpid=aroles_wpID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_wp');
    return;
  end if;
  aBRIEF:=func.roles_wp_BRIEF_F(aroles_wpid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_wp_DELETE /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aroles_wpid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_wp where roles_wpID=aroles_wpID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_wp where roles_wpid=aroles_wpID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_wp',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_wp');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_wp_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_wpid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_wp');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_roles_act is select roles_act.roles_actid ID from roles_act where  roles_act.ParentStructRowID = aroles_wpid;
    child_roles_act_rec  child_roles_act%ROWTYPE;
    begin
    --open child_roles_act;
      for child_roles_act_rec in child_roles_act loop
      roles_act_DELETE (acursession,child_roles_act_rec.id,aInstanceid);
      end loop;
      --close child_roles_act;
    end ;
declare cursor chld_roles_wp is select  instanceid ID from instance where OwnerPartName ='roles_wp' and OwnerRowID=aroles_wpid;
row_roles_wp  chld_roles_wp%ROWTYPE;
begin
--open chld_roles_wp;
for row_roles_wp in chld_roles_wp loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_wp.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_wp.id);
end loop;
--close chld_roles_wp;
end ;
  delete from  roles_wp 
  where  roles_wpID = aroles_wpID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные приложения*/
procedure roles_wp_SAVE /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aroles_wpid CHAR,
aInstanceID CHAR 
,awp CHAR/* Приложение *//* Приложение */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_wp where roles_wpID=aroles_wpID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_wp where roles_wpid=aroles_wpID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_wp',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_wp');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_wp_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_wpid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_wp');
    return;
  end if;
 -- update row  --
 update  roles_wp set ChangeStamp=sysdate
,
  wp=awp
  where  roles_wpID = aroles_wpID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_wp where InstanceID=aInstanceID 
 and wp=awp;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_wp');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_wp',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_wp');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_wp');
    return;
  end if;
 insert into   roles_wp
 (  roles_wpID 
,InstanceID
,wp

 ) values ( aroles_wpID 
,aInstanceID
,awp

 ); 
 roles_wp_SINIT( aCURSESSION,aroles_wpid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_wp where InstanceID=aInstanceID 
 and wp=awp;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_wp');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure roles_wp_PARENT /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles_wp where  roles_wpid=aRowID;
 end; 

procedure roles_wp_ISLOCKED /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_wp where roles_wpid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_wp_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_wp_LOCK /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_wp_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_wp_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_wp where roles_wpid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_wp');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_wp set LockUserID =auserID ,LockSessionID =null where roles_wpid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_wp set LockUserID =null,LockSessionID =aCURSESSION  where roles_wpid=aRowID;
     return;
   end if;
 end ;

procedure roles_wp_HCL /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_roles_act is select roles_act.roles_actid ID from roles_act where  roles_act.ParentStructRowID = aRowid;
row_roles_act lch_roles_act%ROWTYPE;
begin  
--open lch_roles_act;
for row_roles_act in lch_roles_act
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from roles_act where roles_actid=row_roles_act.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_act;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_roles_act;
     return;
   end if; 
 end if;  
 roles_act_HCL (acursession,row_roles_act.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_act;
   return;
 end if;
end loop;
--close lch_roles_act;
end;
aIsLocked :=0;
end;

procedure roles_wp_UNLOCK /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_wp_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_wp set LockUserID =null  where roles_wpid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_wp set LockSessionID =null  where roles_wpid=aRowID;
     return;
   end if;
 end; 

procedure roles_wp_SINIT /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_wp where roles_wpid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_wp');
    return;
  end if;
if aSecurityStyleID is null then
 roles_wp_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_wp set securitystyleid =aStyleID where roles_wpid = aRowID;
else 
 update roles_wp set securitystyleid =aSecurityStyleID where roles_wpid = aRowID;
end if; 
end ; 

procedure roles_wp_propagate /*Доступные приложения*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_wp where roles_wpid=aRowid;
declare cursor pch_roles_act  is select roles_act.roles_actid ID from roles_act where  roles_act.ParentStructRowID = aRowid;
row_roles_act  pch_roles_act%ROWTYPE;
begin
--open pch_roles_act;
for row_roles_act in pch_roles_act loop
   roles_act_SINIT( acursession,row_roles_act.id,assid);
   roles_act_propagate( acursession,row_roles_act.id);
end loop;
--close pch_roles_act;
end;
end;


procedure roles_act_BRIEF  (
 aCURSESSION CHAR,
 aroles_actid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_actid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_act where roles_actID=aroles_actID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_act where roles_actid=aroles_actID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_act');
    return;
  end if;
  aBRIEF:=func.roles_act_BRIEF_F(aroles_actid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_act_DELETE /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aroles_actid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_act where roles_actID=aroles_actID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_act where roles_actid=aroles_actID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_act',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_act');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_act_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_actid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_act');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_roles_act is select  instanceid ID from instance where OwnerPartName ='roles_act' and OwnerRowID=aroles_actid;
row_roles_act  chld_roles_act%ROWTYPE;
begin
--open chld_roles_act;
for row_roles_act in chld_roles_act loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_act.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_act.id);
end loop;
--close chld_roles_act;
end ;
  delete from  roles_act 
  where  roles_actID = aroles_actID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Разрешенные пункты меню*/
procedure roles_act_SAVE /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aroles_actid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aaccesible
 NUMBER := null /* Доступность *//* Доступность */
,amenuname
 VARCHAR2/* Меню *//* Меню */
,amenucode
 VARCHAR2/* Код пункта меню *//* Код пункта меню */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_act where roles_actID=aroles_actID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_act where roles_actid=aroles_actID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_act',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_act');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_act_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_actid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_act');
    return;
  end if;
 -- update row  --
 update  roles_act set ChangeStamp=sysdate
,
  accesible=aaccesible
,
  menuname=amenuname
,
  menucode=amenucode
  where  roles_actID = aroles_actID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from roles_wp where roles_wpid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_act',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_act');
      return;
    end if;
 end if;
 roles_wp_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_act');
    return;
  end if;
 insert into   roles_act
 (  roles_actID 
,ParentStructRowID
,accesible

,menuname

,menucode

 ) values ( aroles_actID 
,aParentStructRowID
,aaccesible

,amenuname

,amenucode

 ); 
 roles_act_SINIT( aCURSESSION,aroles_actid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure roles_act_PARENT /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from roles_act where  roles_actid=aRowID;
  aParentTable := 'roles_wp';
 end; 

procedure roles_act_ISLOCKED /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_act where roles_actid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_act_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_act_LOCK /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_act_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_act_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_act where roles_actid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_act');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_act set LockUserID =auserID ,LockSessionID =null where roles_actid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_act set LockUserID =null,LockSessionID =aCURSESSION  where roles_actid=aRowID;
     return;
   end if;
 end ;

procedure roles_act_HCL /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles_act_UNLOCK /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_act_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_act set LockUserID =null  where roles_actid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_act set LockSessionID =null  where roles_actid=aRowID;
     return;
   end if;
 end; 

procedure roles_act_SINIT /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_act where roles_actid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_act');
    return;
  end if;
if aSecurityStyleID is null then
 roles_act_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_act set securitystyleid =aStyleID where roles_actid = aRowID;
else 
 update roles_act set securitystyleid =aSecurityStyleID where roles_actid = aRowID;
end if; 
end ; 

procedure roles_act_propagate /*Разрешенные пункты меню*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_act where roles_actid=aRowid;
end;


procedure roles2_module_BRIEF  (
 aCURSESSION CHAR,
 aroles2_moduleid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles2_moduleid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles2_module where roles2_moduleID=aroles2_moduleID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles2_module where roles2_moduleid=aroles2_moduleID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles2_module');
    return;
  end if;
  aBRIEF:=func.roles2_module_BRIEF_F(aroles2_moduleid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles2_module_DELETE /**/ (
 aCURSESSION CHAR,
 aroles2_moduleid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles2_module where roles2_moduleID=aroles2_moduleID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles2_module where roles2_moduleid=aroles2_moduleID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles2_module',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles2_module');
      return;
    end if;
  end if;
 --  verify lock  --
 roles2_module_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles2_moduleid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles2_module');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_roles2_modreport is select roles2_modreport.roles2_modreportid ID from roles2_modreport where  roles2_modreport.ParentStructRowID = aroles2_moduleid;
    child_roles2_modreport_rec  child_roles2_modreport%ROWTYPE;
    begin
    --open child_roles2_modreport;
      for child_roles2_modreport_rec in child_roles2_modreport loop
      roles2_modreport_DELETE (acursession,child_roles2_modreport_rec.id,aInstanceid);
      end loop;
      --close child_roles2_modreport;
    end ;
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles2_module',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;aroles2_moduleid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_roles2_module is select  instanceid ID from instance where OwnerPartName ='roles2_module' and OwnerRowID=aroles2_moduleid;
row_roles2_module  chld_roles2_module%ROWTYPE;
begin
--open chld_roles2_module;
for row_roles2_module in chld_roles2_module loop
 Kernel.INSTANCE_OWNER (acursession,row_roles2_module.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles2_module.id);
end loop;
--close chld_roles2_module;
end ;
  delete from  roles2_module 
  where  roles2_moduleID = aroles2_moduleID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Модули*/
procedure roles2_module_SAVE /**/ (
 aCURSESSION CHAR,
 aroles2_moduleid CHAR,
aInstanceID CHAR 
,agroupname
 VARCHAR2 := null /* Имя группы *//* Имя группы */
,acaption
 VARCHAR2/* Надпись *//* Надпись */
,asequence
 NUMBER/* № п/п *//* № п/п */
,amoduleaccessible
 NUMBER/* Разрешен *//* Разрешен */
,acustomizevisibility
 NUMBER/* Настраивать видимость *//* Настраивать видимость */
,atheicon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aname
 VARCHAR2/* Код модуля *//* Код модуля */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
,aallobjects
 NUMBER/* Вся фирма *//* Вся фирма */
,acolegsobject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,asubstructobjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles2_module where roles2_moduleID=aroles2_moduleID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles2_module where roles2_moduleid=aroles2_moduleID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles2_module',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles2_module');
      return;
    end if;
  end if;
 --  verify lock  --
 roles2_module_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles2_moduleid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles2_module');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles2_module',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;aroles2_moduleid,aLogInstanceID=&gt;aInstanceID);
 update  roles2_module set ChangeStamp=sysdate
,
  groupname=agroupname
,
  caption=acaption
,
  sequence=asequence
,
  moduleaccessible=amoduleaccessible
,
  customizevisibility=acustomizevisibility
,
  theicon=atheicon
,
  name=aname
,
  thecomment=athecomment
,
  allobjects=aallobjects
,
  colegsobject=acolegsobject
,
  substructobjects=asubstructobjects
  where  roles2_moduleID = aroles2_moduleID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles2_module',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles2_module');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles2_module');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles2_module',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;aroles2_moduleid,aLogInstanceID=&gt;aInstanceID);
 insert into   roles2_module
 (  roles2_moduleID 
,InstanceID
,groupname

,caption

,sequence

,moduleaccessible

,customizevisibility

,theicon

,name

,thecomment

,allobjects

,colegsobject

,substructobjects

 ) values ( aroles2_moduleID 
,aInstanceID
,agroupname

,acaption

,asequence

,amoduleaccessible

,acustomizevisibility

,atheicon

,aname

,athecomment

,aallobjects

,acolegsobject

,asubstructobjects

 ); 
 roles2_module_SINIT( aCURSESSION,aroles2_moduleid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure roles2_module_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles2_module where  roles2_moduleid=aRowID;
 end; 

procedure roles2_module_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles2_module where roles2_moduleid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles2_module_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles2_module_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles2_module_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles2_module_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles2_module where roles2_moduleid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles2_module');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles2_module set LockUserID =auserID ,LockSessionID =null where roles2_moduleid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles2_module set LockUserID =null,LockSessionID =aCURSESSION  where roles2_moduleid=aRowID;
     return;
   end if;
 end ;

procedure roles2_module_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_roles2_modreport is select roles2_modreport.roles2_modreportid ID from roles2_modreport where  roles2_modreport.ParentStructRowID = aRowid;
row_roles2_modreport lch_roles2_modreport%ROWTYPE;
begin  
--open lch_roles2_modreport;
for row_roles2_modreport in lch_roles2_modreport
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from roles2_modreport where roles2_modreportid=row_roles2_modreport.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles2_modreport;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_roles2_modreport;
     return;
   end if; 
 end if;  
 roles2_modreport_HCL (acursession,row_roles2_modreport.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles2_modreport;
   return;
 end if;
end loop;
--close lch_roles2_modreport;
end;
aIsLocked :=0;
end;

procedure roles2_module_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles2_module_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles2_module set LockUserID =null  where roles2_moduleid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles2_module set LockSessionID =null  where roles2_moduleid=aRowID;
     return;
   end if;
 end; 

procedure roles2_module_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles2_module where roles2_moduleid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles2_module');
    return;
  end if;
if aSecurityStyleID is null then
 roles2_module_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles2_module set securitystyleid =aStyleID where roles2_moduleid = aRowID;
else 
 update roles2_module set securitystyleid =aSecurityStyleID where roles2_moduleid = aRowID;
end if; 
end ; 

procedure roles2_module_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles2_module where roles2_moduleid=aRowid;
declare cursor pch_roles2_modreport  is select roles2_modreport.roles2_modreportid ID from roles2_modreport where  roles2_modreport.ParentStructRowID = aRowid;
row_roles2_modreport  pch_roles2_modreport%ROWTYPE;
begin
--open pch_roles2_modreport;
for row_roles2_modreport in pch_roles2_modreport loop
   roles2_modreport_SINIT( acursession,row_roles2_modreport.id,assid);
   roles2_modreport_propagate( acursession,row_roles2_modreport.id);
end loop;
--close pch_roles2_modreport;
end;
end;


procedure roles2_modreport_BRIEF  (
 aCURSESSION CHAR,
 aroles2_modreportid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles2_modreportid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles2_modreport where roles2_modreportID=aroles2_modreportID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles2_modreport where roles2_modreportid=aroles2_modreportID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles2_modreport');
    return;
  end if;
  aBRIEF:=func.roles2_modreport_BRIEF_F(aroles2_modreportid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles2_modreport_DELETE /**/ (
 aCURSESSION CHAR,
 aroles2_modreportid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles2_modreport where roles2_modreportID=aroles2_modreportID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles2_modreport where roles2_modreportid=aroles2_modreportID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles2_modreport',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles2_modreport');
      return;
    end if;
  end if;
 --  verify lock  --
 roles2_modreport_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles2_modreportid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles2_modreport');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles2_modreport',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;aroles2_modreportid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_roles2_modreport is select  instanceid ID from instance where OwnerPartName ='roles2_modreport' and OwnerRowID=aroles2_modreportid;
row_roles2_modreport  chld_roles2_modreport%ROWTYPE;
begin
--open chld_roles2_modreport;
for row_roles2_modreport in chld_roles2_modreport loop
 Kernel.INSTANCE_OWNER (acursession,row_roles2_modreport.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles2_modreport.id);
end loop;
--close chld_roles2_modreport;
end ;
  delete from  roles2_modreport 
  where  roles2_modreportID = aroles2_modreportID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Действия и отчеты*/
procedure roles2_modreport_SAVE /**/ (
 aCURSESSION CHAR,
 aroles2_modreportid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Код *//* Код */
,aallowaction
 NUMBER/* Разрешен *//* Разрешен */
,acaption
 VARCHAR2/* Надпись *//* Надпись */
,asequence
 NUMBER/* № п/п *//* № п/п */
,atheicon
 VARCHAR2 := null /* Иконка *//* Иконка */
,aisreport
 NUMBER/* Это отчет *//* Это отчет */
,aselecttype
 NUMBER := null /* Вариант выбора *//* Вариант выбора */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles2_modreport where roles2_modreportID=aroles2_modreportID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles2_modreport where roles2_modreportid=aroles2_modreportID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles2_modreport',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles2_modreport');
      return;
    end if;
  end if;
 --  verify lock  --
 roles2_modreport_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles2_modreportid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles2_modreport');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles2_modreport',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;aroles2_modreportid,aLogInstanceID=&gt;aInstanceID);
 update  roles2_modreport set ChangeStamp=sysdate
,
  name=aname
,
  allowaction=aallowaction
,
  caption=acaption
,
  sequence=asequence
,
  theicon=atheicon
,
  isreport=aisreport
,
  selecttype=aselecttype
  where  roles2_modreportID = aroles2_modreportID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from roles2_module where roles2_moduleid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles2_modreport',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles2_modreport');
      return;
    end if;
 end if;
 roles2_module_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles2_modreport');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'roles2_modreport',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;aroles2_modreportid,aLogInstanceID=&gt;aInstanceID);
 insert into   roles2_modreport
 (  roles2_modreportID 
,ParentStructRowID
,name

,allowaction

,caption

,sequence

,theicon

,isreport

,selecttype

 ) values ( aroles2_modreportID 
,aParentStructRowID
,aname

,aallowaction

,acaption

,asequence

,atheicon

,aisreport

,aselecttype

 ); 
 roles2_modreport_SINIT( aCURSESSION,aroles2_modreportid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure roles2_modreport_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from roles2_modreport where  roles2_modreportid=aRowID;
  aParentTable := 'roles2_module';
 end; 

procedure roles2_modreport_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles2_modreport where roles2_modreportid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles2_modreport_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles2_modreport_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles2_modreport_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles2_modreport_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles2_modreport where roles2_modreportid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles2_modreport');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles2_modreport set LockUserID =auserID ,LockSessionID =null where roles2_modreportid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles2_modreport set LockUserID =null,LockSessionID =aCURSESSION  where roles2_modreportid=aRowID;
     return;
   end if;
 end ;

procedure roles2_modreport_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles2_modreport_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles2_modreport_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles2_modreport set LockUserID =null  where roles2_modreportid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles2_modreport set LockSessionID =null  where roles2_modreportid=aRowID;
     return;
   end if;
 end; 

procedure roles2_modreport_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles2_modreport where roles2_modreportid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles2_modreport');
    return;
  end if;
if aSecurityStyleID is null then
 roles2_modreport_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles2_modreport set securitystyleid =aStyleID where roles2_modreportid = aRowID;
else 
 update roles2_modreport set securitystyleid =aSecurityStyleID where roles2_modreportid = aRowID;
end if; 
end ; 

procedure roles2_modreport_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles2_modreport where roles2_modreportid=aRowid;
end;


procedure roles_doc_BRIEF  (
 aCURSESSION CHAR,
 aroles_docid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_docid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_doc where roles_docID=aroles_docID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_doc where roles_docid=aroles_docID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_doc');
    return;
  end if;
  aBRIEF:=func.roles_doc_BRIEF_F(aroles_docid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_doc_DELETE /**/ (
 aCURSESSION CHAR,
 aroles_docid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_doc where roles_docID=aroles_docID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_doc where roles_docid=aroles_docID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_doc',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_doc');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_doc_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_docid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_doc');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_roles_doc_state is select roles_doc_state.roles_doc_stateid ID from roles_doc_state where  roles_doc_state.ParentStructRowID = aroles_docid;
    child_roles_doc_state_rec  child_roles_doc_state%ROWTYPE;
    begin
    --open child_roles_doc_state;
      for child_roles_doc_state_rec in child_roles_doc_state loop
      roles_doc_state_DELETE (acursession,child_roles_doc_state_rec.id,aInstanceid);
      end loop;
      --close child_roles_doc_state;
    end ;
declare cursor chld_roles_doc is select  instanceid ID from instance where OwnerPartName ='roles_doc' and OwnerRowID=aroles_docid;
row_roles_doc  chld_roles_doc%ROWTYPE;
begin
--open chld_roles_doc;
for row_roles_doc in chld_roles_doc loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_doc.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_doc.id);
end loop;
--close chld_roles_doc;
end ;
  delete from  roles_doc 
  where  roles_docID = aroles_docID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные документы*/
procedure roles_doc_SAVE /**/ (
 aCURSESSION CHAR,
 aroles_docid CHAR,
aInstanceID CHAR 
,athe_document CHAR/* Тип документа *//* Тип документа */
,athe_denied
 NUMBER := null /* Запрещен *//* Запрещен */
,aallowdeletedoc
 NUMBER/* Разрешено удаление *//* Разрешено удаление */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_doc where roles_docID=aroles_docID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_doc where roles_docid=aroles_docID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_doc',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_doc');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_doc_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_docid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_doc');
    return;
  end if;
 -- update row  --
 update  roles_doc set ChangeStamp=sysdate
,
  the_document=athe_document
,
  the_denied=athe_denied
,
  allowdeletedoc=aallowdeletedoc
  where  roles_docID = aroles_docID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_doc where InstanceID=aInstanceID 
 and the_document=athe_document;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_doc');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_doc',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_doc');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_doc');
    return;
  end if;
 insert into   roles_doc
 (  roles_docID 
,InstanceID
,the_document

,the_denied

,allowdeletedoc

 ) values ( aroles_docID 
,aInstanceID
,athe_document

,athe_denied

,aallowdeletedoc

 ); 
 roles_doc_SINIT( aCURSESSION,aroles_docid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_doc where InstanceID=aInstanceID 
 and the_document=athe_document;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_doc');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure roles_doc_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles_doc where  roles_docid=aRowID;
 end; 

procedure roles_doc_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_doc where roles_docid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_doc_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_doc_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_doc_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_doc_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_doc where roles_docid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_doc');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_doc set LockUserID =auserID ,LockSessionID =null where roles_docid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_doc set LockUserID =null,LockSessionID =aCURSESSION  where roles_docid=aRowID;
     return;
   end if;
 end ;

procedure roles_doc_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_roles_doc_state is select roles_doc_state.roles_doc_stateid ID from roles_doc_state where  roles_doc_state.ParentStructRowID = aRowid;
row_roles_doc_state lch_roles_doc_state%ROWTYPE;
begin  
--open lch_roles_doc_state;
for row_roles_doc_state in lch_roles_doc_state
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from roles_doc_state where roles_doc_stateid=row_roles_doc_state.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_roles_doc_state;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_roles_doc_state;
     return;
   end if; 
 end if;  
 roles_doc_state_HCL (acursession,row_roles_doc_state.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_roles_doc_state;
   return;
 end if;
end loop;
--close lch_roles_doc_state;
end;
aIsLocked :=0;
end;

procedure roles_doc_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_doc_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_doc set LockUserID =null  where roles_docid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_doc set LockSessionID =null  where roles_docid=aRowID;
     return;
   end if;
 end; 

procedure roles_doc_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_doc where roles_docid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_doc');
    return;
  end if;
if aSecurityStyleID is null then
 roles_doc_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_doc set securitystyleid =aStyleID where roles_docid = aRowID;
else 
 update roles_doc set securitystyleid =aSecurityStyleID where roles_docid = aRowID;
end if; 
end ; 

procedure roles_doc_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_doc where roles_docid=aRowid;
declare cursor pch_roles_doc_state  is select roles_doc_state.roles_doc_stateid ID from roles_doc_state where  roles_doc_state.ParentStructRowID = aRowid;
row_roles_doc_state  pch_roles_doc_state%ROWTYPE;
begin
--open pch_roles_doc_state;
for row_roles_doc_state in pch_roles_doc_state loop
   roles_doc_state_SINIT( acursession,row_roles_doc_state.id,assid);
   roles_doc_state_propagate( acursession,row_roles_doc_state.id);
end loop;
--close pch_roles_doc_state;
end;
end;


procedure roles_doc_state_BRIEF  (
 aCURSESSION CHAR,
 aroles_doc_stateid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_doc_stateid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_doc_state where roles_doc_stateID=aroles_doc_stateID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_doc_state where roles_doc_stateid=aroles_doc_stateID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_doc_state');
    return;
  end if;
  aBRIEF:=func.roles_doc_state_BRIEF_F(aroles_doc_stateid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_doc_state_DELETE /**/ (
 aCURSESSION CHAR,
 aroles_doc_stateid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_doc_state where roles_doc_stateID=aroles_doc_stateID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_doc_state where roles_doc_stateid=aroles_doc_stateID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_doc_state',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_doc_state');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_doc_state_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_doc_stateid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_doc_state');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_roles_doc_state is select  instanceid ID from instance where OwnerPartName ='roles_doc_state' and OwnerRowID=aroles_doc_stateid;
row_roles_doc_state  chld_roles_doc_state%ROWTYPE;
begin
--open chld_roles_doc_state;
for row_roles_doc_state in chld_roles_doc_state loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_doc_state.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_doc_state.id);
end loop;
--close chld_roles_doc_state;
end ;
  delete from  roles_doc_state 
  where  roles_doc_stateID = aroles_doc_stateID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Доступные состояния*/
procedure roles_doc_state_SAVE /**/ (
 aCURSESSION CHAR,
 aroles_doc_stateid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_state CHAR := null /* Состояние *//* Состояние */
,athe_mode CHAR := null /* Режим *//* Режим */
,aallowdelete
 NUMBER/* Можно удалять *//* Можно удалять */
,astatechangedisabled
 NUMBER/* Запрещена смена состояния *//* Запрещена смена состояния */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_doc_state where roles_doc_stateID=aroles_doc_stateID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_doc_state where roles_doc_stateid=aroles_doc_stateID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_doc_state',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_doc_state');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_doc_state_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_doc_stateid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_doc_state');
    return;
  end if;
 -- update row  --
 update  roles_doc_state set ChangeStamp=sysdate
,
  the_state=athe_state
,
  the_mode=athe_mode
,
  allowdelete=aallowdelete
,
  statechangedisabled=astatechangedisabled
  where  roles_doc_stateID = aroles_doc_stateID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from roles_doc where roles_docid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_doc_state',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_doc_state');
      return;
    end if;
 end if;
 roles_doc_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_doc_state');
    return;
  end if;
 insert into   roles_doc_state
 (  roles_doc_stateID 
,ParentStructRowID
,the_state

,the_mode

,allowdelete

,statechangedisabled

 ) values ( aroles_doc_stateID 
,aParentStructRowID
,athe_state

,athe_mode

,aallowdelete

,astatechangedisabled

 ); 
 roles_doc_state_SINIT( aCURSESSION,aroles_doc_stateid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure roles_doc_state_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from roles_doc_state where  roles_doc_stateid=aRowID;
  aParentTable := 'roles_doc';
 end; 

procedure roles_doc_state_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_doc_state where roles_doc_stateid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_doc_state_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_doc_state_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_doc_state_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_doc_state_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_doc_state where roles_doc_stateid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_doc_state');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_doc_state set LockUserID =auserID ,LockSessionID =null where roles_doc_stateid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_doc_state set LockUserID =null,LockSessionID =aCURSESSION  where roles_doc_stateid=aRowID;
     return;
   end if;
 end ;

procedure roles_doc_state_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles_doc_state_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_doc_state_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_doc_state set LockUserID =null  where roles_doc_stateid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_doc_state set LockSessionID =null  where roles_doc_stateid=aRowID;
     return;
   end if;
 end; 

procedure roles_doc_state_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_doc_state where roles_doc_stateid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_doc_state');
    return;
  end if;
if aSecurityStyleID is null then
 roles_doc_state_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_doc_state set securitystyleid =aStyleID where roles_doc_stateid = aRowID;
else 
 update roles_doc_state set securitystyleid =aSecurityStyleID where roles_doc_stateid = aRowID;
end if; 
end ; 

procedure roles_doc_state_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_doc_state where roles_doc_stateid=aRowid;
end;


procedure roles_reports_BRIEF  (
 aCURSESSION CHAR,
 aroles_reportsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_reportsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_reports where roles_reportsID=aroles_reportsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_reports where roles_reportsid=aroles_reportsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_reports');
    return;
  end if;
  aBRIEF:=func.roles_reports_BRIEF_F(aroles_reportsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_reports_DELETE /**/ (
 aCURSESSION CHAR,
 aroles_reportsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_reports where roles_reportsID=aroles_reportsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_reports where roles_reportsid=aroles_reportsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_reports',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_reports');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_reports_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_reportsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_reports');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_roles_reports is select  instanceid ID from instance where OwnerPartName ='roles_reports' and OwnerRowID=aroles_reportsid;
row_roles_reports  chld_roles_reports%ROWTYPE;
begin
--open chld_roles_reports;
for row_roles_reports in chld_roles_reports loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_reports.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_reports.id);
end loop;
--close chld_roles_reports;
end ;
  delete from  roles_reports 
  where  roles_reportsID = aroles_reportsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отчёты*/
procedure roles_reports_SAVE /**/ (
 aCURSESSION CHAR,
 aroles_reportsid CHAR,
aInstanceID CHAR 
,athe_report CHAR/* Отчёт *//* Отчёт */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_reports where roles_reportsID=aroles_reportsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_reports where roles_reportsid=aroles_reportsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_reports',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_reports');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_reports_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_reportsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_reports');
    return;
  end if;
 -- update row  --
 update  roles_reports set ChangeStamp=sysdate
,
  the_report=athe_report
  where  roles_reportsID = aroles_reportsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_reports',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_reports');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_reports');
    return;
  end if;
 insert into   roles_reports
 (  roles_reportsID 
,InstanceID
,the_report

 ) values ( aroles_reportsID 
,aInstanceID
,athe_report

 ); 
 roles_reports_SINIT( aCURSESSION,aroles_reportsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure roles_reports_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles_reports where  roles_reportsid=aRowID;
 end; 

procedure roles_reports_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_reports where roles_reportsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_reports_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_reports_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_reports_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_reports_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_reports where roles_reportsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_reports');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_reports set LockUserID =auserID ,LockSessionID =null where roles_reportsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_reports set LockUserID =null,LockSessionID =aCURSESSION  where roles_reportsid=aRowID;
     return;
   end if;
 end ;

procedure roles_reports_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles_reports_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_reports_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_reports set LockUserID =null  where roles_reportsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_reports set LockSessionID =null  where roles_reportsid=aRowID;
     return;
   end if;
 end; 

procedure roles_reports_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_reports where roles_reportsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_reports');
    return;
  end if;
if aSecurityStyleID is null then
 roles_reports_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_reports set securitystyleid =aStyleID where roles_reportsid = aRowID;
else 
 update roles_reports set securitystyleid =aSecurityStyleID where roles_reportsid = aRowID;
end if; 
end ; 

procedure roles_reports_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_reports where roles_reportsid=aRowid;
end;


procedure roles_user_BRIEF  (
 aCURSESSION CHAR,
 aroles_userid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_userid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_user where roles_userID=aroles_userID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_user where roles_userid=aroles_userID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_user');
    return;
  end if;
  aBRIEF:=func.roles_user_BRIEF_F(aroles_userid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_user_DELETE /*Пользователи*/ (
 aCURSESSION CHAR,
 aroles_userid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_user where roles_userID=aroles_userID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_user where roles_userid=aroles_userID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_user',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_user');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_user_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_userid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_user');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_roles_user is select  instanceid ID from instance where OwnerPartName ='roles_user' and OwnerRowID=aroles_userid;
row_roles_user  chld_roles_user%ROWTYPE;
begin
--open chld_roles_user;
for row_roles_user in chld_roles_user loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_user.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_user.id);
end loop;
--close chld_roles_user;
end ;
  delete from  roles_user 
  where  roles_userID = aroles_userID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Пользователи*/
procedure roles_user_SAVE /*Пользователи*/ (
 aCURSESSION CHAR,
 aroles_userid CHAR,
aInstanceID CHAR 
,atheuser CHAR/* Пользователь *//* Пользователь */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_user where roles_userID=aroles_userID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_user where roles_userid=aroles_userID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_user',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_user');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_user_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_userid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_user');
    return;
  end if;
 -- update row  --
 update  roles_user set ChangeStamp=sysdate
,
  theuser=atheuser
  where  roles_userID = aroles_userID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_user where InstanceID=aInstanceID 
 and theuser=atheuser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_user');
 return;
end if;
 select Count(*) into aUniqueRowCount from roles_user where InstanceID=aInstanceID 
 and theuser=atheuser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_user');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_user',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_user');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_user');
    return;
  end if;
 insert into   roles_user
 (  roles_userID 
,InstanceID
,theuser

 ) values ( aroles_userID 
,aInstanceID
,atheuser

 ); 
 roles_user_SINIT( aCURSESSION,aroles_userid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_user where InstanceID=aInstanceID 
 and theuser=atheuser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_user');
 return;
end if;
 select Count(*) into aUniqueRowCount from roles_user where InstanceID=aInstanceID 
 and theuser=atheuser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_user');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure roles_user_PARENT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles_user where  roles_userid=aRowID;
 end; 

procedure roles_user_ISLOCKED /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_user where roles_userid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_user_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_user_LOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_user_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_user_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_user where roles_userid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_user');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_user set LockUserID =auserID ,LockSessionID =null where roles_userid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_user set LockUserID =null,LockSessionID =aCURSESSION  where roles_userid=aRowID;
     return;
   end if;
 end ;

procedure roles_user_HCL /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles_user_UNLOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_user_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_user set LockUserID =null  where roles_userid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_user set LockSessionID =null  where roles_userid=aRowID;
     return;
   end if;
 end; 

procedure roles_user_SINIT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_user where roles_userid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_user');
    return;
  end if;
if aSecurityStyleID is null then
 roles_user_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_user set securitystyleid =aStyleID where roles_userid = aRowID;
else 
 update roles_user set securitystyleid =aSecurityStyleID where roles_userid = aRowID;
end if; 
end ; 

procedure roles_user_propagate /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_user where roles_userid=aRowid;
end;


procedure roles_map_BRIEF  (
 aCURSESSION CHAR,
 aroles_mapid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_mapid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_map where roles_mapID=aroles_mapID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_map where roles_mapid=aroles_mapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_map');
    return;
  end if;
  aBRIEF:=func.roles_map_BRIEF_F(aroles_mapid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_map_DELETE /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aroles_mapid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_map where roles_mapID=aroles_mapID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_map where roles_mapid=aroles_mapID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_map',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_map');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_map_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_mapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_map');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_roles_map is select  instanceid ID from instance where OwnerPartName ='roles_map' and OwnerRowID=aroles_mapid;
row_roles_map  chld_roles_map%ROWTYPE;
begin
--open chld_roles_map;
for row_roles_map in chld_roles_map loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_map.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_map.id);
end loop;
--close chld_roles_map;
end ;
  delete from  roles_map 
  where  roles_mapID = aroles_mapID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отображение на группы*/
procedure roles_map_SAVE /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aroles_mapid CHAR,
aInstanceID CHAR 
,athegroup CHAR/* Группа *//* Группа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_map where roles_mapID=aroles_mapID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_map where roles_mapid=aroles_mapID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_map',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_map');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_map_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_mapid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_map');
    return;
  end if;
 -- update row  --
 update  roles_map set ChangeStamp=sysdate
,
  thegroup=athegroup
  where  roles_mapID = aroles_mapID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_map where InstanceID=aInstanceID 
 and thegroup=athegroup;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_map');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_map',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_map');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_map');
    return;
  end if;
 insert into   roles_map
 (  roles_mapID 
,InstanceID
,thegroup

 ) values ( aroles_mapID 
,aInstanceID
,athegroup

 ); 
 roles_map_SINIT( aCURSESSION,aroles_mapid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from roles_map where InstanceID=aInstanceID 
 and thegroup=athegroup;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_map');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure roles_map_PARENT /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles_map where  roles_mapid=aRowID;
 end; 

procedure roles_map_ISLOCKED /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_map where roles_mapid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_map_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_map_LOCK /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_map_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_map_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_map where roles_mapid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_map');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_map set LockUserID =auserID ,LockSessionID =null where roles_mapid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_map set LockUserID =null,LockSessionID =aCURSESSION  where roles_mapid=aRowID;
     return;
   end if;
 end ;

procedure roles_map_HCL /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles_map_UNLOCK /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_map_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_map set LockUserID =null  where roles_mapid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_map set LockSessionID =null  where roles_mapid=aRowID;
     return;
   end if;
 end; 

procedure roles_map_SINIT /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_map where roles_mapid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_map');
    return;
  end if;
if aSecurityStyleID is null then
 roles_map_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_map set securitystyleid =aStyleID where roles_mapid = aRowID;
else 
 update roles_map set securitystyleid =aSecurityStyleID where roles_mapid = aRowID;
end if; 
end ; 

procedure roles_map_propagate /*Отображение на группы защиты*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_map where roles_mapid=aRowid;
end;


procedure roles_def_BRIEF  (
 aCURSESSION CHAR,
 aroles_defid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if aroles_defid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from roles_def where roles_defID=aroles_defID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from roles_def where roles_defid=aroles_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=roles_def');
    return;
  end if;
  aBRIEF:=func.roles_def_BRIEF_F(aroles_defid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure roles_def_DELETE /*Определение роли*/ (
 aCURSESSION CHAR,
 aroles_defid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from roles_def where roles_defID=aroles_defID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from roles_def where roles_defid=aroles_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:roles_def',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=roles_def');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=roles_def');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_roles_def is select  instanceid ID from instance where OwnerPartName ='roles_def' and OwnerRowID=aroles_defid;
row_roles_def  chld_roles_def%ROWTYPE;
begin
--open chld_roles_def;
for row_roles_def in chld_roles_def loop
 Kernel.INSTANCE_OWNER (acursession,row_roles_def.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_roles_def.id);
end loop;
--close chld_roles_def;
end ;
  delete from  roles_def 
  where  roles_defID = aroles_defID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Определение роли*/
procedure roles_def_SAVE /*Определение роли*/ (
 aCURSESSION CHAR,
 aroles_defid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aallobjects
 NUMBER/* Вся фирма *//* Вся фирма */
,acolegsobject
 NUMBER/* Объекты коллег *//* Объекты коллег */
,asubstructobjects
 NUMBER/* Подчиненные подразделения *//* Подчиненные подразделения */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from roles_def where roles_defID=aroles_defID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from roles_def where roles_defid=aroles_defID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:roles_def',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=roles_def');
      return;
    end if;
  end if;
 --  verify lock  --
 roles_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aroles_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_def');
    return;
  end if;
 -- update row  --
 update  roles_def set ChangeStamp=sysdate
,
  name=aname
,
  allobjects=aallobjects
,
  colegsobject=acolegsobject
,
  substructobjects=asubstructobjects
  where  roles_defID = aroles_defID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from roles_def where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_def');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:roles_def',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=roles_def');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=roles_def');
    return;
  end if;
select Count(*) into existsCnt from roles_def where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;roles_def&gt;');
    return;
 End if;
 insert into   roles_def
 (  roles_defID 
,InstanceID
,name

,allobjects

,colegsobject

,substructobjects

 ) values ( aroles_defID 
,aInstanceID
,aname

,aallobjects

,acolegsobject

,asubstructobjects

 ); 
 roles_def_SINIT( aCURSESSION,aroles_defid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from roles_def where 1=1  
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=roles_def');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure roles_def_PARENT /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from roles_def where  roles_defid=aRowID;
 end; 

procedure roles_def_ISLOCKED /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from roles_def where roles_defid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  roles_def_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin roles.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure roles_def_LOCK /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 roles_def_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  roles_def_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from roles_def where roles_defid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=roles_def');
    return;
  end if;
   if  aLockMode =2  
   then   
    update roles_def set LockUserID =auserID ,LockSessionID =null where roles_defid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update roles_def set LockUserID =null,LockSessionID =aCURSESSION  where roles_defid=aRowID;
     return;
   end if;
 end ;

procedure roles_def_HCL /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure roles_def_UNLOCK /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 roles_def_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update roles_def set LockUserID =null  where roles_defid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update roles_def set LockSessionID =null  where roles_defid=aRowID;
     return;
   end if;
 end; 

procedure roles_def_SINIT /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from roles_def where roles_defid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =roles_def');
    return;
  end if;
if aSecurityStyleID is null then
 roles_def_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update roles_def set securitystyleid =aStyleID where roles_defid = aRowID;
else 
 update roles_def set securitystyleid =aSecurityStyleID where roles_defid = aRowID;
end if; 
end ; 

procedure roles_def_propagate /*Определение роли*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from roles_def where roles_defid=aRowid;
end;
end roles;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tosched" BlockCode=" create or replace package body tosched as

procedure tosched_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='tosched'
then
declare cursor child_to_scheditems is select to_scheditems.to_scheditemsid ID from to_scheditems where  to_scheditems.InstanceID = ainstanceid;
row_to_scheditems  child_to_scheditems%ROWTYPE;
begin
--open child_to_scheditems;
for row_to_scheditems in child_to_scheditems loop
 to_scheditems_DELETE (acursession,row_to_scheditems.id,aInstanceID);
end loop;
--close child_to_scheditems;
end;
declare cursor child_to_schedinfo is select to_schedinfo.to_schedinfoid ID from to_schedinfo where  to_schedinfo.InstanceID = ainstanceid;
row_to_schedinfo  child_to_schedinfo%ROWTYPE;
begin
--open child_to_schedinfo;
for row_to_schedinfo in child_to_schedinfo loop
 to_schedinfo_DELETE (acursession,row_to_schedinfo.id,aInstanceID);
end loop;
--close child_to_schedinfo;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure tosched_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'tosched'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_to_scheditems is select to_scheditems.to_scheditemsid ID from to_scheditems where  to_scheditems.InstanceID = arowid;
ROW_to_scheditems  lch_to_scheditems%ROWTYPE;
begin
--open lch_to_scheditems;
for row_to_scheditems in lch_to_scheditems loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_scheditems where to_scheditemsid=row_to_scheditems.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_scheditems;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_scheditems;
     return;
   end if; 
 end if; 
 to_scheditems_HCL (acursession,ROW_to_scheditems.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_scheditems;
   return;
 end if;
 end loop;
--close lch_to_scheditems;
end;
declare cursor lch_to_schedinfo is select to_schedinfo.to_schedinfoid ID from to_schedinfo where  to_schedinfo.InstanceID = arowid;
ROW_to_schedinfo  lch_to_schedinfo%ROWTYPE;
begin
--open lch_to_schedinfo;
for row_to_schedinfo in lch_to_schedinfo loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_schedinfo where to_schedinfoid=row_to_schedinfo.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_schedinfo;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_schedinfo;
     return;
   end if; 
 end if; 
 to_schedinfo_HCL (acursession,ROW_to_schedinfo.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_schedinfo;
   return;
 end if;
 end loop;
--close lch_to_schedinfo;
end;
 end if;
aIsLocked:=0;
end;
procedure tosched_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'tosched'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_to_scheditems is select to_scheditems.to_scheditemsid id from to_scheditems where  to_scheditems.InstanceID = arowid;
row_to_scheditems  pch_to_scheditems%ROWTYPE;
begin
--open pch_to_scheditems;
for row_to_scheditems in  pch_to_scheditems loop
 to_scheditems_SINIT( acursession,row_to_scheditems.id,assid);
 to_scheditems_propagate( acursession,row_to_scheditems.id);
end loop;
--close pch_to_scheditems;
end;
declare cursor pch_to_schedinfo is select to_schedinfo.to_schedinfoid id from to_schedinfo where  to_schedinfo.InstanceID = arowid;
row_to_schedinfo  pch_to_schedinfo%ROWTYPE;
begin
--open pch_to_schedinfo;
for row_to_schedinfo in  pch_to_schedinfo loop
 to_schedinfo_SINIT( acursession,row_to_schedinfo.id,assid);
 to_schedinfo_propagate( acursession,row_to_schedinfo.id);
end loop;
--close pch_to_schedinfo;
end;
 end if; 
end;


procedure to_scheditems_BRIEF  (
 aCURSESSION CHAR,
 ato_scheditemsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_scheditemsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_scheditems where to_scheditemsID=ato_scheditemsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_scheditems where to_scheditemsid=ato_scheditemsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_scheditems');
    return;
  end if;
  aBRIEF:=func.to_scheditems_BRIEF_F(ato_scheditemsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_scheditems_DELETE /**/ (
 aCURSESSION CHAR,
 ato_scheditemsid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_scheditems where to_scheditemsID=ato_scheditemsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_scheditems where to_scheditemsid=ato_scheditemsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_scheditems',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_scheditems');
      return;
    end if;
  end if;
 --  verify lock  --
 to_scheditems_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_scheditemsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_scheditems');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_scheditems',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_scheditemsid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_scheditems is select  instanceid ID from instance where OwnerPartName ='to_scheditems' and OwnerRowID=ato_scheditemsid;
row_to_scheditems  chld_to_scheditems%ROWTYPE;
begin
--open chld_to_scheditems;
for row_to_scheditems in chld_to_scheditems loop
 Kernel.INSTANCE_OWNER (acursession,row_to_scheditems.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_scheditems.id);
end loop;
--close chld_to_scheditems;
end ;
  delete from  to_scheditems 
  where  to_scheditemsID = ato_scheditemsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Расписание ТО*/
procedure to_scheditems_SAVE /**/ (
 aCURSESSION CHAR,
 ato_scheditemsid CHAR,
aInstanceID CHAR 
,athemachine CHAR/* Станок *//* Станок */
,atodate
 DATE/* Плановая дата ТО *//* Плановая дата ТО */
,acheckin
 DATE := null /* Взят в работу *//* Взят в работу */
,aoper CHAR := null /* Оператор *//* Оператор */
,aisdone
 NUMBER := null /* ТО проведено *//* ТО проведено */
,afinishdate
 DATE := null /* Дата завершения ТО *//* Дата завершения ТО */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_scheditems where to_scheditemsID=ato_scheditemsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_scheditems where to_scheditemsid=ato_scheditemsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_scheditems',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_scheditems');
      return;
    end if;
  end if;
 --  verify lock  --
 to_scheditems_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_scheditemsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_scheditems');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_scheditems',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_scheditemsid,aLogInstanceID=&gt;aInstanceID);
 update  to_scheditems set ChangeStamp=sysdate
,
  themachine=athemachine
,
  todate=atodate
,
  checkin=acheckin
,
  oper=aoper
,
  isdone=aisdone
,
  finishdate=afinishdate
  where  to_scheditemsID = ato_scheditemsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_scheditems',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_scheditems');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_scheditems');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_scheditems',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_scheditemsid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_scheditems
 (  to_scheditemsID 
,InstanceID
,themachine

,todate

,checkin

,oper

,isdone

,finishdate

 ) values ( ato_scheditemsID 
,aInstanceID
,athemachine

,atodate

,acheckin

,aoper

,aisdone

,afinishdate

 ); 
 to_scheditems_SINIT( aCURSESSION,ato_scheditemsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_scheditems_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_scheditems where  to_scheditemsid=aRowID;
 end; 

procedure to_scheditems_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_scheditems where to_scheditemsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_scheditems_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tosched.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_scheditems_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_scheditems_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_scheditems_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_scheditems where to_scheditemsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_scheditems');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_scheditems set LockUserID =auserID ,LockSessionID =null where to_scheditemsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_scheditems set LockUserID =null,LockSessionID =aCURSESSION  where to_scheditemsid=aRowID;
     return;
   end if;
 end ;

procedure to_scheditems_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_scheditems_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_scheditems_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_scheditems set LockUserID =null  where to_scheditemsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_scheditems set LockSessionID =null  where to_scheditemsid=aRowID;
     return;
   end if;
 end; 

procedure to_scheditems_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_scheditems where to_scheditemsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_scheditems');
    return;
  end if;
if aSecurityStyleID is null then
 to_scheditems_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_scheditems set securitystyleid =aStyleID where to_scheditemsid = aRowID;
else 
 update to_scheditems set securitystyleid =aSecurityStyleID where to_scheditemsid = aRowID;
end if; 
end ; 

procedure to_scheditems_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_scheditems where to_scheditemsid=aRowid;
end;


procedure to_schedinfo_BRIEF  (
 aCURSESSION CHAR,
 ato_schedinfoid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_schedinfoid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_schedinfo where to_schedinfoID=ato_schedinfoID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_schedinfo where to_schedinfoid=ato_schedinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_schedinfo');
    return;
  end if;
  aBRIEF:=func.to_schedinfo_BRIEF_F(ato_schedinfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_schedinfo_DELETE /**/ (
 aCURSESSION CHAR,
 ato_schedinfoid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_schedinfo where to_schedinfoID=ato_schedinfoID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_schedinfo where to_schedinfoid=ato_schedinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_schedinfo',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_schedinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 to_schedinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_schedinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_schedinfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_schedinfo',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_schedinfoid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_schedinfo is select  instanceid ID from instance where OwnerPartName ='to_schedinfo' and OwnerRowID=ato_schedinfoid;
row_to_schedinfo  chld_to_schedinfo%ROWTYPE;
begin
--open chld_to_schedinfo;
for row_to_schedinfo in chld_to_schedinfo loop
 Kernel.INSTANCE_OWNER (acursession,row_to_schedinfo.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_schedinfo.id);
end loop;
--close chld_to_schedinfo;
end ;
  delete from  to_schedinfo 
  where  to_schedinfoID = ato_schedinfoID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure to_schedinfo_SAVE /**/ (
 aCURSESSION CHAR,
 ato_schedinfoid CHAR,
aInstanceID CHAR 
,adfrom
 DATE/* С *//* С */
,adto
 DATE := null /* По *//* По */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_schedinfo where to_schedinfoID=ato_schedinfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_schedinfo where to_schedinfoid=ato_schedinfoID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_schedinfo',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_schedinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 to_schedinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_schedinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_schedinfo');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_schedinfo',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_schedinfoid,aLogInstanceID=&gt;aInstanceID);
 update  to_schedinfo set ChangeStamp=sysdate
,
  dfrom=adfrom
,
  dto=adto
  where  to_schedinfoID = ato_schedinfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_schedinfo',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_schedinfo');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_schedinfo');
    return;
  end if;
select Count(*) into existsCnt from to_schedinfo where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;to_schedinfo&gt;');
    return;
 End if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_schedinfo',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_schedinfoid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_schedinfo
 (  to_schedinfoID 
,InstanceID
,dfrom

,dto

 ) values ( ato_schedinfoID 
,aInstanceID
,adfrom

,adto

 ); 
 to_schedinfo_SINIT( aCURSESSION,ato_schedinfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_schedinfo_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_schedinfo where  to_schedinfoid=aRowID;
 end; 

procedure to_schedinfo_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_schedinfo where to_schedinfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_schedinfo_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tosched.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_schedinfo_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_schedinfo_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_schedinfo_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_schedinfo where to_schedinfoid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_schedinfo');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_schedinfo set LockUserID =auserID ,LockSessionID =null where to_schedinfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_schedinfo set LockUserID =null,LockSessionID =aCURSESSION  where to_schedinfoid=aRowID;
     return;
   end if;
 end ;

procedure to_schedinfo_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_schedinfo_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_schedinfo_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_schedinfo set LockUserID =null  where to_schedinfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_schedinfo set LockSessionID =null  where to_schedinfoid=aRowID;
     return;
   end if;
 end; 

procedure to_schedinfo_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_schedinfo where to_schedinfoid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_schedinfo');
    return;
  end if;
if aSecurityStyleID is null then
 to_schedinfo_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_schedinfo set securitystyleid =aStyleID where to_schedinfoid = aRowID;
else 
 update to_schedinfo set securitystyleid =aSecurityStyleID where to_schedinfoid = aRowID;
end if; 
end ; 

procedure to_schedinfo_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_schedinfo where to_schedinfoid=aRowid;
end;
end tosched;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--totrn" BlockCode=" create or replace package body totrn as

procedure totrn_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='totrn'
then
declare cursor child_totrn_data is select totrn_data.totrn_dataid ID from totrn_data where  totrn_data.InstanceID = ainstanceid;
row_totrn_data  child_totrn_data%ROWTYPE;
begin
--open child_totrn_data;
for row_totrn_data in child_totrn_data loop
 totrn_data_DELETE (acursession,row_totrn_data.id,aInstanceID);
end loop;
--close child_totrn_data;
end;
declare cursor child_totrn_def is select totrn_def.totrn_defid ID from totrn_def where  totrn_def.InstanceID = ainstanceid;
row_totrn_def  child_totrn_def%ROWTYPE;
begin
--open child_totrn_def;
for row_totrn_def in child_totrn_def loop
 totrn_def_DELETE (acursession,row_totrn_def.id,aInstanceID);
end loop;
--close child_totrn_def;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure totrn_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'totrn'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_totrn_data is select totrn_data.totrn_dataid ID from totrn_data where  totrn_data.InstanceID = arowid;
ROW_totrn_data  lch_totrn_data%ROWTYPE;
begin
--open lch_totrn_data;
for row_totrn_data in lch_totrn_data loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from totrn_data where totrn_dataid=row_totrn_data.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_totrn_data;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_totrn_data;
     return;
   end if; 
 end if; 
 totrn_data_HCL (acursession,ROW_totrn_data.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_totrn_data;
   return;
 end if;
 end loop;
--close lch_totrn_data;
end;
declare cursor lch_totrn_def is select totrn_def.totrn_defid ID from totrn_def where  totrn_def.InstanceID = arowid;
ROW_totrn_def  lch_totrn_def%ROWTYPE;
begin
--open lch_totrn_def;
for row_totrn_def in lch_totrn_def loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from totrn_def where totrn_defid=row_totrn_def.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_totrn_def;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_totrn_def;
     return;
   end if; 
 end if; 
 totrn_def_HCL (acursession,ROW_totrn_def.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_totrn_def;
   return;
 end if;
 end loop;
--close lch_totrn_def;
end;
 end if;
aIsLocked:=0;
end;
procedure totrn_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'totrn'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_totrn_data is select totrn_data.totrn_dataid id from totrn_data where  totrn_data.InstanceID = arowid;
row_totrn_data  pch_totrn_data%ROWTYPE;
begin
--open pch_totrn_data;
for row_totrn_data in  pch_totrn_data loop
 totrn_data_SINIT( acursession,row_totrn_data.id,assid);
 totrn_data_propagate( acursession,row_totrn_data.id);
end loop;
--close pch_totrn_data;
end;
declare cursor pch_totrn_def is select totrn_def.totrn_defid id from totrn_def where  totrn_def.InstanceID = arowid;
row_totrn_def  pch_totrn_def%ROWTYPE;
begin
--open pch_totrn_def;
for row_totrn_def in  pch_totrn_def loop
 totrn_def_SINIT( acursession,row_totrn_def.id,assid);
 totrn_def_propagate( acursession,row_totrn_def.id);
end loop;
--close pch_totrn_def;
end;
 end if; 
end;


procedure totrn_data_BRIEF  (
 aCURSESSION CHAR,
 atotrn_dataid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atotrn_dataid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from totrn_data where totrn_dataID=atotrn_dataID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from totrn_data where totrn_dataid=atotrn_dataID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=totrn_data');
    return;
  end if;
  aBRIEF:=func.totrn_data_BRIEF_F(atotrn_dataid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure totrn_data_DELETE /**/ (
 aCURSESSION CHAR,
 atotrn_dataid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from totrn_data where totrn_dataID=atotrn_dataID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from totrn_data where totrn_dataid=atotrn_dataID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:totrn_data',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=totrn_data');
      return;
    end if;
  end if;
 --  verify lock  --
 totrn_data_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atotrn_dataid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=totrn_data');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'totrn_data',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atotrn_dataid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_totrn_data is select  instanceid ID from instance where OwnerPartName ='totrn_data' and OwnerRowID=atotrn_dataid;
row_totrn_data  chld_totrn_data%ROWTYPE;
begin
--open chld_totrn_data;
for row_totrn_data in chld_totrn_data loop
 Kernel.INSTANCE_OWNER (acursession,row_totrn_data.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_totrn_data.id);
end loop;
--close chld_totrn_data;
end ;
  delete from  totrn_data 
  where  totrn_dataID = atotrn_dataID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Данные тренда*/
procedure totrn_data_SAVE /**/ (
 aCURSESSION CHAR,
 atotrn_dataid CHAR,
aInstanceID CHAR 
,atime_label
 DATE/* Временная метка *//* Временная метка */
,athevalue
 NUMBER/* Значение *//* Значение */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from totrn_data where totrn_dataID=atotrn_dataID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from totrn_data where totrn_dataid=atotrn_dataID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:totrn_data',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=totrn_data');
      return;
    end if;
  end if;
 --  verify lock  --
 totrn_data_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atotrn_dataid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=totrn_data');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'totrn_data',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atotrn_dataid,aLogInstanceID=&gt;aInstanceID);
 update  totrn_data set ChangeStamp=sysdate
,
  time_label=atime_label
,
  thevalue=athevalue
  where  totrn_dataID = atotrn_dataID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:totrn_data',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=totrn_data');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=totrn_data');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'totrn_data',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atotrn_dataid,aLogInstanceID=&gt;aInstanceID);
 insert into   totrn_data
 (  totrn_dataID 
,InstanceID
,time_label

,thevalue

 ) values ( atotrn_dataID 
,aInstanceID
,atime_label

,athevalue

 ); 
 totrn_data_SINIT( aCURSESSION,atotrn_dataid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure totrn_data_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from totrn_data where  totrn_dataid=aRowID;
 end; 

procedure totrn_data_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from totrn_data where totrn_dataid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  totrn_data_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin totrn.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure totrn_data_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 totrn_data_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  totrn_data_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from totrn_data where totrn_dataid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=totrn_data');
    return;
  end if;
   if  aLockMode =2  
   then   
    update totrn_data set LockUserID =auserID ,LockSessionID =null where totrn_dataid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update totrn_data set LockUserID =null,LockSessionID =aCURSESSION  where totrn_dataid=aRowID;
     return;
   end if;
 end ;

procedure totrn_data_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure totrn_data_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 totrn_data_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update totrn_data set LockUserID =null  where totrn_dataid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update totrn_data set LockSessionID =null  where totrn_dataid=aRowID;
     return;
   end if;
 end; 

procedure totrn_data_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from totrn_data where totrn_dataid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =totrn_data');
    return;
  end if;
if aSecurityStyleID is null then
 totrn_data_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update totrn_data set securitystyleid =aStyleID where totrn_dataid = aRowID;
else 
 update totrn_data set securitystyleid =aSecurityStyleID where totrn_dataid = aRowID;
end if; 
end ; 

procedure totrn_data_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from totrn_data where totrn_dataid=aRowid;
end;


procedure totrn_def_BRIEF  (
 aCURSESSION CHAR,
 atotrn_defid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atotrn_defid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from totrn_def where totrn_defID=atotrn_defID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from totrn_def where totrn_defid=atotrn_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=totrn_def');
    return;
  end if;
  aBRIEF:=func.totrn_def_BRIEF_F(atotrn_defid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure totrn_def_DELETE /**/ (
 aCURSESSION CHAR,
 atotrn_defid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from totrn_def where totrn_defID=atotrn_defID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from totrn_def where totrn_defid=atotrn_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:totrn_def',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=totrn_def');
      return;
    end if;
  end if;
 --  verify lock  --
 totrn_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atotrn_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=totrn_def');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'totrn_def',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atotrn_defid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_totrn_def is select  instanceid ID from instance where OwnerPartName ='totrn_def' and OwnerRowID=atotrn_defid;
row_totrn_def  chld_totrn_def%ROWTYPE;
begin
--open chld_totrn_def;
for row_totrn_def in chld_totrn_def loop
 Kernel.INSTANCE_OWNER (acursession,row_totrn_def.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_totrn_def.id);
end loop;
--close chld_totrn_def;
end ;
  delete from  totrn_def 
  where  totrn_defID = atotrn_defID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание тренда*/
procedure totrn_def_SAVE /**/ (
 aCURSESSION CHAR,
 atotrn_defid CHAR,
aInstanceID CHAR 
,athemachine CHAR/* Станок *//* Станок */
,atrandtype CHAR/* Тип тренда *//* Тип тренда */
,atopvalue
 NUMBER := null /* Верхняя граница *//* Верхняя граница */
,abottomval
 NUMBER := null /* Нижняя граница *//* Нижняя граница */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from totrn_def where totrn_defID=atotrn_defID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from totrn_def where totrn_defid=atotrn_defID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:totrn_def',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=totrn_def');
      return;
    end if;
  end if;
 --  verify lock  --
 totrn_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atotrn_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=totrn_def');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'totrn_def',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atotrn_defid,aLogInstanceID=&gt;aInstanceID);
 update  totrn_def set ChangeStamp=sysdate
,
  themachine=athemachine
,
  trandtype=atrandtype
,
  topvalue=atopvalue
,
  bottomval=abottomval
  where  totrn_defID = atotrn_defID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:totrn_def',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=totrn_def');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=totrn_def');
    return;
  end if;
select Count(*) into existsCnt from totrn_def where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;totrn_def&gt;');
    return;
 End if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'totrn_def',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atotrn_defid,aLogInstanceID=&gt;aInstanceID);
 insert into   totrn_def
 (  totrn_defID 
,InstanceID
,themachine

,trandtype

,topvalue

,bottomval

 ) values ( atotrn_defID 
,aInstanceID
,athemachine

,atrandtype

,atopvalue

,abottomval

 ); 
 totrn_def_SINIT( aCURSESSION,atotrn_defid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure totrn_def_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from totrn_def where  totrn_defid=aRowID;
 end; 

procedure totrn_def_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from totrn_def where totrn_defid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  totrn_def_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin totrn.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure totrn_def_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 totrn_def_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  totrn_def_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from totrn_def where totrn_defid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=totrn_def');
    return;
  end if;
   if  aLockMode =2  
   then   
    update totrn_def set LockUserID =auserID ,LockSessionID =null where totrn_defid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update totrn_def set LockUserID =null,LockSessionID =aCURSESSION  where totrn_defid=aRowID;
     return;
   end if;
 end ;

procedure totrn_def_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure totrn_def_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 totrn_def_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update totrn_def set LockUserID =null  where totrn_defid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update totrn_def set LockSessionID =null  where totrn_defid=aRowID;
     return;
   end if;
 end; 

procedure totrn_def_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from totrn_def where totrn_defid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =totrn_def');
    return;
  end if;
if aSecurityStyleID is null then
 totrn_def_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update totrn_def set securitystyleid =aStyleID where totrn_defid = aRowID;
else 
 update totrn_def set securitystyleid =aSecurityStyleID where totrn_defid = aRowID;
end if; 
end ; 

procedure totrn_def_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from totrn_def where totrn_defid=aRowid;
end;
end totrn;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--totask" BlockCode=" create or replace package body totask as

procedure totask_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='totask'
then
declare cursor child_to_taskcomment is select to_taskcomment.to_taskcommentid ID from to_taskcomment where  to_taskcomment.InstanceID = ainstanceid;
row_to_taskcomment  child_to_taskcomment%ROWTYPE;
begin
--open child_to_taskcomment;
for row_to_taskcomment in child_to_taskcomment loop
 to_taskcomment_DELETE (acursession,row_to_taskcomment.id,aInstanceID);
end loop;
--close child_to_taskcomment;
end;
declare cursor child_to_taskinfo is select to_taskinfo.to_taskinfoid ID from to_taskinfo where  to_taskinfo.InstanceID = ainstanceid;
row_to_taskinfo  child_to_taskinfo%ROWTYPE;
begin
--open child_to_taskinfo;
for row_to_taskinfo in child_to_taskinfo loop
 to_taskinfo_DELETE (acursession,row_to_taskinfo.id,aInstanceID);
end loop;
--close child_to_taskinfo;
end;
declare cursor child_to_taskchecks is select to_taskchecks.to_taskchecksid ID from to_taskchecks where  to_taskchecks.InstanceID = ainstanceid;
row_to_taskchecks  child_to_taskchecks%ROWTYPE;
begin
--open child_to_taskchecks;
for row_to_taskchecks in child_to_taskchecks loop
 to_taskchecks_DELETE (acursession,row_to_taskchecks.id,aInstanceID);
end loop;
--close child_to_taskchecks;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure totask_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'totask'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_to_taskcomment is select to_taskcomment.to_taskcommentid ID from to_taskcomment where  to_taskcomment.InstanceID = arowid;
ROW_to_taskcomment  lch_to_taskcomment%ROWTYPE;
begin
--open lch_to_taskcomment;
for row_to_taskcomment in lch_to_taskcomment loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_taskcomment where to_taskcommentid=row_to_taskcomment.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_taskcomment;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_taskcomment;
     return;
   end if; 
 end if; 
 to_taskcomment_HCL (acursession,ROW_to_taskcomment.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_taskcomment;
   return;
 end if;
 end loop;
--close lch_to_taskcomment;
end;
declare cursor lch_to_taskinfo is select to_taskinfo.to_taskinfoid ID from to_taskinfo where  to_taskinfo.InstanceID = arowid;
ROW_to_taskinfo  lch_to_taskinfo%ROWTYPE;
begin
--open lch_to_taskinfo;
for row_to_taskinfo in lch_to_taskinfo loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_taskinfo where to_taskinfoid=row_to_taskinfo.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_taskinfo;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_taskinfo;
     return;
   end if; 
 end if; 
 to_taskinfo_HCL (acursession,ROW_to_taskinfo.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_taskinfo;
   return;
 end if;
 end loop;
--close lch_to_taskinfo;
end;
declare cursor lch_to_taskchecks is select to_taskchecks.to_taskchecksid ID from to_taskchecks where  to_taskchecks.InstanceID = arowid;
ROW_to_taskchecks  lch_to_taskchecks%ROWTYPE;
begin
--open lch_to_taskchecks;
for row_to_taskchecks in lch_to_taskchecks loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_taskchecks where to_taskchecksid=row_to_taskchecks.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_taskchecks;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_taskchecks;
     return;
   end if; 
 end if; 
 to_taskchecks_HCL (acursession,ROW_to_taskchecks.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_taskchecks;
   return;
 end if;
 end loop;
--close lch_to_taskchecks;
end;
 end if;
aIsLocked:=0;
end;
procedure totask_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'totask'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_to_taskcomment is select to_taskcomment.to_taskcommentid id from to_taskcomment where  to_taskcomment.InstanceID = arowid;
row_to_taskcomment  pch_to_taskcomment%ROWTYPE;
begin
--open pch_to_taskcomment;
for row_to_taskcomment in  pch_to_taskcomment loop
 to_taskcomment_SINIT( acursession,row_to_taskcomment.id,assid);
 to_taskcomment_propagate( acursession,row_to_taskcomment.id);
end loop;
--close pch_to_taskcomment;
end;
declare cursor pch_to_taskinfo is select to_taskinfo.to_taskinfoid id from to_taskinfo where  to_taskinfo.InstanceID = arowid;
row_to_taskinfo  pch_to_taskinfo%ROWTYPE;
begin
--open pch_to_taskinfo;
for row_to_taskinfo in  pch_to_taskinfo loop
 to_taskinfo_SINIT( acursession,row_to_taskinfo.id,assid);
 to_taskinfo_propagate( acursession,row_to_taskinfo.id);
end loop;
--close pch_to_taskinfo;
end;
declare cursor pch_to_taskchecks is select to_taskchecks.to_taskchecksid id from to_taskchecks where  to_taskchecks.InstanceID = arowid;
row_to_taskchecks  pch_to_taskchecks%ROWTYPE;
begin
--open pch_to_taskchecks;
for row_to_taskchecks in  pch_to_taskchecks loop
 to_taskchecks_SINIT( acursession,row_to_taskchecks.id,assid);
 to_taskchecks_propagate( acursession,row_to_taskchecks.id);
end loop;
--close pch_to_taskchecks;
end;
 end if; 
end;


procedure to_taskcomment_BRIEF  (
 aCURSESSION CHAR,
 ato_taskcommentid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_taskcommentid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_taskcomment where to_taskcommentID=ato_taskcommentID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_taskcomment where to_taskcommentid=ato_taskcommentID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_taskcomment');
    return;
  end if;
  aBRIEF:=func.to_taskcomment_BRIEF_F(ato_taskcommentid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_taskcomment_DELETE /**/ (
 aCURSESSION CHAR,
 ato_taskcommentid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_taskcomment where to_taskcommentID=ato_taskcommentID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_taskcomment where to_taskcommentid=ato_taskcommentID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_taskcomment',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_taskcomment');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskcomment_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskcommentid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_taskcomment');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskcomment',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_taskcommentid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_taskcomment is select  instanceid ID from instance where OwnerPartName ='to_taskcomment' and OwnerRowID=ato_taskcommentid;
row_to_taskcomment  chld_to_taskcomment%ROWTYPE;
begin
--open chld_to_taskcomment;
for row_to_taskcomment in chld_to_taskcomment loop
 Kernel.INSTANCE_OWNER (acursession,row_to_taskcomment.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_taskcomment.id);
end loop;
--close chld_to_taskcomment;
end ;
  delete from  to_taskcomment 
  where  to_taskcommentID = ato_taskcommentID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Примечания*/
procedure to_taskcomment_SAVE /**/ (
 aCURSESSION CHAR,
 ato_taskcommentid CHAR,
aInstanceID CHAR 
,acodetocomment CHAR := null /* Узел *//* Узел */
,athecomment VARCHAR2/* Примечание *//* Примечание */
,athe_operator CHAR/* Оператор *//* Оператор */
,athe_date
 DATE/* Дата комментария *//* Дата комментария */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_taskcomment where to_taskcommentID=ato_taskcommentID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_taskcomment where to_taskcommentid=ato_taskcommentID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_taskcomment',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_taskcomment');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskcomment_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskcommentid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskcomment');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskcomment',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_taskcommentid,aLogInstanceID=&gt;aInstanceID);
 update  to_taskcomment set ChangeStamp=sysdate
,
  codetocomment=acodetocomment
,
  thecomment=athecomment
,
  the_operator=athe_operator
,
  the_date=athe_date
  where  to_taskcommentID = ato_taskcommentID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_taskcomment',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_taskcomment');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskcomment');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskcomment',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_taskcommentid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_taskcomment
 (  to_taskcommentID 
,InstanceID
,codetocomment

,thecomment

,the_operator

,the_date

 ) values ( ato_taskcommentID 
,aInstanceID
,acodetocomment

,athecomment

,athe_operator

,athe_date

 ); 
 to_taskcomment_SINIT( aCURSESSION,ato_taskcommentid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_taskcomment_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_taskcomment where  to_taskcommentid=aRowID;
 end; 

procedure to_taskcomment_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_taskcomment where to_taskcommentid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_taskcomment_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin totask.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_taskcomment_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_taskcomment_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_taskcomment_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_taskcomment where to_taskcommentid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_taskcomment');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_taskcomment set LockUserID =auserID ,LockSessionID =null where to_taskcommentid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_taskcomment set LockUserID =null,LockSessionID =aCURSESSION  where to_taskcommentid=aRowID;
     return;
   end if;
 end ;

procedure to_taskcomment_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_taskcomment_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_taskcomment_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_taskcomment set LockUserID =null  where to_taskcommentid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_taskcomment set LockSessionID =null  where to_taskcommentid=aRowID;
     return;
   end if;
 end; 

procedure to_taskcomment_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_taskcomment where to_taskcommentid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_taskcomment');
    return;
  end if;
if aSecurityStyleID is null then
 to_taskcomment_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_taskcomment set securitystyleid =aStyleID where to_taskcommentid = aRowID;
else 
 update to_taskcomment set securitystyleid =aSecurityStyleID where to_taskcommentid = aRowID;
end if; 
end ; 

procedure to_taskcomment_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_taskcomment where to_taskcommentid=aRowid;
end;


procedure to_taskinfo_BRIEF  (
 aCURSESSION CHAR,
 ato_taskinfoid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_taskinfoid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_taskinfo where to_taskinfoID=ato_taskinfoID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_taskinfo where to_taskinfoid=ato_taskinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_taskinfo');
    return;
  end if;
  aBRIEF:=func.to_taskinfo_BRIEF_F(ato_taskinfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_taskinfo_DELETE /**/ (
 aCURSESSION CHAR,
 ato_taskinfoid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_taskinfo where to_taskinfoID=ato_taskinfoID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_taskinfo where to_taskinfoid=ato_taskinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_taskinfo',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_taskinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_taskinfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskinfo',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_taskinfoid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_taskinfo is select  instanceid ID from instance where OwnerPartName ='to_taskinfo' and OwnerRowID=ato_taskinfoid;
row_to_taskinfo  chld_to_taskinfo%ROWTYPE;
begin
--open chld_to_taskinfo;
for row_to_taskinfo in chld_to_taskinfo loop
 Kernel.INSTANCE_OWNER (acursession,row_to_taskinfo.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_taskinfo.id);
end loop;
--close chld_to_taskinfo;
end ;
  delete from  to_taskinfo 
  where  to_taskinfoID = ato_taskinfoID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure to_taskinfo_SAVE /**/ (
 aCURSESSION CHAR,
 ato_taskinfoid CHAR,
aInstanceID CHAR 
,athemachine CHAR/* Пункт расписания *//* Пункт расписания */
,aoper CHAR/* Оператор *//* Оператор */
,athecard CHAR := null /* Диагностическая карта *//* Диагностическая карта */
,acrdate
 DATE/* Дата создания *//* Дата создания */
,ataskfinished
 NUMBER := null /* Задача завершена *//* Задача завершена */
,afinishtime
 DATE := null /* Время завершения задачи *//* Время завершения задачи */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_taskinfo where to_taskinfoID=ato_taskinfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_taskinfo where to_taskinfoid=ato_taskinfoID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_taskinfo',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_taskinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskinfo');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskinfo',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_taskinfoid,aLogInstanceID=&gt;aInstanceID);
 update  to_taskinfo set ChangeStamp=sysdate
,
  themachine=athemachine
,
  oper=aoper
,
  thecard=athecard
,
  crdate=acrdate
,
  taskfinished=ataskfinished
,
  finishtime=afinishtime
  where  to_taskinfoID = ato_taskinfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_taskinfo',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_taskinfo');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskinfo');
    return;
  end if;
select Count(*) into existsCnt from to_taskinfo where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;to_taskinfo&gt;');
    return;
 End if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskinfo',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_taskinfoid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_taskinfo
 (  to_taskinfoID 
,InstanceID
,themachine

,oper

,thecard

,crdate

,taskfinished

,finishtime

 ) values ( ato_taskinfoID 
,aInstanceID
,athemachine

,aoper

,athecard

,acrdate

,ataskfinished

,afinishtime

 ); 
 to_taskinfo_SINIT( aCURSESSION,ato_taskinfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_taskinfo_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_taskinfo where  to_taskinfoid=aRowID;
 end; 

procedure to_taskinfo_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_taskinfo where to_taskinfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_taskinfo_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin totask.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_taskinfo_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_taskinfo_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_taskinfo_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_taskinfo where to_taskinfoid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_taskinfo');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_taskinfo set LockUserID =auserID ,LockSessionID =null where to_taskinfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_taskinfo set LockUserID =null,LockSessionID =aCURSESSION  where to_taskinfoid=aRowID;
     return;
   end if;
 end ;

procedure to_taskinfo_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_taskinfo_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_taskinfo_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_taskinfo set LockUserID =null  where to_taskinfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_taskinfo set LockSessionID =null  where to_taskinfoid=aRowID;
     return;
   end if;
 end; 

procedure to_taskinfo_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_taskinfo where to_taskinfoid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_taskinfo');
    return;
  end if;
if aSecurityStyleID is null then
 to_taskinfo_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_taskinfo set securitystyleid =aStyleID where to_taskinfoid = aRowID;
else 
 update to_taskinfo set securitystyleid =aSecurityStyleID where to_taskinfoid = aRowID;
end if; 
end ; 

procedure to_taskinfo_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_taskinfo where to_taskinfoid=aRowid;
end;


procedure to_taskchecks_BRIEF  (
 aCURSESSION CHAR,
 ato_taskchecksid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_taskchecksid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_taskchecks where to_taskchecksID=ato_taskchecksID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_taskchecks where to_taskchecksid=ato_taskchecksID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_taskchecks');
    return;
  end if;
  aBRIEF:=func.to_taskchecks_BRIEF_F(ato_taskchecksid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_taskchecks_DELETE /**/ (
 aCURSESSION CHAR,
 ato_taskchecksid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_taskchecks where to_taskchecksID=ato_taskchecksID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_taskchecks where to_taskchecksid=ato_taskchecksID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_taskchecks',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_taskchecks');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskchecks_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskchecksid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_taskchecks');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_to_taskcheckcomment is select to_taskcheckcomment.to_taskcheckcommentid ID from to_taskcheckcomment where  to_taskcheckcomment.ParentStructRowID = ato_taskchecksid;
    child_to_taskcheckcomment_rec  child_to_taskcheckcomment%ROWTYPE;
    begin
    --open child_to_taskcheckcomment;
      for child_to_taskcheckcomment_rec in child_to_taskcheckcomment loop
      to_taskcheckcomment_DELETE (acursession,child_to_taskcheckcomment_rec.id,aInstanceid);
      end loop;
      --close child_to_taskcheckcomment;
    end ;
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskchecks',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_taskchecksid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_taskchecks is select  instanceid ID from instance where OwnerPartName ='to_taskchecks' and OwnerRowID=ato_taskchecksid;
row_to_taskchecks  chld_to_taskchecks%ROWTYPE;
begin
--open chld_to_taskchecks;
for row_to_taskchecks in chld_to_taskchecks loop
 Kernel.INSTANCE_OWNER (acursession,row_to_taskchecks.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_taskchecks.id);
end loop;
--close chld_to_taskchecks;
end ;
  delete from  to_taskchecks 
  where  to_taskchecksID = ato_taskchecksID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Проверки*/
procedure to_taskchecks_SAVE /**/ (
 aCURSESSION CHAR,
 ato_taskchecksid CHAR,
aInstanceID CHAR 
,athe_system CHAR/* Группа узлов *//* Группа узлов */
,athesubsystem
 VARCHAR2/* Узел *//* Узел */
,athe_check
 VARCHAR2/* Показатель *//* Показатель */
,anormochas
 NUMBER := null /* Нормочас *//* Нормочас */
,avaluetype CHAR/* Измерение *//* Измерение */
,alowvalue
 VARCHAR2 := null /* Нижняя граница (&gt;=) *//* Нижняя граница (&gt;=) */
,ahivalue
 VARCHAR2 := null /* Верхняя граница (&lt;=) *//* Верхняя граница (&lt;=) */
,athe_comment VARCHAR2 := null /* Примечание *//* Примечание */
,athevalue
 VARCHAR2 := null /* Значение *//* Значение */
,athe_doc VARCHAR2 := null /* Документация *//* Документация */
,acheckref CHAR/* Основание для проверки *//* Основание для проверки */
,atagid
 VARCHAR2 := null /* Метка *//* Метка */
,atagtime
 DATE := null /* Дата регистрации метки *//* Дата регистрации метки */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_taskchecks where to_taskchecksID=ato_taskchecksID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_taskchecks where to_taskchecksid=ato_taskchecksID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_taskchecks',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_taskchecks');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskchecks_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskchecksid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskchecks');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskchecks',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_taskchecksid,aLogInstanceID=&gt;aInstanceID);
 update  to_taskchecks set ChangeStamp=sysdate
,
  the_system=athe_system
,
  thesubsystem=athesubsystem
,
  the_check=athe_check
,
  normochas=anormochas
,
  valuetype=avaluetype
,
  lowvalue=alowvalue
,
  hivalue=ahivalue
,
  the_comment=athe_comment
,
  thevalue=athevalue
,
  the_doc=athe_doc
,
  checkref=acheckref
,
  tagid=atagid
,
  tagtime=atagtime
  where  to_taskchecksID = ato_taskchecksID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_taskchecks',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_taskchecks');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskchecks');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskchecks',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_taskchecksid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_taskchecks
 (  to_taskchecksID 
,InstanceID
,the_system

,thesubsystem

,the_check

,normochas

,valuetype

,lowvalue

,hivalue

,the_comment

,thevalue

,the_doc

,checkref

,tagid

,tagtime

 ) values ( ato_taskchecksID 
,aInstanceID
,athe_system

,athesubsystem

,athe_check

,anormochas

,avaluetype

,alowvalue

,ahivalue

,athe_comment

,athevalue

,athe_doc

,acheckref

,atagid

,atagtime

 ); 
 to_taskchecks_SINIT( aCURSESSION,ato_taskchecksid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_taskchecks_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_taskchecks where  to_taskchecksid=aRowID;
 end; 

procedure to_taskchecks_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_taskchecks where to_taskchecksid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_taskchecks_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin totask.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_taskchecks_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_taskchecks_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_taskchecks_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_taskchecks where to_taskchecksid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_taskchecks');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_taskchecks set LockUserID =auserID ,LockSessionID =null where to_taskchecksid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_taskchecks set LockUserID =null,LockSessionID =aCURSESSION  where to_taskchecksid=aRowID;
     return;
   end if;
 end ;

procedure to_taskchecks_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_to_taskcheckcomment is select to_taskcheckcomment.to_taskcheckcommentid ID from to_taskcheckcomment where  to_taskcheckcomment.ParentStructRowID = aRowid;
row_to_taskcheckcomment lch_to_taskcheckcomment%ROWTYPE;
begin  
--open lch_to_taskcheckcomment;
for row_to_taskcheckcomment in lch_to_taskcheckcomment
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from to_taskcheckcomment where to_taskcheckcommentid=row_to_taskcheckcomment.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_taskcheckcomment;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_to_taskcheckcomment;
     return;
   end if; 
 end if;  
 to_taskcheckcomment_HCL (acursession,row_to_taskcheckcomment.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_taskcheckcomment;
   return;
 end if;
end loop;
--close lch_to_taskcheckcomment;
end;
aIsLocked :=0;
end;

procedure to_taskchecks_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_taskchecks_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_taskchecks set LockUserID =null  where to_taskchecksid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_taskchecks set LockSessionID =null  where to_taskchecksid=aRowID;
     return;
   end if;
 end; 

procedure to_taskchecks_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_taskchecks where to_taskchecksid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_taskchecks');
    return;
  end if;
if aSecurityStyleID is null then
 to_taskchecks_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_taskchecks set securitystyleid =aStyleID where to_taskchecksid = aRowID;
else 
 update to_taskchecks set securitystyleid =aSecurityStyleID where to_taskchecksid = aRowID;
end if; 
end ; 

procedure to_taskchecks_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_taskchecks where to_taskchecksid=aRowid;
declare cursor pch_to_taskcheckcomment  is select to_taskcheckcomment.to_taskcheckcommentid ID from to_taskcheckcomment where  to_taskcheckcomment.ParentStructRowID = aRowid;
row_to_taskcheckcomment  pch_to_taskcheckcomment%ROWTYPE;
begin
--open pch_to_taskcheckcomment;
for row_to_taskcheckcomment in pch_to_taskcheckcomment loop
   to_taskcheckcomment_SINIT( acursession,row_to_taskcheckcomment.id,assid);
   to_taskcheckcomment_propagate( acursession,row_to_taskcheckcomment.id);
end loop;
--close pch_to_taskcheckcomment;
end;
end;


procedure to_taskcheckcomment_BRIEF  (
 aCURSESSION CHAR,
 ato_taskcheckcommentid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_taskcheckcommentid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_taskcheckcomment where to_taskcheckcommentID=ato_taskcheckcommentID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_taskcheckcomment where to_taskcheckcommentid=ato_taskcheckcommentID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_taskcheckcomment');
    return;
  end if;
  aBRIEF:=func.to_taskcheckcomment_BRIEF_F(ato_taskcheckcommentid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_taskcheckcomment_DELETE /**/ (
 aCURSESSION CHAR,
 ato_taskcheckcommentid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_taskcheckcomment where to_taskcheckcommentID=ato_taskcheckcommentID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_taskcheckcomment where to_taskcheckcommentid=ato_taskcheckcommentID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_taskcheckcomment',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_taskcheckcomment');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskcheckcomment_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskcheckcommentid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_taskcheckcomment');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskcheckcomment',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_taskcheckcommentid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_taskcheckcomment is select  instanceid ID from instance where OwnerPartName ='to_taskcheckcomment' and OwnerRowID=ato_taskcheckcommentid;
row_to_taskcheckcomment  chld_to_taskcheckcomment%ROWTYPE;
begin
--open chld_to_taskcheckcomment;
for row_to_taskcheckcomment in chld_to_taskcheckcomment loop
 Kernel.INSTANCE_OWNER (acursession,row_to_taskcheckcomment.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_taskcheckcomment.id);
end loop;
--close chld_to_taskcheckcomment;
end ;
  delete from  to_taskcheckcomment 
  where  to_taskcheckcommentID = ato_taskcheckcommentID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Комментарии к проверке*/
procedure to_taskcheckcomment_SAVE /**/ (
 aCURSESSION CHAR,
 ato_taskcheckcommentid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_operator CHAR/* Оператор *//* Оператор */
,athe_date
 DATE/* Дата комментария *//* Дата комментария */
,ainfo VARCHAR2/* Суть комментария *//* Суть комментария */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_taskcheckcomment where to_taskcheckcommentID=ato_taskcheckcommentID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_taskcheckcomment where to_taskcheckcommentid=ato_taskcheckcommentID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_taskcheckcomment',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_taskcheckcomment');
      return;
    end if;
  end if;
 --  verify lock  --
 to_taskcheckcomment_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_taskcheckcommentid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskcheckcomment');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskcheckcomment',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_taskcheckcommentid,aLogInstanceID=&gt;aInstanceID);
 update  to_taskcheckcomment set ChangeStamp=sysdate
,
  the_operator=athe_operator
,
  the_date=athe_date
,
  info=ainfo
  where  to_taskcheckcommentID = ato_taskcheckcommentID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from to_taskchecks where to_taskchecksid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_taskcheckcomment',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_taskcheckcomment');
      return;
    end if;
 end if;
 to_taskchecks_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_taskcheckcomment');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_taskcheckcomment',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_taskcheckcommentid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_taskcheckcomment
 (  to_taskcheckcommentID 
,ParentStructRowID
,the_operator

,the_date

,info

 ) values ( ato_taskcheckcommentID 
,aParentStructRowID
,athe_operator

,athe_date

,ainfo

 ); 
 to_taskcheckcomment_SINIT( aCURSESSION,ato_taskcheckcommentid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_taskcheckcomment_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from to_taskcheckcomment where  to_taskcheckcommentid=aRowID;
  aParentTable := 'to_taskchecks';
 end; 

procedure to_taskcheckcomment_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_taskcheckcomment where to_taskcheckcommentid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_taskcheckcomment_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin totask.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_taskcheckcomment_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_taskcheckcomment_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_taskcheckcomment_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_taskcheckcomment where to_taskcheckcommentid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_taskcheckcomment');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_taskcheckcomment set LockUserID =auserID ,LockSessionID =null where to_taskcheckcommentid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_taskcheckcomment set LockUserID =null,LockSessionID =aCURSESSION  where to_taskcheckcommentid=aRowID;
     return;
   end if;
 end ;

procedure to_taskcheckcomment_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_taskcheckcomment_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_taskcheckcomment_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_taskcheckcomment set LockUserID =null  where to_taskcheckcommentid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_taskcheckcomment set LockSessionID =null  where to_taskcheckcommentid=aRowID;
     return;
   end if;
 end; 

procedure to_taskcheckcomment_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_taskcheckcomment where to_taskcheckcommentid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_taskcheckcomment');
    return;
  end if;
if aSecurityStyleID is null then
 to_taskcheckcomment_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_taskcheckcomment set securitystyleid =aStyleID where to_taskcheckcommentid = aRowID;
else 
 update to_taskcheckcomment set securitystyleid =aSecurityStyleID where to_taskcheckcommentid = aRowID;
end if; 
end ; 

procedure to_taskcheckcomment_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_taskcheckcomment where to_taskcheckcommentid=aRowid;
end;
end totask;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzusers" BlockCode=" create or replace package body mtzusers as

procedure mtzusers_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzusers'
then
declare cursor child_users is select users.usersid ID from users where  users.InstanceID = ainstanceid;
row_users  child_users%ROWTYPE;
begin
--open child_users;
for row_users in child_users loop
 users_DELETE (acursession,row_users.id,aInstanceID);
end loop;
--close child_users;
end;
declare cursor child_groups is select groups.groupsid ID from groups where  groups.InstanceID = ainstanceid;
row_groups  child_groups%ROWTYPE;
begin
--open child_groups;
for row_groups in child_groups loop
 groups_DELETE (acursession,row_groups.id,aInstanceID);
end loop;
--close child_groups;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzusers_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzusers'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_users is select users.usersid ID from users where  users.InstanceID = arowid;
ROW_users  lch_users%ROWTYPE;
begin
--open lch_users;
for row_users in lch_users loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from users where usersid=row_users.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_users;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_users;
     return;
   end if; 
 end if; 
 users_HCL (acursession,ROW_users.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_users;
   return;
 end if;
 end loop;
--close lch_users;
end;
declare cursor lch_groups is select groups.groupsid ID from groups where  groups.InstanceID = arowid;
ROW_groups  lch_groups%ROWTYPE;
begin
--open lch_groups;
for row_groups in lch_groups loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from groups where groupsid=row_groups.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_groups;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_groups;
     return;
   end if; 
 end if; 
 groups_HCL (acursession,ROW_groups.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_groups;
   return;
 end if;
 end loop;
--close lch_groups;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzusers_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzusers'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_users is select users.usersid id from users where  users.InstanceID = arowid;
row_users  pch_users%ROWTYPE;
begin
--open pch_users;
for row_users in  pch_users loop
 users_SINIT( acursession,row_users.id,assid);
 users_propagate( acursession,row_users.id);
end loop;
--close pch_users;
end;
declare cursor pch_groups is select groups.groupsid id from groups where  groups.InstanceID = arowid;
row_groups  pch_groups%ROWTYPE;
begin
--open pch_groups;
for row_groups in  pch_groups loop
 groups_SINIT( acursession,row_groups.id,assid);
 groups_propagate( acursession,row_groups.id);
end loop;
--close pch_groups;
end;
 end if; 
end;


procedure users_BRIEF  (
 aCURSESSION CHAR,
 ausersid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ausersid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from users where usersID=ausersID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from users where usersid=ausersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=users');
    return;
  end if;
  aBRIEF:=func.users_BRIEF_F(ausersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure users_DELETE /*Пользователи*/ (
 aCURSESSION CHAR,
 ausersid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from users where usersID=ausersID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from users where usersid=ausersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:users',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=users');
      return;
    end if;
  end if;
 --  verify lock  --
 users_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ausersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=users');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_users is select  instanceid ID from instance where OwnerPartName ='users' and OwnerRowID=ausersid;
row_users  chld_users%ROWTYPE;
begin
--open chld_users;
for row_users in chld_users loop
 Kernel.INSTANCE_OWNER (acursession,row_users.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_users.id);
end loop;
--close chld_users;
end ;
  delete from  users 
  where  usersID = ausersID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Пользователи*/
procedure users_SAVE /*Пользователи*/ (
 aCURSESSION CHAR,
 ausersid CHAR,
aInstanceID CHAR 
,afamily
 VARCHAR2/* Фамилия *//* Фамилия */
,aname
 VARCHAR2/* Имя *//* Имя */
,asurname
 VARCHAR2/* Отчество *//* Отчество */
,alogin
 VARCHAR2/* Имя для входа *//* Имя для входа */
,apassword VARCHAR2 := null /* Пароль *//* Пароль */
,adomainame
 VARCHAR2 := null /* Доменное имя *//* Доменное имя */
,aemail VARCHAR2 := null /* e-mail *//* e-mail */
,aphone
 VARCHAR2 := null /* Телефон *//* Телефон */
,alocalphone
 VARCHAR2 := null /* Местный телефон *//* Местный телефон */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from users where usersID=ausersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from users where usersid=ausersID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:users',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=users');
      return;
    end if;
  end if;
 --  verify lock  --
 users_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ausersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=users');
    return;
  end if;
 -- update row  --
 update  users set ChangeStamp=sysdate
,
  family=afamily
,
  name=aname
,
  surname=asurname
,
  login=alogin
,
  password=apassword
,
  domainame=adomainame
,
  email=aemail
,
  phone=aphone
,
  localphone=alocalphone
  where  usersID = ausersID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from users where InstanceID=aInstanceID 
 and login=alogin;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=users');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:users',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=users');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=users');
    return;
  end if;
 insert into   users
 (  usersID 
,InstanceID
,family

,name

,surname

,login

,password

,domainame

,email

,phone

,localphone

 ) values ( ausersID 
,aInstanceID
,afamily

,aname

,asurname

,alogin

,apassword

,adomainame

,aemail

,aphone

,alocalphone

 ); 
 users_SINIT( aCURSESSION,ausersid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from users where InstanceID=aInstanceID 
 and login=alogin;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=users');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure users_PARENT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from users where  usersid=aRowID;
 end; 

procedure users_ISLOCKED /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from users where usersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  users_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzusers.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure users_LOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 users_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  users_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from users where usersid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=users');
    return;
  end if;
   if  aLockMode =2  
   then   
    update users set LockUserID =auserID ,LockSessionID =null where usersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update users set LockUserID =null,LockSessionID =aCURSESSION  where usersid=aRowID;
     return;
   end if;
 end ;

procedure users_HCL /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure users_UNLOCK /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 users_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update users set LockUserID =null  where usersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update users set LockSessionID =null  where usersid=aRowID;
     return;
   end if;
 end; 

procedure users_SINIT /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from users where usersid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =users');
    return;
  end if;
if aSecurityStyleID is null then
 users_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update users set securitystyleid =aStyleID where usersid = aRowID;
else 
 update users set securitystyleid =aSecurityStyleID where usersid = aRowID;
end if; 
end ; 

procedure users_propagate /*Пользователи*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from users where usersid=aRowid;
end;


procedure groups_BRIEF  (
 aCURSESSION CHAR,
 agroupsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if agroupsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from groups where groupsID=agroupsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from groups where groupsid=agroupsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=groups');
    return;
  end if;
  aBRIEF:=func.groups_BRIEF_F(agroupsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure groups_DELETE /*Группы*/ (
 aCURSESSION CHAR,
 agroupsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from groups where groupsID=agroupsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from groups where groupsid=agroupsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:groups',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=groups');
      return;
    end if;
  end if;
 --  verify lock  --
 groups_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agroupsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=groups');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_groupuser is select groupuser.groupuserid ID from groupuser where  groupuser.ParentStructRowID = agroupsid;
    child_groupuser_rec  child_groupuser%ROWTYPE;
    begin
    --open child_groupuser;
      for child_groupuser_rec in child_groupuser loop
      groupuser_DELETE (acursession,child_groupuser_rec.id,aInstanceid);
      end loop;
      --close child_groupuser;
    end ;
declare cursor chld_groups is select  instanceid ID from instance where OwnerPartName ='groups' and OwnerRowID=agroupsid;
row_groups  chld_groups%ROWTYPE;
begin
--open chld_groups;
for row_groups in chld_groups loop
 Kernel.INSTANCE_OWNER (acursession,row_groups.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_groups.id);
end loop;
--close chld_groups;
end ;
  delete from  groups 
  where  groupsID = agroupsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Группы*/
procedure groups_SAVE /*Группы*/ (
 aCURSESSION CHAR,
 agroupsid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aadgroup
 VARCHAR2 := null /* Группа AD *//* Группа AD */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from groups where groupsID=agroupsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from groups where groupsid=agroupsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:groups',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=groups');
      return;
    end if;
  end if;
 --  verify lock  --
 groups_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agroupsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=groups');
    return;
  end if;
 -- update row  --
 update  groups set ChangeStamp=sysdate
,
  name=aname
,
  adgroup=aadgroup
  where  groupsID = agroupsID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from groups where InstanceID=aInstanceID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=groups');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:groups',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=groups');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=groups');
    return;
  end if;
 insert into   groups
 (  groupsID 
,InstanceID
,name

,adgroup

 ) values ( agroupsID 
,aInstanceID
,aname

,aadgroup

 ); 
 groups_SINIT( aCURSESSION,agroupsid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from groups where InstanceID=aInstanceID 
 and name=aname;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=groups');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure groups_PARENT /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from groups where  groupsid=aRowID;
 end; 

procedure groups_ISLOCKED /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from groups where groupsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  groups_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzusers.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure groups_LOCK /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 groups_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  groups_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from groups where groupsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=groups');
    return;
  end if;
   if  aLockMode =2  
   then   
    update groups set LockUserID =auserID ,LockSessionID =null where groupsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update groups set LockUserID =null,LockSessionID =aCURSESSION  where groupsid=aRowID;
     return;
   end if;
 end ;

procedure groups_HCL /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_groupuser is select groupuser.groupuserid ID from groupuser where  groupuser.ParentStructRowID = aRowid;
row_groupuser lch_groupuser%ROWTYPE;
begin  
--open lch_groupuser;
for row_groupuser in lch_groupuser
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from groupuser where groupuserid=row_groupuser.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_groupuser;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_groupuser;
     return;
   end if; 
 end if;  
 groupuser_HCL (acursession,row_groupuser.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_groupuser;
   return;
 end if;
end loop;
--close lch_groupuser;
end;
aIsLocked :=0;
end;

procedure groups_UNLOCK /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 groups_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update groups set LockUserID =null  where groupsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update groups set LockSessionID =null  where groupsid=aRowID;
     return;
   end if;
 end; 

procedure groups_SINIT /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from groups where groupsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =groups');
    return;
  end if;
if aSecurityStyleID is null then
 groups_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update groups set securitystyleid =aStyleID where groupsid = aRowID;
else 
 update groups set securitystyleid =aSecurityStyleID where groupsid = aRowID;
end if; 
end ; 

procedure groups_propagate /*Группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from groups where groupsid=aRowid;
declare cursor pch_groupuser  is select groupuser.groupuserid ID from groupuser where  groupuser.ParentStructRowID = aRowid;
row_groupuser  pch_groupuser%ROWTYPE;
begin
--open pch_groupuser;
for row_groupuser in pch_groupuser loop
   groupuser_SINIT( acursession,row_groupuser.id,assid);
   groupuser_propagate( acursession,row_groupuser.id);
end loop;
--close pch_groupuser;
end;
end;


procedure groupuser_BRIEF  (
 aCURSESSION CHAR,
 agroupuserid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if agroupuserid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from groupuser where groupuserID=agroupuserID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from groupuser where groupuserid=agroupuserID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=groupuser');
    return;
  end if;
  aBRIEF:=func.groupuser_BRIEF_F(agroupuserid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure groupuser_DELETE /*Состав группы*/ (
 aCURSESSION CHAR,
 agroupuserid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from groupuser where groupuserID=agroupuserID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from groupuser where groupuserid=agroupuserID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:groupuser',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=groupuser');
      return;
    end if;
  end if;
 --  verify lock  --
 groupuser_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agroupuserid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=groupuser');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_groupuser is select  instanceid ID from instance where OwnerPartName ='groupuser' and OwnerRowID=agroupuserid;
row_groupuser  chld_groupuser%ROWTYPE;
begin
--open chld_groupuser;
for row_groupuser in chld_groupuser loop
 Kernel.INSTANCE_OWNER (acursession,row_groupuser.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_groupuser.id);
end loop;
--close chld_groupuser;
end ;
  delete from  groupuser 
  where  groupuserID = agroupuserID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Состав группы*/
procedure groupuser_SAVE /*Состав группы*/ (
 aCURSESSION CHAR,
 agroupuserid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,atheuser CHAR/* Пользователь *//* Пользователь */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from groupuser where groupuserID=agroupuserID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from groupuser where groupuserid=agroupuserID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:groupuser',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=groupuser');
      return;
    end if;
  end if;
 --  verify lock  --
 groupuser_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;agroupuserid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=groupuser');
    return;
  end if;
 -- update row  --
 update  groupuser set ChangeStamp=sysdate
,
  theuser=atheuser
  where  groupuserID = agroupuserID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from groupuser where ParentStructRowID=aParentStructRowID 
 and theuser=atheuser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=groupuser');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from groups where groupsid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:groupuser',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=groupuser');
      return;
    end if;
 end if;
 groups_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=groupuser');
    return;
  end if;
 insert into   groupuser
 (  groupuserID 
,ParentStructRowID
,theuser

 ) values ( agroupuserID 
,aParentStructRowID
,atheuser

 ); 
 groupuser_SINIT( aCURSESSION,agroupuserid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from groupuser where ParentStructRowID=aParentStructRowID 
 and theuser=atheuser;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=groupuser');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure groupuser_PARENT /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from groupuser where  groupuserid=aRowID;
  aParentTable := 'groups';
 end; 

procedure groupuser_ISLOCKED /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from groupuser where groupuserid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  groupuser_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzusers.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure groupuser_LOCK /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 groupuser_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  groupuser_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from groupuser where groupuserid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=groupuser');
    return;
  end if;
   if  aLockMode =2  
   then   
    update groupuser set LockUserID =auserID ,LockSessionID =null where groupuserid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update groupuser set LockUserID =null,LockSessionID =aCURSESSION  where groupuserid=aRowID;
     return;
   end if;
 end ;

procedure groupuser_HCL /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure groupuser_UNLOCK /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 groupuser_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update groupuser set LockUserID =null  where groupuserid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update groupuser set LockSessionID =null  where groupuserid=aRowID;
     return;
   end if;
 end; 

procedure groupuser_SINIT /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from groupuser where groupuserid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =groupuser');
    return;
  end if;
if aSecurityStyleID is null then
 groupuser_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update groupuser set securitystyleid =aStyleID where groupuserid = aRowID;
else 
 update groupuser set securitystyleid =aSecurityStyleID where groupuserid = aRowID;
end if; 
end ; 

procedure groupuser_propagate /*Состав группы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from groupuser where groupuserid=aRowid;
end;
end mtzusers;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--toop" BlockCode=" create or replace package body toop as

procedure toop_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='toop'
then
declare cursor child_to_oper is select to_oper.to_operid ID from to_oper where  to_oper.InstanceID = ainstanceid;
row_to_oper  child_to_oper%ROWTYPE;
begin
--open child_to_oper;
for row_to_oper in child_to_oper loop
 to_oper_DELETE (acursession,row_to_oper.id,aInstanceID);
end loop;
--close child_to_oper;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure toop_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'toop'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_to_oper is select to_oper.to_operid ID from to_oper where  to_oper.InstanceID = arowid;
ROW_to_oper  lch_to_oper%ROWTYPE;
begin
--open lch_to_oper;
for row_to_oper in lch_to_oper loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_oper where to_operid=row_to_oper.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_oper;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_oper;
     return;
   end if; 
 end if; 
 to_oper_HCL (acursession,ROW_to_oper.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_oper;
   return;
 end if;
 end loop;
--close lch_to_oper;
end;
 end if;
aIsLocked:=0;
end;
procedure toop_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'toop'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_to_oper is select to_oper.to_operid id from to_oper where  to_oper.InstanceID = arowid;
row_to_oper  pch_to_oper%ROWTYPE;
begin
--open pch_to_oper;
for row_to_oper in  pch_to_oper loop
 to_oper_SINIT( acursession,row_to_oper.id,assid);
 to_oper_propagate( acursession,row_to_oper.id);
end loop;
--close pch_to_oper;
end;
 end if; 
end;


procedure to_oper_BRIEF  (
 aCURSESSION CHAR,
 ato_operid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_operid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_oper where to_operID=ato_operID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_oper where to_operid=ato_operID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_oper');
    return;
  end if;
  aBRIEF:=func.to_oper_BRIEF_F(ato_operid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_oper_DELETE /**/ (
 aCURSESSION CHAR,
 ato_operid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_oper where to_operID=ato_operID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_oper where to_operid=ato_operID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_oper',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_oper');
      return;
    end if;
  end if;
 --  verify lock  --
 to_oper_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_operid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_oper');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_oper',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_operid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_oper is select  instanceid ID from instance where OwnerPartName ='to_oper' and OwnerRowID=ato_operid;
row_to_oper  chld_to_oper%ROWTYPE;
begin
--open chld_to_oper;
for row_to_oper in chld_to_oper loop
 Kernel.INSTANCE_OWNER (acursession,row_to_oper.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_oper.id);
end loop;
--close chld_to_oper;
end ;
  delete from  to_oper 
  where  to_operID = ato_operID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Оператор*/
procedure to_oper_SAVE /**/ (
 aCURSESSION CHAR,
 ato_operid CHAR,
aInstanceID CHAR 
,afamilyname
 VARCHAR2/* Фамилия *//* Фамилия */
,aname
 VARCHAR2/* Имя *//* Имя */
,asurname
 VARCHAR2/* Отчество *//* Отчество */
,atnum
 VARCHAR2 := null /* Табельный номер *//* Табельный номер */
,atherole CHAR := null /* Роль *//* Роль */
,alogin
 VARCHAR2 := null /* Логин *//* Логин */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_oper where to_operID=ato_operID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_oper where to_operid=ato_operID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_oper',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_oper');
      return;
    end if;
  end if;
 --  verify lock  --
 to_oper_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_operid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_oper');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_oper',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_operid,aLogInstanceID=&gt;aInstanceID);
 update  to_oper set ChangeStamp=sysdate
,
  familyname=afamilyname
,
  name=aname
,
  surname=asurname
,
  tnum=atnum
,
  therole=atherole
,
  login=alogin
  where  to_operID = ato_operID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_oper',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_oper');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_oper');
    return;
  end if;
select Count(*) into existsCnt from to_oper where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;to_oper&gt;');
    return;
 End if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_oper',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_operid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_oper
 (  to_operID 
,InstanceID
,familyname

,name

,surname

,tnum

,therole

,login

 ) values ( ato_operID 
,aInstanceID
,afamilyname

,aname

,asurname

,atnum

,atherole

,alogin

 ); 
 to_oper_SINIT( aCURSESSION,ato_operid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_oper_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_oper where  to_operid=aRowID;
 end; 

procedure to_oper_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_oper where to_operid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_oper_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin toop.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_oper_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_oper_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_oper_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_oper where to_operid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_oper');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_oper set LockUserID =auserID ,LockSessionID =null where to_operid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_oper set LockUserID =null,LockSessionID =aCURSESSION  where to_operid=aRowID;
     return;
   end if;
 end ;

procedure to_oper_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_oper_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_oper_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_oper set LockUserID =null  where to_operid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_oper set LockSessionID =null  where to_operid=aRowID;
     return;
   end if;
 end; 

procedure to_oper_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_oper where to_operid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_oper');
    return;
  end if;
if aSecurityStyleID is null then
 to_oper_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_oper set securitystyleid =aStyleID where to_operid = aRowID;
else 
 update to_oper set securitystyleid =aSecurityStyleID where to_operid = aRowID;
end if; 
end ; 

procedure to_oper_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_oper where to_operid=aRowid;
end;
end toop;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--stdnumerator" BlockCode=" create or replace package body stdnumerator as

procedure stdnumerator_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='stdnumerator'
then
declare cursor child_num_zones is select num_zones.num_zonesid ID from num_zones where  num_zones.InstanceID = ainstanceid;
row_num_zones  child_num_zones%ROWTYPE;
begin
--open child_num_zones;
for row_num_zones in child_num_zones loop
 num_zones_DELETE (acursession,row_num_zones.id,aInstanceID);
end loop;
--close child_num_zones;
end;
declare cursor child_num_head is select num_head.num_headid ID from num_head where  num_head.InstanceID = ainstanceid;
row_num_head  child_num_head%ROWTYPE;
begin
--open child_num_head;
for row_num_head in child_num_head loop
 num_head_DELETE (acursession,row_num_head.id,aInstanceID);
end loop;
--close child_num_head;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure stdnumerator_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'stdnumerator'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_num_zones is select num_zones.num_zonesid ID from num_zones where  num_zones.InstanceID = arowid;
ROW_num_zones  lch_num_zones%ROWTYPE;
begin
--open lch_num_zones;
for row_num_zones in lch_num_zones loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from num_zones where num_zonesid=row_num_zones.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_num_zones;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_num_zones;
     return;
   end if; 
 end if; 
 num_zones_HCL (acursession,ROW_num_zones.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_num_zones;
   return;
 end if;
 end loop;
--close lch_num_zones;
end;
declare cursor lch_num_head is select num_head.num_headid ID from num_head where  num_head.InstanceID = arowid;
ROW_num_head  lch_num_head%ROWTYPE;
begin
--open lch_num_head;
for row_num_head in lch_num_head loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from num_head where num_headid=row_num_head.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_num_head;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_num_head;
     return;
   end if; 
 end if; 
 num_head_HCL (acursession,ROW_num_head.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_num_head;
   return;
 end if;
 end loop;
--close lch_num_head;
end;
 end if;
aIsLocked:=0;
end;
procedure stdnumerator_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'stdnumerator'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_num_zones is select num_zones.num_zonesid id from num_zones where  num_zones.InstanceID = arowid;
row_num_zones  pch_num_zones%ROWTYPE;
begin
--open pch_num_zones;
for row_num_zones in  pch_num_zones loop
 num_zones_SINIT( acursession,row_num_zones.id,assid);
 num_zones_propagate( acursession,row_num_zones.id);
end loop;
--close pch_num_zones;
end;
declare cursor pch_num_head is select num_head.num_headid id from num_head where  num_head.InstanceID = arowid;
row_num_head  pch_num_head%ROWTYPE;
begin
--open pch_num_head;
for row_num_head in  pch_num_head loop
 num_head_SINIT( acursession,row_num_head.id,assid);
 num_head_propagate( acursession,row_num_head.id);
end loop;
--close pch_num_head;
end;
 end if; 
end;


procedure num_zones_BRIEF  (
 aCURSESSION CHAR,
 anum_zonesid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if anum_zonesid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from num_zones where num_zonesID=anum_zonesID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from num_zones where num_zonesid=anum_zonesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=num_zones');
    return;
  end if;
  aBRIEF:=func.num_zones_BRIEF_F(anum_zonesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure num_zones_DELETE /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 anum_zonesid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from num_zones where num_zonesID=anum_zonesID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from num_zones where num_zonesid=anum_zonesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:num_zones',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=num_zones');
      return;
    end if;
  end if;
 --  verify lock  --
 num_zones_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anum_zonesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=num_zones');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_num_values is select num_values.num_valuesid ID from num_values where  num_values.ParentStructRowID = anum_zonesid;
    child_num_values_rec  child_num_values%ROWTYPE;
    begin
    --open child_num_values;
      for child_num_values_rec in child_num_values loop
      num_values_DELETE (acursession,child_num_values_rec.id,aInstanceid);
      end loop;
      --close child_num_values;
    end ;
declare cursor chld_num_zones is select  instanceid ID from instance where OwnerPartName ='num_zones' and OwnerRowID=anum_zonesid;
row_num_zones  chld_num_zones%ROWTYPE;
begin
--open chld_num_zones;
for row_num_zones in chld_num_zones loop
 Kernel.INSTANCE_OWNER (acursession,row_num_zones.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_num_zones.id);
end loop;
--close chld_num_zones;
end ;
  delete from  num_zones 
  where  num_zonesID = anum_zonesID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Зоны*/
procedure num_zones_SAVE /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 anum_zonesid CHAR,
aInstanceID CHAR 
,azonemask
 VARCHAR2/* Маска зоны *//* Маска зоны */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from num_zones where num_zonesID=anum_zonesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from num_zones where num_zonesid=anum_zonesID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:num_zones',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=num_zones');
      return;
    end if;
  end if;
 --  verify lock  --
 num_zones_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anum_zonesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=num_zones');
    return;
  end if;
 -- update row  --
 update  num_zones set ChangeStamp=sysdate
,
  zonemask=azonemask
  where  num_zonesID = anum_zonesID; 
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from num_zones where InstanceID=aInstanceID 
 and zonemask=azonemask;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=num_zones');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:num_zones',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=num_zones');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=num_zones');
    return;
  end if;
 insert into   num_zones
 (  num_zonesID 
,InstanceID
,zonemask

 ) values ( anum_zonesID 
,aInstanceID
,azonemask

 ); 
 num_zones_SINIT( aCURSESSION,anum_zonesid,atmpid);
 -- checking unique constraints  --

 select Count(*) into aUniqueRowCount from num_zones where InstanceID=aInstanceID 
 and zonemask=azonemask;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=num_zones');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure num_zones_PARENT /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from num_zones where  num_zonesid=aRowID;
 end; 

procedure num_zones_ISLOCKED /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from num_zones where num_zonesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  num_zones_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin stdnumerator.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure num_zones_LOCK /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 num_zones_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  num_zones_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from num_zones where num_zonesid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=num_zones');
    return;
  end if;
   if  aLockMode =2  
   then   
    update num_zones set LockUserID =auserID ,LockSessionID =null where num_zonesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update num_zones set LockUserID =null,LockSessionID =aCURSESSION  where num_zonesid=aRowID;
     return;
   end if;
 end ;

procedure num_zones_HCL /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_num_values is select num_values.num_valuesid ID from num_values where  num_values.ParentStructRowID = aRowid;
row_num_values lch_num_values%ROWTYPE;
begin  
--open lch_num_values;
for row_num_values in lch_num_values
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from num_values where num_valuesid=row_num_values.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_num_values;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_num_values;
     return;
   end if; 
 end if;  
 num_values_HCL (acursession,row_num_values.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_num_values;
   return;
 end if;
end loop;
--close lch_num_values;
end;
aIsLocked :=0;
end;

procedure num_zones_UNLOCK /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 num_zones_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update num_zones set LockUserID =null  where num_zonesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update num_zones set LockSessionID =null  where num_zonesid=aRowID;
     return;
   end if;
 end; 

procedure num_zones_SINIT /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from num_zones where num_zonesid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =num_zones');
    return;
  end if;
if aSecurityStyleID is null then
 num_zones_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update num_zones set securitystyleid =aStyleID where num_zonesid = aRowID;
else 
 update num_zones set securitystyleid =aSecurityStyleID where num_zonesid = aRowID;
end if; 
end ; 

procedure num_zones_propagate /*Зоны уникальных нумеров*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from num_zones where num_zonesid=aRowid;
declare cursor pch_num_values  is select num_values.num_valuesid ID from num_values where  num_values.ParentStructRowID = aRowid;
row_num_values  pch_num_values%ROWTYPE;
begin
--open pch_num_values;
for row_num_values in pch_num_values loop
   num_values_SINIT( acursession,row_num_values.id,assid);
   num_values_propagate( acursession,row_num_values.id);
end loop;
--close pch_num_values;
end;
end;


procedure num_values_BRIEF  (
 aCURSESSION CHAR,
 anum_valuesid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if anum_valuesid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from num_values where num_valuesID=anum_valuesID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from num_values where num_valuesid=anum_valuesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=num_values');
    return;
  end if;
  aBRIEF:=func.num_values_BRIEF_F(anum_valuesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure num_values_DELETE /*уникальные номера*/ (
 aCURSESSION CHAR,
 anum_valuesid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from num_values where num_valuesID=anum_valuesID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from num_values where num_valuesid=anum_valuesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:num_values',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=num_values');
      return;
    end if;
  end if;
 --  verify lock  --
 num_values_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anum_valuesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=num_values');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_num_values is select  instanceid ID from instance where OwnerPartName ='num_values' and OwnerRowID=anum_valuesid;
row_num_values  chld_num_values%ROWTYPE;
begin
--open chld_num_values;
for row_num_values in chld_num_values loop
 Kernel.INSTANCE_OWNER (acursession,row_num_values.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_num_values.id);
end loop;
--close chld_num_values;
end ;
  delete from  num_values 
  where  num_valuesID = anum_valuesID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Номера*/
procedure num_values_SAVE /*уникальные номера*/ (
 aCURSESSION CHAR,
 anum_valuesid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,athe_value
 NUMBER/* Значение *//* Значение */
,aownerpartname
 VARCHAR2 := null /* Раздел *//* Раздел */
,aownerrowid CHAR := null /* Идентификатор строки *//* Идентификатор строки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from num_values where num_valuesID=anum_valuesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from num_values where num_valuesid=anum_valuesID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:num_values',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=num_values');
      return;
    end if;
  end if;
 --  verify lock  --
 num_values_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anum_valuesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=num_values');
    return;
  end if;
 -- update row  --
 update  num_values set ChangeStamp=sysdate
,
  the_value=athe_value
,
  ownerpartname=aownerpartname
,
  ownerrowid=aownerrowid
  where  num_valuesID = anum_valuesID; 
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from num_values where ParentStructRowID=aParentStructRowID 
 and the_value=athe_value;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=num_values');
 return;
end if;

 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from num_zones where num_zonesid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:num_values',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=num_values');
      return;
    end if;
 end if;
 num_zones_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=num_values');
    return;
  end if;
 insert into   num_values
 (  num_valuesID 
,ParentStructRowID
,the_value

,ownerpartname

,ownerrowid

 ) values ( anum_valuesID 
,aParentStructRowID
,athe_value

,aownerpartname

,aownerrowid

 ); 
 num_values_SINIT( aCURSESSION,anum_valuesid,atmpid);
 -- checking unique constraints  --

select Count(*) into aUniqueRowCount from num_values where ParentStructRowID=aParentStructRowID 
 and the_value=athe_value;
if aUniqueRowCount&gt;=2
then
 raise_application_error(-20000,'Нарущение уникальности сочетания полей. Раздел=num_values');
 return;
end if;

 end if;
 -- close transaction --
 end; 

procedure num_values_PARENT /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from num_values where  num_valuesid=aRowID;
  aParentTable := 'num_zones';
 end; 

procedure num_values_ISLOCKED /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from num_values where num_valuesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  num_values_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin stdnumerator.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure num_values_LOCK /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 num_values_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  num_values_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from num_values where num_valuesid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=num_values');
    return;
  end if;
   if  aLockMode =2  
   then   
    update num_values set LockUserID =auserID ,LockSessionID =null where num_valuesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update num_values set LockUserID =null,LockSessionID =aCURSESSION  where num_valuesid=aRowID;
     return;
   end if;
 end ;

procedure num_values_HCL /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure num_values_UNLOCK /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 num_values_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update num_values set LockUserID =null  where num_valuesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update num_values set LockSessionID =null  where num_valuesid=aRowID;
     return;
   end if;
 end; 

procedure num_values_SINIT /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from num_values where num_valuesid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =num_values');
    return;
  end if;
if aSecurityStyleID is null then
 num_values_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update num_values set securitystyleid =aStyleID where num_valuesid = aRowID;
else 
 update num_values set securitystyleid =aSecurityStyleID where num_valuesid = aRowID;
end if; 
end ; 

procedure num_values_propagate /*уникальные номера*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from num_values where num_valuesid=aRowid;
end;


procedure num_head_BRIEF  (
 aCURSESSION CHAR,
 anum_headid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if anum_headid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from num_head where num_headID=anum_headID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from num_head where num_headid=anum_headID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=num_head');
    return;
  end if;
  aBRIEF:=func.num_head_BRIEF_F(anum_headid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure num_head_DELETE /*Описание нумератора*/ (
 aCURSESSION CHAR,
 anum_headid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from num_head where num_headID=anum_headID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from num_head where num_headid=anum_headID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:num_head',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=num_head');
      return;
    end if;
  end if;
 --  verify lock  --
 num_head_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anum_headid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=num_head');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_num_head is select  instanceid ID from instance where OwnerPartName ='num_head' and OwnerRowID=anum_headid;
row_num_head  chld_num_head%ROWTYPE;
begin
--open chld_num_head;
for row_num_head in chld_num_head loop
 Kernel.INSTANCE_OWNER (acursession,row_num_head.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_num_head.id);
end loop;
--close chld_num_head;
end ;
  delete from  num_head 
  where  num_headID = anum_headID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure num_head_SAVE /*Описание нумератора*/ (
 aCURSESSION CHAR,
 anum_headid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,ashema
 NUMBER/* Схема нумерации *//* Схема нумерации */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from num_head where num_headID=anum_headID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from num_head where num_headid=anum_headID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:num_head',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=num_head');
      return;
    end if;
  end if;
 --  verify lock  --
 num_head_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;anum_headid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=num_head');
    return;
  end if;
 -- update row  --
 update  num_head set ChangeStamp=sysdate
,
  name=aname
,
  shema=ashema
  where  num_headID = anum_headID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:num_head',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=num_head');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=num_head');
    return;
  end if;
select Count(*) into existsCnt from num_head where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;num_head&gt;');
    return;
 End if;
 insert into   num_head
 (  num_headID 
,InstanceID
,name

,shema

 ) values ( anum_headID 
,aInstanceID
,aname

,ashema

 ); 
 num_head_SINIT( aCURSESSION,anum_headid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure num_head_PARENT /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from num_head where  num_headid=aRowID;
 end; 

procedure num_head_ISLOCKED /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from num_head where num_headid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  num_head_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin stdnumerator.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure num_head_LOCK /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 num_head_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  num_head_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from num_head where num_headid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=num_head');
    return;
  end if;
   if  aLockMode =2  
   then   
    update num_head set LockUserID =auserID ,LockSessionID =null where num_headid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update num_head set LockUserID =null,LockSessionID =aCURSESSION  where num_headid=aRowID;
     return;
   end if;
 end ;

procedure num_head_HCL /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure num_head_UNLOCK /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 num_head_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update num_head set LockUserID =null  where num_headid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update num_head set LockSessionID =null  where num_headid=aRowID;
     return;
   end if;
 end; 

procedure num_head_SINIT /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from num_head where num_headid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =num_head');
    return;
  end if;
if aSecurityStyleID is null then
 num_head_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update num_head set securitystyleid =aStyleID where num_headid = aRowID;
else 
 update num_head set securitystyleid =aSecurityStyleID where num_headid = aRowID;
end if; 
end ; 

procedure num_head_propagate /*Описание нумератора*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from num_head where num_headid=aRowid;
end;
end stdnumerator;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tor" BlockCode=" create or replace package body tor as

procedure tor_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='tor'
then
declare cursor child_tor_info is select tor_info.tor_infoid ID from tor_info where  tor_info.InstanceID = ainstanceid;
row_tor_info  child_tor_info%ROWTYPE;
begin
--open child_tor_info;
for row_tor_info in child_tor_info loop
 tor_info_DELETE (acursession,row_tor_info.id,aInstanceID);
end loop;
--close child_tor_info;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure tor_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'tor'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_tor_info is select tor_info.tor_infoid ID from tor_info where  tor_info.InstanceID = arowid;
ROW_tor_info  lch_tor_info%ROWTYPE;
begin
--open lch_tor_info;
for row_tor_info in lch_tor_info loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from tor_info where tor_infoid=row_tor_info.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_tor_info;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_tor_info;
     return;
   end if; 
 end if; 
 tor_info_HCL (acursession,ROW_tor_info.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_tor_info;
   return;
 end if;
 end loop;
--close lch_tor_info;
end;
 end if;
aIsLocked:=0;
end;
procedure tor_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'tor'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_tor_info is select tor_info.tor_infoid id from tor_info where  tor_info.InstanceID = arowid;
row_tor_info  pch_tor_info%ROWTYPE;
begin
--open pch_tor_info;
for row_tor_info in  pch_tor_info loop
 tor_info_SINIT( acursession,row_tor_info.id,assid);
 tor_info_propagate( acursession,row_tor_info.id);
end loop;
--close pch_tor_info;
end;
 end if; 
end;


procedure tor_info_BRIEF  (
 aCURSESSION CHAR,
 ator_infoid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ator_infoid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from tor_info where tor_infoID=ator_infoID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from tor_info where tor_infoid=ator_infoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=tor_info');
    return;
  end if;
  aBRIEF:=func.tor_info_BRIEF_F(ator_infoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure tor_info_DELETE /**/ (
 aCURSESSION CHAR,
 ator_infoid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from tor_info where tor_infoID=ator_infoID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from tor_info where tor_infoid=ator_infoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:tor_info',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=tor_info');
      return;
    end if;
  end if;
 --  verify lock  --
 tor_info_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ator_infoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=tor_info');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tor_info',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ator_infoid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_tor_info is select  instanceid ID from instance where OwnerPartName ='tor_info' and OwnerRowID=ator_infoid;
row_tor_info  chld_tor_info%ROWTYPE;
begin
--open chld_tor_info;
for row_tor_info in chld_tor_info loop
 Kernel.INSTANCE_OWNER (acursession,row_tor_info.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_tor_info.id);
end loop;
--close chld_tor_info;
end ;
  delete from  tor_info 
  where  tor_infoID = ator_infoID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Записи о рабочих станциях*/
procedure tor_info_SAVE /**/ (
 aCURSESSION CHAR,
 ator_infoid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название станции *//* Название станции */
,aserverdata
 DATE := null /* Дата сервер *//* Дата сервер */
,aclientdata
 DATE := null /* Дата клиент *//* Дата клиент */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from tor_info where tor_infoID=ator_infoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from tor_info where tor_infoid=ator_infoID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:tor_info',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=tor_info');
      return;
    end if;
  end if;
 --  verify lock  --
 tor_info_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ator_infoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tor_info');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tor_info',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ator_infoid,aLogInstanceID=&gt;aInstanceID);
 update  tor_info set ChangeStamp=sysdate
,
  name=aname
,
  serverdata=aserverdata
,
  clientdata=aclientdata
  where  tor_infoID = ator_infoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:tor_info',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=tor_info');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=tor_info');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'tor_info',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ator_infoid,aLogInstanceID=&gt;aInstanceID);
 insert into   tor_info
 (  tor_infoID 
,InstanceID
,name

,serverdata

,clientdata

 ) values ( ator_infoID 
,aInstanceID
,aname

,aserverdata

,aclientdata

 ); 
 tor_info_SINIT( aCURSESSION,ator_infoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure tor_info_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from tor_info where  tor_infoid=aRowID;
 end; 

procedure tor_info_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from tor_info where tor_infoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  tor_info_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tor.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure tor_info_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 tor_info_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  tor_info_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from tor_info where tor_infoid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=tor_info');
    return;
  end if;
   if  aLockMode =2  
   then   
    update tor_info set LockUserID =auserID ,LockSessionID =null where tor_infoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update tor_info set LockUserID =null,LockSessionID =aCURSESSION  where tor_infoid=aRowID;
     return;
   end if;
 end ;

procedure tor_info_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure tor_info_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 tor_info_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update tor_info set LockUserID =null  where tor_infoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update tor_info set LockSessionID =null  where tor_infoid=aRowID;
     return;
   end if;
 end; 

procedure tor_info_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from tor_info where tor_infoid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =tor_info');
    return;
  end if;
if aSecurityStyleID is null then
 tor_info_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update tor_info set securitystyleid =aStyleID where tor_infoid = aRowID;
else 
 update tor_info set securitystyleid =aSecurityStyleID where tor_infoid = aRowID;
end if; 
end ; 

procedure tor_info_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from tor_info where tor_infoid=aRowid;
end;
end tor;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzext" BlockCode=" create or replace package body mtzext as

procedure mtzext_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzext'
then
declare cursor child_mtzext_def is select mtzext_def.mtzext_defid ID from mtzext_def where  mtzext_def.InstanceID = ainstanceid;
row_mtzext_def  child_mtzext_def%ROWTYPE;
begin
--open child_mtzext_def;
for row_mtzext_def in child_mtzext_def loop
 mtzext_def_DELETE (acursession,row_mtzext_def.id,aInstanceID);
end loop;
--close child_mtzext_def;
end;
declare cursor child_mtzextrel is select mtzextrel.mtzextrelid ID from mtzextrel where  mtzextrel.InstanceID = ainstanceid;
row_mtzextrel  child_mtzextrel%ROWTYPE;
begin
--open child_mtzextrel;
for row_mtzextrel in child_mtzextrel loop
 mtzextrel_DELETE (acursession,row_mtzextrel.id,aInstanceID);
end loop;
--close child_mtzextrel;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzext_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzext'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_mtzext_def is select mtzext_def.mtzext_defid ID from mtzext_def where  mtzext_def.InstanceID = arowid;
ROW_mtzext_def  lch_mtzext_def%ROWTYPE;
begin
--open lch_mtzext_def;
for row_mtzext_def in lch_mtzext_def loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from mtzext_def where mtzext_defid=row_mtzext_def.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_mtzext_def;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_mtzext_def;
     return;
   end if; 
 end if; 
 mtzext_def_HCL (acursession,ROW_mtzext_def.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_mtzext_def;
   return;
 end if;
 end loop;
--close lch_mtzext_def;
end;
declare cursor lch_mtzextrel is select mtzextrel.mtzextrelid ID from mtzextrel where  mtzextrel.InstanceID = arowid;
ROW_mtzextrel  lch_mtzextrel%ROWTYPE;
begin
--open lch_mtzextrel;
for row_mtzextrel in lch_mtzextrel loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from mtzextrel where mtzextrelid=row_mtzextrel.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_mtzextrel;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_mtzextrel;
     return;
   end if; 
 end if; 
 mtzextrel_HCL (acursession,ROW_mtzextrel.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_mtzextrel;
   return;
 end if;
 end loop;
--close lch_mtzextrel;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzext_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzext'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_mtzext_def is select mtzext_def.mtzext_defid id from mtzext_def where  mtzext_def.InstanceID = arowid;
row_mtzext_def  pch_mtzext_def%ROWTYPE;
begin
--open pch_mtzext_def;
for row_mtzext_def in  pch_mtzext_def loop
 mtzext_def_SINIT( acursession,row_mtzext_def.id,assid);
 mtzext_def_propagate( acursession,row_mtzext_def.id);
end loop;
--close pch_mtzext_def;
end;
declare cursor pch_mtzextrel is select mtzextrel.mtzextrelid id from mtzextrel where  mtzextrel.InstanceID = arowid;
row_mtzextrel  pch_mtzextrel%ROWTYPE;
begin
--open pch_mtzextrel;
for row_mtzextrel in  pch_mtzextrel loop
 mtzextrel_SINIT( acursession,row_mtzextrel.id,assid);
 mtzextrel_propagate( acursession,row_mtzextrel.id);
end loop;
--close pch_mtzextrel;
end;
 end if; 
end;


procedure mtzext_def_BRIEF  (
 aCURSESSION CHAR,
 amtzext_defid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if amtzext_defid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from mtzext_def where mtzext_defID=amtzext_defID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from mtzext_def where mtzext_defid=amtzext_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=mtzext_def');
    return;
  end if;
  aBRIEF:=func.mtzext_def_BRIEF_F(amtzext_defid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure mtzext_def_DELETE /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 amtzext_defid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from mtzext_def where mtzext_defID=amtzext_defID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from mtzext_def where mtzext_defid=amtzext_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:mtzext_def',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=mtzext_def');
      return;
    end if;
  end if;
 --  verify lock  --
 mtzext_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtzext_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=mtzext_def');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_mtzext_def is select  instanceid ID from instance where OwnerPartName ='mtzext_def' and OwnerRowID=amtzext_defid;
row_mtzext_def  chld_mtzext_def%ROWTYPE;
begin
--open chld_mtzext_def;
for row_mtzext_def in chld_mtzext_def loop
 Kernel.INSTANCE_OWNER (acursession,row_mtzext_def.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_mtzext_def.id);
end loop;
--close chld_mtzext_def;
end ;
  delete from  mtzext_def 
  where  mtzext_defID = amtzext_defID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure mtzext_def_SAVE /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 amtzext_defid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,aexttype
 NUMBER/* Тип расширения *//* Тип расширения */
,athedescription VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from mtzext_def where mtzext_defID=amtzext_defID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from mtzext_def where mtzext_defid=amtzext_defID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:mtzext_def',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=mtzext_def');
      return;
    end if;
  end if;
 --  verify lock  --
 mtzext_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtzext_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtzext_def');
    return;
  end if;
 -- update row  --
 update  mtzext_def set ChangeStamp=sysdate
,
  name=aname
,
  exttype=aexttype
,
  thedescription=athedescription
  where  mtzext_defID = amtzext_defID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:mtzext_def',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=mtzext_def');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtzext_def');
    return;
  end if;
select Count(*) into existsCnt from mtzext_def where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;mtzext_def&gt;');
    return;
 End if;
 insert into   mtzext_def
 (  mtzext_defID 
,InstanceID
,name

,exttype

,thedescription

 ) values ( amtzext_defID 
,aInstanceID
,aname

,aexttype

,athedescription

 ); 
 mtzext_def_SINIT( aCURSESSION,amtzext_defid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure mtzext_def_PARENT /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from mtzext_def where  mtzext_defid=aRowID;
 end; 

procedure mtzext_def_ISLOCKED /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from mtzext_def where mtzext_defid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  mtzext_def_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzext.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure mtzext_def_LOCK /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 mtzext_def_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  mtzext_def_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from mtzext_def where mtzext_defid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=mtzext_def');
    return;
  end if;
   if  aLockMode =2  
   then   
    update mtzext_def set LockUserID =auserID ,LockSessionID =null where mtzext_defid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update mtzext_def set LockUserID =null,LockSessionID =aCURSESSION  where mtzext_defid=aRowID;
     return;
   end if;
 end ;

procedure mtzext_def_HCL /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure mtzext_def_UNLOCK /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 mtzext_def_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update mtzext_def set LockUserID =null  where mtzext_defid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update mtzext_def set LockSessionID =null  where mtzext_defid=aRowID;
     return;
   end if;
 end; 

procedure mtzext_def_SINIT /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from mtzext_def where mtzext_defid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =mtzext_def');
    return;
  end if;
if aSecurityStyleID is null then
 mtzext_def_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update mtzext_def set securitystyleid =aStyleID where mtzext_defid = aRowID;
else 
 update mtzext_def set securitystyleid =aSecurityStyleID where mtzext_defid = aRowID;
end if; 
end ; 

procedure mtzext_def_propagate /*Список зарегистрированных расширений*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from mtzext_def where mtzext_defid=aRowid;
end;


procedure mtzextrel_BRIEF  (
 aCURSESSION CHAR,
 amtzextrelid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if amtzextrelid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from mtzextrel where mtzextrelID=amtzextrelID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from mtzextrel where mtzextrelid=amtzextrelID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=mtzextrel');
    return;
  end if;
  aBRIEF:=func.mtzextrel_BRIEF_F(amtzextrelid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure mtzextrel_DELETE /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 amtzextrelid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from mtzextrel where mtzextrelID=amtzextrelID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from mtzextrel where mtzextrelid=amtzextrelID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:mtzextrel',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=mtzextrel');
      return;
    end if;
  end if;
 --  verify lock  --
 mtzextrel_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtzextrelid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=mtzextrel');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_mtzextrel is select  instanceid ID from instance where OwnerPartName ='mtzextrel' and OwnerRowID=amtzextrelid;
row_mtzextrel  chld_mtzextrel%ROWTYPE;
begin
--open chld_mtzextrel;
for row_mtzextrel in chld_mtzextrel loop
 Kernel.INSTANCE_OWNER (acursession,row_mtzextrel.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_mtzextrel.id);
end loop;
--close chld_mtzextrel;
end ;
  delete from  mtzextrel 
  where  mtzextrelID = amtzextrelID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Реализации расширения*/
procedure mtzextrel_SAVE /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 amtzextrelid CHAR,
aInstanceID CHAR 
,atheplatform
 NUMBER/* Реализация *//* Реализация */
,atheclassname
 VARCHAR2/* Название класса *//* Название класса */
,athelibraryname
 VARCHAR2 := null /* Название библиотеки *//* Название библиотеки */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from mtzextrel where mtzextrelID=amtzextrelID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from mtzextrel where mtzextrelid=amtzextrelID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:mtzextrel',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=mtzextrel');
      return;
    end if;
  end if;
 --  verify lock  --
 mtzextrel_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtzextrelid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtzextrel');
    return;
  end if;
 -- update row  --
 update  mtzextrel set ChangeStamp=sysdate
,
  theplatform=atheplatform
,
  theclassname=atheclassname
,
  thelibraryname=athelibraryname
  where  mtzextrelID = amtzextrelID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:mtzextrel',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=mtzextrel');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtzextrel');
    return;
  end if;
 insert into   mtzextrel
 (  mtzextrelID 
,InstanceID
,theplatform

,theclassname

,thelibraryname

 ) values ( amtzextrelID 
,aInstanceID
,atheplatform

,atheclassname

,athelibraryname

 ); 
 mtzextrel_SINIT( aCURSESSION,amtzextrelid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure mtzextrel_PARENT /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from mtzextrel where  mtzextrelid=aRowID;
 end; 

procedure mtzextrel_ISLOCKED /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from mtzextrel where mtzextrelid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  mtzextrel_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzext.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure mtzextrel_LOCK /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 mtzextrel_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  mtzextrel_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from mtzextrel where mtzextrelid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=mtzextrel');
    return;
  end if;
   if  aLockMode =2  
   then   
    update mtzextrel set LockUserID =auserID ,LockSessionID =null where mtzextrelid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update mtzextrel set LockUserID =null,LockSessionID =aCURSESSION  where mtzextrelid=aRowID;
     return;
   end if;
 end ;

procedure mtzextrel_HCL /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure mtzextrel_UNLOCK /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 mtzextrel_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update mtzextrel set LockUserID =null  where mtzextrelid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update mtzextrel set LockSessionID =null  where mtzextrelid=aRowID;
     return;
   end if;
 end; 

procedure mtzextrel_SINIT /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from mtzextrel where mtzextrelid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =mtzextrel');
    return;
  end if;
if aSecurityStyleID is null then
 mtzextrel_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update mtzextrel set securitystyleid =aStyleID where mtzextrelid = aRowID;
else 
 update mtzextrel set securitystyleid =aSecurityStyleID where mtzextrelid = aRowID;
end if; 
end ; 

procedure mtzextrel_propagate /*Реализации расширения для разных разработческих плаформ*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from mtzextrel where mtzextrelid=aRowid;
end;
end mtzext;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--tocard" BlockCode=" create or replace package body tocard as

procedure tocard_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='tocard'
then
declare cursor child_to_cardinfo is select to_cardinfo.to_cardinfoid ID from to_cardinfo where  to_cardinfo.InstanceID = ainstanceid;
row_to_cardinfo  child_to_cardinfo%ROWTYPE;
begin
--open child_to_cardinfo;
for row_to_cardinfo in child_to_cardinfo loop
 to_cardinfo_DELETE (acursession,row_to_cardinfo.id,aInstanceID);
end loop;
--close child_to_cardinfo;
end;
declare cursor child_to_cardchecks is select to_cardchecks.to_cardchecksid ID from to_cardchecks where  to_cardchecks.InstanceID = ainstanceid;
row_to_cardchecks  child_to_cardchecks%ROWTYPE;
begin
--open child_to_cardchecks;
for row_to_cardchecks in child_to_cardchecks loop
 to_cardchecks_DELETE (acursession,row_to_cardchecks.id,aInstanceID);
end loop;
--close child_to_cardchecks;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure tocard_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'tocard'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_to_cardinfo is select to_cardinfo.to_cardinfoid ID from to_cardinfo where  to_cardinfo.InstanceID = arowid;
ROW_to_cardinfo  lch_to_cardinfo%ROWTYPE;
begin
--open lch_to_cardinfo;
for row_to_cardinfo in lch_to_cardinfo loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_cardinfo where to_cardinfoid=row_to_cardinfo.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_cardinfo;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_cardinfo;
     return;
   end if; 
 end if; 
 to_cardinfo_HCL (acursession,ROW_to_cardinfo.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_cardinfo;
   return;
 end if;
 end loop;
--close lch_to_cardinfo;
end;
declare cursor lch_to_cardchecks is select to_cardchecks.to_cardchecksid ID from to_cardchecks where  to_cardchecks.InstanceID = arowid;
ROW_to_cardchecks  lch_to_cardchecks%ROWTYPE;
begin
--open lch_to_cardchecks;
for row_to_cardchecks in lch_to_cardchecks loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from to_cardchecks where to_cardchecksid=row_to_cardchecks.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_cardchecks;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_to_cardchecks;
     return;
   end if; 
 end if; 
 to_cardchecks_HCL (acursession,ROW_to_cardchecks.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_cardchecks;
   return;
 end if;
 end loop;
--close lch_to_cardchecks;
end;
 end if;
aIsLocked:=0;
end;
procedure tocard_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'tocard'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_to_cardinfo is select to_cardinfo.to_cardinfoid id from to_cardinfo where  to_cardinfo.InstanceID = arowid;
row_to_cardinfo  pch_to_cardinfo%ROWTYPE;
begin
--open pch_to_cardinfo;
for row_to_cardinfo in  pch_to_cardinfo loop
 to_cardinfo_SINIT( acursession,row_to_cardinfo.id,assid);
 to_cardinfo_propagate( acursession,row_to_cardinfo.id);
end loop;
--close pch_to_cardinfo;
end;
declare cursor pch_to_cardchecks is select to_cardchecks.to_cardchecksid id from to_cardchecks where  to_cardchecks.InstanceID = arowid;
row_to_cardchecks  pch_to_cardchecks%ROWTYPE;
begin
--open pch_to_cardchecks;
for row_to_cardchecks in  pch_to_cardchecks loop
 to_cardchecks_SINIT( acursession,row_to_cardchecks.id,assid);
 to_cardchecks_propagate( acursession,row_to_cardchecks.id);
end loop;
--close pch_to_cardchecks;
end;
 end if; 
end;


procedure to_cardinfo_BRIEF  (
 aCURSESSION CHAR,
 ato_cardinfoid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_cardinfoid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_cardinfo where to_cardinfoID=ato_cardinfoID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_cardinfo where to_cardinfoid=ato_cardinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_cardinfo');
    return;
  end if;
  aBRIEF:=func.to_cardinfo_BRIEF_F(ato_cardinfoid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_cardinfo_DELETE /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 ato_cardinfoid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_cardinfo where to_cardinfoID=ato_cardinfoID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_cardinfo where to_cardinfoid=ato_cardinfoID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_cardinfo',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_cardinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 to_cardinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_cardinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_cardinfo');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_cardinfo',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_cardinfoid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_cardinfo is select  instanceid ID from instance where OwnerPartName ='to_cardinfo' and OwnerRowID=ato_cardinfoid;
row_to_cardinfo  chld_to_cardinfo%ROWTYPE;
begin
--open chld_to_cardinfo;
for row_to_cardinfo in chld_to_cardinfo loop
 Kernel.INSTANCE_OWNER (acursession,row_to_cardinfo.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_cardinfo.id);
end loop;
--close chld_to_cardinfo;
end ;
  delete from  to_cardinfo 
  where  to_cardinfoID = ato_cardinfoID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure to_cardinfo_SAVE /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 ato_cardinfoid CHAR,
aInstanceID CHAR 
,athe_machine CHAR/* Станок *//* Станок */
,acard_date
 DATE := null /* Дата составления карты *//* Дата составления карты */
,acard_archived
 NUMBER := null /* Архивная карта *//* Архивная карта */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_cardinfo where to_cardinfoID=ato_cardinfoID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_cardinfo where to_cardinfoid=ato_cardinfoID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_cardinfo',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_cardinfo');
      return;
    end if;
  end if;
 --  verify lock  --
 to_cardinfo_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_cardinfoid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_cardinfo');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_cardinfo',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_cardinfoid,aLogInstanceID=&gt;aInstanceID);
 update  to_cardinfo set ChangeStamp=sysdate
,
  the_machine=athe_machine
,
  card_date=acard_date
,
  card_archived=acard_archived
  where  to_cardinfoID = ato_cardinfoID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_cardinfo',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_cardinfo');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_cardinfo');
    return;
  end if;
select Count(*) into existsCnt from to_cardinfo where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;to_cardinfo&gt;');
    return;
 End if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_cardinfo',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_cardinfoid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_cardinfo
 (  to_cardinfoID 
,InstanceID
,the_machine

,card_date

,card_archived

 ) values ( ato_cardinfoID 
,aInstanceID
,athe_machine

,acard_date

,acard_archived

 ); 
 to_cardinfo_SINIT( aCURSESSION,ato_cardinfoid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_cardinfo_PARENT /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_cardinfo where  to_cardinfoid=aRowID;
 end; 

procedure to_cardinfo_ISLOCKED /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_cardinfo where to_cardinfoid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_cardinfo_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tocard.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_cardinfo_LOCK /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_cardinfo_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_cardinfo_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_cardinfo where to_cardinfoid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_cardinfo');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_cardinfo set LockUserID =auserID ,LockSessionID =null where to_cardinfoid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_cardinfo set LockUserID =null,LockSessionID =aCURSESSION  where to_cardinfoid=aRowID;
     return;
   end if;
 end ;

procedure to_cardinfo_HCL /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_cardinfo_UNLOCK /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_cardinfo_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_cardinfo set LockUserID =null  where to_cardinfoid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_cardinfo set LockSessionID =null  where to_cardinfoid=aRowID;
     return;
   end if;
 end; 

procedure to_cardinfo_SINIT /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_cardinfo where to_cardinfoid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_cardinfo');
    return;
  end if;
if aSecurityStyleID is null then
 to_cardinfo_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_cardinfo set securitystyleid =aStyleID where to_cardinfoid = aRowID;
else 
 update to_cardinfo set securitystyleid =aSecurityStyleID where to_cardinfoid = aRowID;
end if; 
end ; 

procedure to_cardinfo_propagate /*Описание диагностической карты*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_cardinfo where to_cardinfoid=aRowid;
end;


procedure to_cardchecks_BRIEF  (
 aCURSESSION CHAR,
 ato_cardchecksid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_cardchecksid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_cardchecks where to_cardchecksID=ato_cardchecksID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_cardchecks where to_cardchecksid=ato_cardchecksID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_cardchecks');
    return;
  end if;
  aBRIEF:=func.to_cardchecks_BRIEF_F(ato_cardchecksid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_cardchecks_DELETE /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 ato_cardchecksid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_cardchecks where to_cardchecksID=ato_cardchecksID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_cardchecks where to_cardchecksid=ato_cardchecksID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_cardchecks',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_cardchecks');
      return;
    end if;
  end if;
 --  verify lock  --
 to_cardchecks_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_cardchecksid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_cardchecks');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_to_carddevices is select to_carddevices.to_carddevicesid ID from to_carddevices where  to_carddevices.ParentStructRowID = ato_cardchecksid;
    child_to_carddevices_rec  child_to_carddevices%ROWTYPE;
    begin
    --open child_to_carddevices;
      for child_to_carddevices_rec in child_to_carddevices loop
      to_carddevices_DELETE (acursession,child_to_carddevices_rec.id,aInstanceid);
      end loop;
      --close child_to_carddevices;
    end ;
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_cardchecks',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_cardchecksid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_cardchecks is select  instanceid ID from instance where OwnerPartName ='to_cardchecks' and OwnerRowID=ato_cardchecksid;
row_to_cardchecks  chld_to_cardchecks%ROWTYPE;
begin
--open chld_to_cardchecks;
for row_to_cardchecks in chld_to_cardchecks loop
 Kernel.INSTANCE_OWNER (acursession,row_to_cardchecks.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_cardchecks.id);
end loop;
--close chld_to_cardchecks;
end ;
  delete from  to_cardchecks 
  where  to_cardchecksID = ato_cardchecksID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Проверки*/
procedure to_cardchecks_SAVE /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 ato_cardchecksid CHAR,
aInstanceID CHAR 
,athe_system CHAR/* Группа узлов *//* Группа узлов */
,athesubsystem
 VARCHAR2 := null /* Узел *//* Узел */
,athe_check
 VARCHAR2/* Показатель *//* Показатель */
,anormochas
 NUMBER/* Нормочас *//* Нормочас */
,avaluetype CHAR/* Измерение *//* Измерение */
,alowvalue
 VARCHAR2 := null /* Нижняя граница (&gt;=) *//* Нижняя граница (&gt;=) */
,ahivalue
 VARCHAR2 := null /* Верхняя граница (&lt;=) *//* Верхняя граница (&lt;=) */
,athe_comment VARCHAR2 := null /* Примечание *//* Примечание */
,atagid
 VARCHAR2 := null /* Метка *//* Метка */
,athe_doc VARCHAR2 := null /* Документация *//* Документация */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_cardchecks where to_cardchecksID=ato_cardchecksID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_cardchecks where to_cardchecksid=ato_cardchecksID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_cardchecks',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_cardchecks');
      return;
    end if;
  end if;
 --  verify lock  --
 to_cardchecks_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_cardchecksid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_cardchecks');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_cardchecks',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_cardchecksid,aLogInstanceID=&gt;aInstanceID);
 update  to_cardchecks set ChangeStamp=sysdate
,
  the_system=athe_system
,
  thesubsystem=athesubsystem
,
  the_check=athe_check
,
  normochas=anormochas
,
  valuetype=avaluetype
,
  lowvalue=alowvalue
,
  hivalue=ahivalue
,
  the_comment=athe_comment
,
  tagid=atagid
,
  the_doc=athe_doc
  where  to_cardchecksID = ato_cardchecksID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_cardchecks',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_cardchecks');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_cardchecks');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_cardchecks',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_cardchecksid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_cardchecks
 (  to_cardchecksID 
,InstanceID
,the_system

,thesubsystem

,the_check

,normochas

,valuetype

,lowvalue

,hivalue

,the_comment

,tagid

,the_doc

 ) values ( ato_cardchecksID 
,aInstanceID
,athe_system

,athesubsystem

,athe_check

,anormochas

,avaluetype

,alowvalue

,ahivalue

,athe_comment

,atagid

,athe_doc

 ); 
 to_cardchecks_SINIT( aCURSESSION,ato_cardchecksid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_cardchecks_PARENT /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from to_cardchecks where  to_cardchecksid=aRowID;
 end; 

procedure to_cardchecks_ISLOCKED /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_cardchecks where to_cardchecksid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_cardchecks_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tocard.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_cardchecks_LOCK /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_cardchecks_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_cardchecks_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_cardchecks where to_cardchecksid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_cardchecks');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_cardchecks set LockUserID =auserID ,LockSessionID =null where to_cardchecksid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_cardchecks set LockUserID =null,LockSessionID =aCURSESSION  where to_cardchecksid=aRowID;
     return;
   end if;
 end ;

procedure to_cardchecks_HCL /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_to_carddevices is select to_carddevices.to_carddevicesid ID from to_carddevices where  to_carddevices.ParentStructRowID = aRowid;
row_to_carddevices lch_to_carddevices%ROWTYPE;
begin  
--open lch_to_carddevices;
for row_to_carddevices in lch_to_carddevices
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from to_carddevices where to_carddevicesid=row_to_carddevices.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_to_carddevices;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_to_carddevices;
     return;
   end if; 
 end if;  
 to_carddevices_HCL (acursession,row_to_carddevices.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_to_carddevices;
   return;
 end if;
end loop;
--close lch_to_carddevices;
end;
aIsLocked :=0;
end;

procedure to_cardchecks_UNLOCK /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_cardchecks_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_cardchecks set LockUserID =null  where to_cardchecksid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_cardchecks set LockSessionID =null  where to_cardchecksid=aRowID;
     return;
   end if;
 end; 

procedure to_cardchecks_SINIT /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_cardchecks where to_cardchecksid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_cardchecks');
    return;
  end if;
if aSecurityStyleID is null then
 to_cardchecks_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_cardchecks set securitystyleid =aStyleID where to_cardchecksid = aRowID;
else 
 update to_cardchecks set securitystyleid =aSecurityStyleID where to_cardchecksid = aRowID;
end if; 
end ; 

procedure to_cardchecks_propagate /*Проверяемые параметры*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_cardchecks where to_cardchecksid=aRowid;
declare cursor pch_to_carddevices  is select to_carddevices.to_carddevicesid ID from to_carddevices where  to_carddevices.ParentStructRowID = aRowid;
row_to_carddevices  pch_to_carddevices%ROWTYPE;
begin
--open pch_to_carddevices;
for row_to_carddevices in pch_to_carddevices loop
   to_carddevices_SINIT( acursession,row_to_carddevices.id,assid);
   to_carddevices_propagate( acursession,row_to_carddevices.id);
end loop;
--close pch_to_carddevices;
end;
end;


procedure to_carddevices_BRIEF  (
 aCURSESSION CHAR,
 ato_carddevicesid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if ato_carddevicesid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from to_carddevices where to_carddevicesID=ato_carddevicesID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from to_carddevices where to_carddevicesid=ato_carddevicesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=to_carddevices');
    return;
  end if;
  aBRIEF:=func.to_carddevices_BRIEF_F(ato_carddevicesid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure to_carddevices_DELETE /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 ato_carddevicesid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from to_carddevices where to_carddevicesID=ato_carddevicesID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from to_carddevices where to_carddevicesid=ato_carddevicesID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:to_carddevices',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=to_carddevices');
      return;
    end if;
  end if;
 --  verify lock  --
 to_carddevices_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_carddevicesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=to_carddevices');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_carddevices',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;ato_carddevicesid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_to_carddevices is select  instanceid ID from instance where OwnerPartName ='to_carddevices' and OwnerRowID=ato_carddevicesid;
row_to_carddevices  chld_to_carddevices%ROWTYPE;
begin
--open chld_to_carddevices;
for row_to_carddevices in chld_to_carddevices loop
 Kernel.INSTANCE_OWNER (acursession,row_to_carddevices.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_to_carddevices.id);
end loop;
--close chld_to_carddevices;
end ;
  delete from  to_carddevices 
  where  to_carddevicesID = ato_carddevicesID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Инструменты и материалы*/
procedure to_carddevices_SAVE /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 ato_carddevicesid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,amat CHAR/* Требуется *//* Требуется */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from to_carddevices where to_carddevicesID=ato_carddevicesID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from to_carddevices where to_carddevicesid=ato_carddevicesID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:to_carddevices',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=to_carddevices');
      return;
    end if;
  end if;
 --  verify lock  --
 to_carddevices_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;ato_carddevicesid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_carddevices');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_carddevices',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;ato_carddevicesid,aLogInstanceID=&gt;aInstanceID);
 update  to_carddevices set ChangeStamp=sysdate
,
  mat=amat
  where  to_carddevicesID = ato_carddevicesID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from to_cardchecks where to_cardchecksid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:to_carddevices',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=to_carddevices');
      return;
    end if;
 end if;
 to_cardchecks_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=to_carddevices');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'to_carddevices',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;ato_carddevicesid,aLogInstanceID=&gt;aInstanceID);
 insert into   to_carddevices
 (  to_carddevicesID 
,ParentStructRowID
,mat

 ) values ( ato_carddevicesID 
,aParentStructRowID
,amat

 ); 
 to_carddevices_SINIT( aCURSESSION,ato_carddevicesid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure to_carddevices_PARENT /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from to_carddevices where  to_carddevicesid=aRowID;
  aParentTable := 'to_cardchecks';
 end; 

procedure to_carddevices_ISLOCKED /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from to_carddevices where to_carddevicesid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  to_carddevices_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin tocard.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure to_carddevices_LOCK /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 to_carddevices_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  to_carddevices_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from to_carddevices where to_carddevicesid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=to_carddevices');
    return;
  end if;
   if  aLockMode =2  
   then   
    update to_carddevices set LockUserID =auserID ,LockSessionID =null where to_carddevicesid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update to_carddevices set LockUserID =null,LockSessionID =aCURSESSION  where to_carddevicesid=aRowID;
     return;
   end if;
 end ;

procedure to_carddevices_HCL /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure to_carddevices_UNLOCK /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 to_carddevices_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update to_carddevices set LockUserID =null  where to_carddevicesid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update to_carddevices set LockSessionID =null  where to_carddevicesid=aRowID;
     return;
   end if;
 end; 

procedure to_carddevices_SINIT /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from to_carddevices where to_carddevicesid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =to_carddevices');
    return;
  end if;
if aSecurityStyleID is null then
 to_carddevices_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update to_carddevices set securitystyleid =aStyleID where to_carddevicesid = aRowID;
else 
 update to_carddevices set securitystyleid =aSecurityStyleID where to_carddevicesid = aRowID;
end if; 
end ; 

procedure to_carddevices_propagate /*Инструменты и материалы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from to_carddevices where to_carddevicesid=aRowid;
end;
end tocard;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--toimg" BlockCode=" create or replace package body toimg as

procedure toimg_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='toimg'
then
declare cursor child_toimg_data is select toimg_data.toimg_dataid ID from toimg_data where  toimg_data.InstanceID = ainstanceid;
row_toimg_data  child_toimg_data%ROWTYPE;
begin
--open child_toimg_data;
for row_toimg_data in child_toimg_data loop
 toimg_data_DELETE (acursession,row_toimg_data.id,aInstanceID);
end loop;
--close child_toimg_data;
end;
declare cursor child_toimg_todelete is select toimg_todelete.toimg_todeleteid ID from toimg_todelete where  toimg_todelete.InstanceID = ainstanceid;
row_toimg_todelete  child_toimg_todelete%ROWTYPE;
begin
--open child_toimg_todelete;
for row_toimg_todelete in child_toimg_todelete loop
 toimg_todelete_DELETE (acursession,row_toimg_todelete.id,aInstanceID);
end loop;
--close child_toimg_todelete;
end;
declare cursor child_toimg_def is select toimg_def.toimg_defid ID from toimg_def where  toimg_def.InstanceID = ainstanceid;
row_toimg_def  child_toimg_def%ROWTYPE;
begin
--open child_toimg_def;
for row_toimg_def in child_toimg_def loop
 toimg_def_DELETE (acursession,row_toimg_def.id,aInstanceID);
end loop;
--close child_toimg_def;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure toimg_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'toimg'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_toimg_data is select toimg_data.toimg_dataid ID from toimg_data where  toimg_data.InstanceID = arowid;
ROW_toimg_data  lch_toimg_data%ROWTYPE;
begin
--open lch_toimg_data;
for row_toimg_data in lch_toimg_data loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from toimg_data where toimg_dataid=row_toimg_data.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_toimg_data;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_toimg_data;
     return;
   end if; 
 end if; 
 toimg_data_HCL (acursession,ROW_toimg_data.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_toimg_data;
   return;
 end if;
 end loop;
--close lch_toimg_data;
end;
declare cursor lch_toimg_todelete is select toimg_todelete.toimg_todeleteid ID from toimg_todelete where  toimg_todelete.InstanceID = arowid;
ROW_toimg_todelete  lch_toimg_todelete%ROWTYPE;
begin
--open lch_toimg_todelete;
for row_toimg_todelete in lch_toimg_todelete loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from toimg_todelete where toimg_todeleteid=row_toimg_todelete.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_toimg_todelete;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_toimg_todelete;
     return;
   end if; 
 end if; 
 toimg_todelete_HCL (acursession,ROW_toimg_todelete.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_toimg_todelete;
   return;
 end if;
 end loop;
--close lch_toimg_todelete;
end;
declare cursor lch_toimg_def is select toimg_def.toimg_defid ID from toimg_def where  toimg_def.InstanceID = arowid;
ROW_toimg_def  lch_toimg_def%ROWTYPE;
begin
--open lch_toimg_def;
for row_toimg_def in lch_toimg_def loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from toimg_def where toimg_defid=row_toimg_def.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_toimg_def;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_toimg_def;
     return;
   end if; 
 end if; 
 toimg_def_HCL (acursession,ROW_toimg_def.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_toimg_def;
   return;
 end if;
 end loop;
--close lch_toimg_def;
end;
 end if;
aIsLocked:=0;
end;
procedure toimg_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'toimg'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_toimg_data is select toimg_data.toimg_dataid id from toimg_data where  toimg_data.InstanceID = arowid;
row_toimg_data  pch_toimg_data%ROWTYPE;
begin
--open pch_toimg_data;
for row_toimg_data in  pch_toimg_data loop
 toimg_data_SINIT( acursession,row_toimg_data.id,assid);
 toimg_data_propagate( acursession,row_toimg_data.id);
end loop;
--close pch_toimg_data;
end;
declare cursor pch_toimg_todelete is select toimg_todelete.toimg_todeleteid id from toimg_todelete where  toimg_todelete.InstanceID = arowid;
row_toimg_todelete  pch_toimg_todelete%ROWTYPE;
begin
--open pch_toimg_todelete;
for row_toimg_todelete in  pch_toimg_todelete loop
 toimg_todelete_SINIT( acursession,row_toimg_todelete.id,assid);
 toimg_todelete_propagate( acursession,row_toimg_todelete.id);
end loop;
--close pch_toimg_todelete;
end;
declare cursor pch_toimg_def is select toimg_def.toimg_defid id from toimg_def where  toimg_def.InstanceID = arowid;
row_toimg_def  pch_toimg_def%ROWTYPE;
begin
--open pch_toimg_def;
for row_toimg_def in  pch_toimg_def loop
 toimg_def_SINIT( acursession,row_toimg_def.id,assid);
 toimg_def_propagate( acursession,row_toimg_def.id);
end loop;
--close pch_toimg_def;
end;
 end if; 
end;


procedure toimg_data_BRIEF  (
 aCURSESSION CHAR,
 atoimg_dataid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atoimg_dataid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from toimg_data where toimg_dataID=atoimg_dataID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from toimg_data where toimg_dataid=atoimg_dataID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=toimg_data');
    return;
  end if;
  aBRIEF:=func.toimg_data_BRIEF_F(atoimg_dataid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure toimg_data_DELETE /**/ (
 aCURSESSION CHAR,
 atoimg_dataid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from toimg_data where toimg_dataID=atoimg_dataID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from toimg_data where toimg_dataid=atoimg_dataID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:toimg_data',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=toimg_data');
      return;
    end if;
  end if;
 --  verify lock  --
 toimg_data_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atoimg_dataid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=toimg_data');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_data',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atoimg_dataid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_toimg_data is select  instanceid ID from instance where OwnerPartName ='toimg_data' and OwnerRowID=atoimg_dataid;
row_toimg_data  chld_toimg_data%ROWTYPE;
begin
--open chld_toimg_data;
for row_toimg_data in chld_toimg_data loop
 Kernel.INSTANCE_OWNER (acursession,row_toimg_data.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_toimg_data.id);
end loop;
--close chld_toimg_data;
end ;
  delete from  toimg_data 
  where  toimg_dataID = atoimg_dataID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Картинки*/
procedure toimg_data_SAVE /**/ (
 aCURSESSION CHAR,
 atoimg_dataid CHAR,
aInstanceID CHAR 
,afname
 VARCHAR2/* Имя файла *//* Имя файла */
,alink2part
 VARCHAR2/* Раздел привязки *//* Раздел привязки */
,alink2id
 VARCHAR2/* Идентификатор привязки *//* Идентификатор привязки */
,afiletype
 VARCHAR2 := null /* Тип файла *//* Тип файла */
,alink1part
 VARCHAR2 := null /* Раздел2 *//* Раздел2 */
,alink1id
 VARCHAR2 := null /* Идентификатор2 *//* Идентификатор2 */
,aoper CHAR := null /* Оператор *//* Оператор */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from toimg_data where toimg_dataID=atoimg_dataID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from toimg_data where toimg_dataid=atoimg_dataID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:toimg_data',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=toimg_data');
      return;
    end if;
  end if;
 --  verify lock  --
 toimg_data_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atoimg_dataid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=toimg_data');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_data',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atoimg_dataid,aLogInstanceID=&gt;aInstanceID);
 update  toimg_data set ChangeStamp=sysdate
,
  fname=afname
,
  link2part=alink2part
,
  link2id=alink2id
,
  filetype=afiletype
,
  link1part=alink1part
,
  link1id=alink1id
,
  oper=aoper
  where  toimg_dataID = atoimg_dataID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:toimg_data',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=toimg_data');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=toimg_data');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_data',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atoimg_dataid,aLogInstanceID=&gt;aInstanceID);
 insert into   toimg_data
 (  toimg_dataID 
,InstanceID
,fname

,link2part

,link2id

,filetype

,link1part

,link1id

,oper

 ) values ( atoimg_dataID 
,aInstanceID
,afname

,alink2part

,alink2id

,afiletype

,alink1part

,alink1id

,aoper

 ); 
 toimg_data_SINIT( aCURSESSION,atoimg_dataid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure toimg_data_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from toimg_data where  toimg_dataid=aRowID;
 end; 

procedure toimg_data_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from toimg_data where toimg_dataid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  toimg_data_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin toimg.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure toimg_data_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 toimg_data_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  toimg_data_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from toimg_data where toimg_dataid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=toimg_data');
    return;
  end if;
   if  aLockMode =2  
   then   
    update toimg_data set LockUserID =auserID ,LockSessionID =null where toimg_dataid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update toimg_data set LockUserID =null,LockSessionID =aCURSESSION  where toimg_dataid=aRowID;
     return;
   end if;
 end ;

procedure toimg_data_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure toimg_data_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 toimg_data_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update toimg_data set LockUserID =null  where toimg_dataid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update toimg_data set LockSessionID =null  where toimg_dataid=aRowID;
     return;
   end if;
 end; 

procedure toimg_data_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from toimg_data where toimg_dataid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =toimg_data');
    return;
  end if;
if aSecurityStyleID is null then
 toimg_data_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update toimg_data set securitystyleid =aStyleID where toimg_dataid = aRowID;
else 
 update toimg_data set securitystyleid =aSecurityStyleID where toimg_dataid = aRowID;
end if; 
end ; 

procedure toimg_data_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from toimg_data where toimg_dataid=aRowid;
end;


procedure toimg_todelete_BRIEF  (
 aCURSESSION CHAR,
 atoimg_todeleteid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atoimg_todeleteid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from toimg_todelete where toimg_todeleteID=atoimg_todeleteID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from toimg_todelete where toimg_todeleteid=atoimg_todeleteID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=toimg_todelete');
    return;
  end if;
  aBRIEF:=func.toimg_todelete_BRIEF_F(atoimg_todeleteid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure toimg_todelete_DELETE /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 atoimg_todeleteid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from toimg_todelete where toimg_todeleteID=atoimg_todeleteID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from toimg_todelete where toimg_todeleteid=atoimg_todeleteID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:toimg_todelete',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=toimg_todelete');
      return;
    end if;
  end if;
 --  verify lock  --
 toimg_todelete_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atoimg_todeleteid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=toimg_todelete');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_todelete',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atoimg_todeleteid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_toimg_todelete is select  instanceid ID from instance where OwnerPartName ='toimg_todelete' and OwnerRowID=atoimg_todeleteid;
row_toimg_todelete  chld_toimg_todelete%ROWTYPE;
begin
--open chld_toimg_todelete;
for row_toimg_todelete in chld_toimg_todelete loop
 Kernel.INSTANCE_OWNER (acursession,row_toimg_todelete.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_toimg_todelete.id);
end loop;
--close chld_toimg_todelete;
end ;
  delete from  toimg_todelete 
  where  toimg_todeleteID = atoimg_todeleteID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Файлы на удаление*/
procedure toimg_todelete_SAVE /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 atoimg_todeleteid CHAR,
aInstanceID CHAR 
,afname
 VARCHAR2/* Имя файла *//* Имя файла */
,afilerowid
 VARCHAR2 := null /* ид строки дя удаления *//* ид строки дя удаления */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from toimg_todelete where toimg_todeleteID=atoimg_todeleteID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from toimg_todelete where toimg_todeleteid=atoimg_todeleteID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:toimg_todelete',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=toimg_todelete');
      return;
    end if;
  end if;
 --  verify lock  --
 toimg_todelete_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atoimg_todeleteid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=toimg_todelete');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_todelete',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atoimg_todeleteid,aLogInstanceID=&gt;aInstanceID);
 update  toimg_todelete set ChangeStamp=sysdate
,
  fname=afname
,
  filerowid=afilerowid
  where  toimg_todeleteID = atoimg_todeleteID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:toimg_todelete',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=toimg_todelete');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=toimg_todelete');
    return;
  end if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_todelete',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atoimg_todeleteid,aLogInstanceID=&gt;aInstanceID);
 insert into   toimg_todelete
 (  toimg_todeleteID 
,InstanceID
,fname

,filerowid

 ) values ( atoimg_todeleteID 
,aInstanceID
,afname

,afilerowid

 ); 
 toimg_todelete_SINIT( aCURSESSION,atoimg_todeleteid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure toimg_todelete_PARENT /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from toimg_todelete where  toimg_todeleteid=aRowID;
 end; 

procedure toimg_todelete_ISLOCKED /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from toimg_todelete where toimg_todeleteid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  toimg_todelete_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin toimg.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure toimg_todelete_LOCK /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 toimg_todelete_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  toimg_todelete_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from toimg_todelete where toimg_todeleteid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=toimg_todelete');
    return;
  end if;
   if  aLockMode =2  
   then   
    update toimg_todelete set LockUserID =auserID ,LockSessionID =null where toimg_todeleteid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update toimg_todelete set LockUserID =null,LockSessionID =aCURSESSION  where toimg_todeleteid=aRowID;
     return;
   end if;
 end ;

procedure toimg_todelete_HCL /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure toimg_todelete_UNLOCK /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 toimg_todelete_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update toimg_todelete set LockUserID =null  where toimg_todeleteid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update toimg_todelete set LockSessionID =null  where toimg_todeleteid=aRowID;
     return;
   end if;
 end; 

procedure toimg_todelete_SINIT /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from toimg_todelete where toimg_todeleteid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =toimg_todelete');
    return;
  end if;
if aSecurityStyleID is null then
 toimg_todelete_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update toimg_todelete set securitystyleid =aStyleID where toimg_todeleteid = aRowID;
else 
 update toimg_todelete set securitystyleid =aSecurityStyleID where toimg_todeleteid = aRowID;
end if; 
end ; 

procedure toimg_todelete_propagate /*Передать информацию серверу об удалении локального файла*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from toimg_todelete where toimg_todeleteid=aRowid;
end;


procedure toimg_def_BRIEF  (
 aCURSESSION CHAR,
 atoimg_defid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if atoimg_defid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from toimg_def where toimg_defID=atoimg_defID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from toimg_def where toimg_defid=atoimg_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=toimg_def');
    return;
  end if;
  aBRIEF:=func.toimg_def_BRIEF_F(atoimg_defid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure toimg_def_DELETE /**/ (
 aCURSESSION CHAR,
 atoimg_defid CHAR,
 ainstanceid char
) as 
 aSysLogID CHAR(38);
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from toimg_def where toimg_defID=atoimg_defID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from toimg_def where toimg_defid=atoimg_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:toimg_def',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=toimg_def');
      return;
    end if;
  end if;
 --  verify lock  --
 toimg_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atoimg_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=toimg_def');
    return;
  end if;
  --begin tran--  
 -- erase child items --
select  newid() into aSysLogid from SYS.DUAL;
 MTZSystem.SysLog_SAVE (aCURSESSION=&gt;acursession ,aTheSession=&gt;acursession, aInstanceID=&gt;aSysInstID, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_def',
 aVERB=&gt;'DELETEROW',  aThe_Resource=&gt;atoimg_defid, aLogInstanceID=&gt;aInstanceID);
declare cursor chld_toimg_def is select  instanceid ID from instance where OwnerPartName ='toimg_def' and OwnerRowID=atoimg_defid;
row_toimg_def  chld_toimg_def%ROWTYPE;
begin
--open chld_toimg_def;
for row_toimg_def in chld_toimg_def loop
 Kernel.INSTANCE_OWNER (acursession,row_toimg_def.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_toimg_def.id);
end loop;
--close chld_toimg_def;
end ;
  delete from  toimg_def 
  where  toimg_defID = atoimg_defID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание хранилища*/
procedure toimg_def_SAVE /**/ (
 aCURSESSION CHAR,
 atoimg_defid CHAR,
aInstanceID CHAR 
,acomputername
 VARCHAR2 := null /* Имя  станции *//* Имя  станции */
,aimagestore
 VARCHAR2 := null /* Папка с фотографиями *//* Папка с фотографиями */
,asharedfolder
 VARCHAR2 := null /* Имя общей директории *//* Имя общей директории */
) as 
aSysLogid CHAR(38);
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from toimg_def where toimg_defID=atoimg_defID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from toimg_def where toimg_defid=atoimg_defID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:toimg_def',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=toimg_def');
      return;
    end if;
  end if;
 --  verify lock  --
 toimg_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;atoimg_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=toimg_def');
    return;
  end if;
 -- update row  --
select newid() into asyslogid from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_def',
 aVERB=&gt;'EDITROW',  aThe_Resource=&gt;atoimg_defid,aLogInstanceID=&gt;aInstanceID);
 update  toimg_def set ChangeStamp=sysdate
,
  computername=acomputername
,
  imagestore=aimagestore
,
  sharedfolder=asharedfolder
  where  toimg_defID = atoimg_defID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:toimg_def',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=toimg_def');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=toimg_def');
    return;
  end if;
select Count(*) into existsCnt from toimg_def where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;toimg_def&gt;');
    return;
 End if;
select newid() into aSysLogID from sys.dual;
 MTZSystem.SysLog_SAVE( aTheSession=&gt;acursession,aCURSESSION=&gt;acursession, aInstanceID=&gt;asysinstid, aSysLogid=&gt;aSysLogid, aLogStructID =&gt; 'toimg_def',
 aVERB=&gt;'CREATEROW',  aThe_Resource=&gt;atoimg_defid,aLogInstanceID=&gt;aInstanceID);
 insert into   toimg_def
 (  toimg_defID 
,InstanceID
,computername

,imagestore

,sharedfolder

 ) values ( atoimg_defID 
,aInstanceID
,acomputername

,aimagestore

,asharedfolder

 ); 
 toimg_def_SINIT( aCURSESSION,atoimg_defid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure toimg_def_PARENT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from toimg_def where  toimg_defid=aRowID;
 end; 

procedure toimg_def_ISLOCKED /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from toimg_def where toimg_defid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  toimg_def_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin toimg.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure toimg_def_LOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 toimg_def_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  toimg_def_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from toimg_def where toimg_defid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=toimg_def');
    return;
  end if;
   if  aLockMode =2  
   then   
    update toimg_def set LockUserID =auserID ,LockSessionID =null where toimg_defid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update toimg_def set LockUserID =null,LockSessionID =aCURSESSION  where toimg_defid=aRowID;
     return;
   end if;
 end ;

procedure toimg_def_HCL /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure toimg_def_UNLOCK /**/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 toimg_def_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update toimg_def set LockUserID =null  where toimg_defid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update toimg_def set LockSessionID =null  where toimg_defid=aRowID;
     return;
   end if;
 end; 

procedure toimg_def_SINIT /**/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from toimg_def where toimg_defid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =toimg_def');
    return;
  end if;
if aSecurityStyleID is null then
 toimg_def_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update toimg_def set securitystyleid =aStyleID where toimg_defid = aRowID;
else 
 update toimg_def set securitystyleid =aSecurityStyleID where toimg_defid = aRowID;
end if; 
end ; 

procedure toimg_def_propagate /**/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from toimg_def where toimg_defid=aRowid;
end;
end toimg;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtz2job" BlockCode=" create or replace package body mtz2job as

procedure mtz2job_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtz2job'
then
declare cursor child_mtz2job_def is select mtz2job_def.mtz2job_defid ID from mtz2job_def where  mtz2job_def.InstanceID = ainstanceid;
row_mtz2job_def  child_mtz2job_def%ROWTYPE;
begin
--open child_mtz2job_def;
for row_mtz2job_def in child_mtz2job_def loop
 mtz2job_def_DELETE (acursession,row_mtz2job_def.id,aInstanceID);
end loop;
--close child_mtz2job_def;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtz2job_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtz2job'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_mtz2job_def is select mtz2job_def.mtz2job_defid ID from mtz2job_def where  mtz2job_def.InstanceID = arowid;
ROW_mtz2job_def  lch_mtz2job_def%ROWTYPE;
begin
--open lch_mtz2job_def;
for row_mtz2job_def in lch_mtz2job_def loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from mtz2job_def where mtz2job_defid=row_mtz2job_def.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_mtz2job_def;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_mtz2job_def;
     return;
   end if; 
 end if; 
 mtz2job_def_HCL (acursession,ROW_mtz2job_def.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_mtz2job_def;
   return;
 end if;
 end loop;
--close lch_mtz2job_def;
end;
 end if;
aIsLocked:=0;
end;
procedure mtz2job_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtz2job'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_mtz2job_def is select mtz2job_def.mtz2job_defid id from mtz2job_def where  mtz2job_def.InstanceID = arowid;
row_mtz2job_def  pch_mtz2job_def%ROWTYPE;
begin
--open pch_mtz2job_def;
for row_mtz2job_def in  pch_mtz2job_def loop
 mtz2job_def_SINIT( acursession,row_mtz2job_def.id,assid);
 mtz2job_def_propagate( acursession,row_mtz2job_def.id);
end loop;
--close pch_mtz2job_def;
end;
 end if; 
end;


procedure mtz2job_def_BRIEF  (
 aCURSESSION CHAR,
 amtz2job_defid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if amtz2job_defid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from mtz2job_def where mtz2job_defID=amtz2job_defID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from mtz2job_def where mtz2job_defid=amtz2job_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=mtz2job_def');
    return;
  end if;
  aBRIEF:=func.mtz2job_def_BRIEF_F(amtz2job_defid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure mtz2job_def_DELETE /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 amtz2job_defid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from mtz2job_def where mtz2job_defID=amtz2job_defID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from mtz2job_def where mtz2job_defid=amtz2job_defID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:mtz2job_def',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=mtz2job_def');
      return;
    end if;
  end if;
 --  verify lock  --
 mtz2job_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtz2job_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=mtz2job_def');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_mtz2job_def is select  instanceid ID from instance where OwnerPartName ='mtz2job_def' and OwnerRowID=amtz2job_defid;
row_mtz2job_def  chld_mtz2job_def%ROWTYPE;
begin
--open chld_mtz2job_def;
for row_mtz2job_def in chld_mtz2job_def loop
 Kernel.INSTANCE_OWNER (acursession,row_mtz2job_def.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_mtz2job_def.id);
end loop;
--close chld_mtz2job_def;
end ;
  delete from  mtz2job_def 
  where  mtz2job_defID = amtz2job_defID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Отложенное событие*/
procedure mtz2job_def_SAVE /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 amtz2job_defid CHAR,
aInstanceID CHAR 
,aeventdate
 DATE/* Отложено до *//* Отложено до */
,aeventype
 VARCHAR2/* Тип события *//* Тип события */
,athruobject CHAR/* Объект - причина события *//* Объект - причина события */
,athrustate CHAR := null /* Состояние - причина *//* Состояние - причина */
,anextstate CHAR := null /* Состояние после обработки *//* Состояние после обработки */
,aprocessdate
 DATE := null /* Момент обработки *//* Момент обработки */
,aprocessed
 NUMBER/* Обработан *//* Обработан */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from mtz2job_def where mtz2job_defID=amtz2job_defID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from mtz2job_def where mtz2job_defid=amtz2job_defID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:mtz2job_def',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=mtz2job_def');
      return;
    end if;
  end if;
 --  verify lock  --
 mtz2job_def_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;amtz2job_defid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtz2job_def');
    return;
  end if;
 -- update row  --
 update  mtz2job_def set ChangeStamp=sysdate
,
  eventdate=aeventdate
,
  eventype=aeventype
,
  thruobject=athruobject
,
  thrustate=athrustate
,
  nextstate=anextstate
,
  processdate=aprocessdate
,
  processed=aprocessed
  where  mtz2job_defID = amtz2job_defID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:mtz2job_def',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=mtz2job_def');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=mtz2job_def');
    return;
  end if;
 insert into   mtz2job_def
 (  mtz2job_defID 
,InstanceID
,eventdate

,eventype

,thruobject

,thrustate

,nextstate

,processdate

,processed

 ) values ( amtz2job_defID 
,aInstanceID
,aeventdate

,aeventype

,athruobject

,athrustate

,anextstate

,aprocessdate

,aprocessed

 ); 
 mtz2job_def_SINIT( aCURSESSION,amtz2job_defid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure mtz2job_def_PARENT /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from mtz2job_def where  mtz2job_defid=aRowID;
 end; 

procedure mtz2job_def_ISLOCKED /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from mtz2job_def where mtz2job_defid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  mtz2job_def_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtz2job.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure mtz2job_def_LOCK /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 mtz2job_def_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  mtz2job_def_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from mtz2job_def where mtz2job_defid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=mtz2job_def');
    return;
  end if;
   if  aLockMode =2  
   then   
    update mtz2job_def set LockUserID =auserID ,LockSessionID =null where mtz2job_defid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update mtz2job_def set LockUserID =null,LockSessionID =aCURSESSION  where mtz2job_defid=aRowID;
     return;
   end if;
 end ;

procedure mtz2job_def_HCL /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure mtz2job_def_UNLOCK /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 mtz2job_def_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update mtz2job_def set LockUserID =null  where mtz2job_defid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update mtz2job_def set LockSessionID =null  where mtz2job_defid=aRowID;
     return;
   end if;
 end; 

procedure mtz2job_def_SINIT /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from mtz2job_def where mtz2job_defid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =mtz2job_def');
    return;
  end if;
if aSecurityStyleID is null then
 mtz2job_def_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update mtz2job_def set securitystyleid =aStyleID where mtz2job_defid = aRowID;
else 
 update mtz2job_def set securitystyleid =aSecurityStyleID where mtz2job_defid = aRowID;
end if; 
end ; 

procedure mtz2job_def_propagate /*Описание отложенного события*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from mtz2job_def where mtz2job_defid=aRowid;
end;
end mtz2job;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzfltr" BlockCode=" create or replace package body mtzfltr as

procedure mtzfltr_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzfltr'
then
declare cursor child_filterfieldgroup is select filterfieldgroup.filterfieldgroupid ID from filterfieldgroup where  filterfieldgroup.InstanceID = ainstanceid;
row_filterfieldgroup  child_filterfieldgroup%ROWTYPE;
begin
--open child_filterfieldgroup;
for row_filterfieldgroup in child_filterfieldgroup loop
 filterfieldgroup_DELETE (acursession,row_filterfieldgroup.id,aInstanceID);
end loop;
--close child_filterfieldgroup;
end;
declare cursor child_filters is select filters.filtersid ID from filters where  filters.InstanceID = ainstanceid;
row_filters  child_filters%ROWTYPE;
begin
--open child_filters;
for row_filters in child_filters loop
 filters_DELETE (acursession,row_filters.id,aInstanceID);
end loop;
--close child_filters;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzfltr_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzfltr'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_filterfieldgroup is select filterfieldgroup.filterfieldgroupid ID from filterfieldgroup where  filterfieldgroup.InstanceID = arowid;
ROW_filterfieldgroup  lch_filterfieldgroup%ROWTYPE;
begin
--open lch_filterfieldgroup;
for row_filterfieldgroup in lch_filterfieldgroup loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from filterfieldgroup where filterfieldgroupid=row_filterfieldgroup.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_filterfieldgroup;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_filterfieldgroup;
     return;
   end if; 
 end if; 
 filterfieldgroup_HCL (acursession,ROW_filterfieldgroup.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_filterfieldgroup;
   return;
 end if;
 end loop;
--close lch_filterfieldgroup;
end;
declare cursor lch_filters is select filters.filtersid ID from filters where  filters.InstanceID = arowid;
ROW_filters  lch_filters%ROWTYPE;
begin
--open lch_filters;
for row_filters in lch_filters loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from filters where filtersid=row_filters.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_filters;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_filters;
     return;
   end if; 
 end if; 
 filters_HCL (acursession,ROW_filters.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_filters;
   return;
 end if;
 end loop;
--close lch_filters;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzfltr_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzfltr'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_filterfieldgroup is select filterfieldgroup.filterfieldgroupid id from filterfieldgroup where  filterfieldgroup.InstanceID = arowid;
row_filterfieldgroup  pch_filterfieldgroup%ROWTYPE;
begin
--open pch_filterfieldgroup;
for row_filterfieldgroup in  pch_filterfieldgroup loop
 filterfieldgroup_SINIT( acursession,row_filterfieldgroup.id,assid);
 filterfieldgroup_propagate( acursession,row_filterfieldgroup.id);
end loop;
--close pch_filterfieldgroup;
end;
declare cursor pch_filters is select filters.filtersid id from filters where  filters.InstanceID = arowid;
row_filters  pch_filters%ROWTYPE;
begin
--open pch_filters;
for row_filters in  pch_filters loop
 filters_SINIT( acursession,row_filters.id,assid);
 filters_propagate( acursession,row_filters.id);
end loop;
--close pch_filters;
end;
 end if; 
end;


procedure filterfieldgroup_BRIEF  (
 aCURSESSION CHAR,
 afilterfieldgroupid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afilterfieldgroupid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from filterfieldgroup where filterfieldgroupID=afilterfieldgroupID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from filterfieldgroup where filterfieldgroupid=afilterfieldgroupID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=filterfieldgroup');
    return;
  end if;
  aBRIEF:=func.filterfieldgroup_BRIEF_F(afilterfieldgroupid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure filterfieldgroup_DELETE /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 afilterfieldgroupid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from filterfieldgroup where filterfieldgroupID=afilterfieldgroupID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from filterfieldgroup where filterfieldgroupid=afilterfieldgroupID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:filterfieldgroup',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=filterfieldgroup');
      return;
    end if;
  end if;
 --  verify lock  --
 filterfieldgroup_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afilterfieldgroupid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=filterfieldgroup');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_fileterfield is select fileterfield.fileterfieldid ID from fileterfield where  fileterfield.ParentStructRowID = afilterfieldgroupid;
    child_fileterfield_rec  child_fileterfield%ROWTYPE;
    begin
    --open child_fileterfield;
      for child_fileterfield_rec in child_fileterfield loop
      fileterfield_DELETE (acursession,child_fileterfield_rec.id,aInstanceid);
      end loop;
      --close child_fileterfield;
    end ;
declare cursor chld_filterfieldgroup is select  instanceid ID from instance where OwnerPartName ='filterfieldgroup' and OwnerRowID=afilterfieldgroupid;
row_filterfieldgroup  chld_filterfieldgroup%ROWTYPE;
begin
--open chld_filterfieldgroup;
for row_filterfieldgroup in chld_filterfieldgroup loop
 Kernel.INSTANCE_OWNER (acursession,row_filterfieldgroup.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_filterfieldgroup.id);
end loop;
--close chld_filterfieldgroup;
end ;
  delete from  filterfieldgroup 
  where  filterfieldgroupID = afilterfieldgroupID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Группа полей фильтра*/
procedure filterfieldgroup_SAVE /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 afilterfieldgroupid CHAR,
aInstanceID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,aallowignore
 NUMBER/* Можно отключать *//* Можно отключать */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from filterfieldgroup where filterfieldgroupID=afilterfieldgroupID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from filterfieldgroup where filterfieldgroupid=afilterfieldgroupID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:filterfieldgroup',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=filterfieldgroup');
      return;
    end if;
  end if;
 --  verify lock  --
 filterfieldgroup_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afilterfieldgroupid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=filterfieldgroup');
    return;
  end if;
 -- update row  --
 update  filterfieldgroup set ChangeStamp=sysdate
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  allowignore=aallowignore
  where  filterfieldgroupID = afilterfieldgroupID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:filterfieldgroup',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=filterfieldgroup');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=filterfieldgroup');
    return;
  end if;
 insert into   filterfieldgroup
 (  filterfieldgroupID 
,InstanceID
,sequence

,name

,caption

,allowignore

 ) values ( afilterfieldgroupID 
,aInstanceID
,asequence

,aname

,acaption

,aallowignore

 ); 
 filterfieldgroup_SINIT( aCURSESSION,afilterfieldgroupid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure filterfieldgroup_PARENT /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from filterfieldgroup where  filterfieldgroupid=aRowID;
 end; 

procedure filterfieldgroup_ISLOCKED /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from filterfieldgroup where filterfieldgroupid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  filterfieldgroup_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzfltr.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure filterfieldgroup_LOCK /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 filterfieldgroup_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  filterfieldgroup_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from filterfieldgroup where filterfieldgroupid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=filterfieldgroup');
    return;
  end if;
   if  aLockMode =2  
   then   
    update filterfieldgroup set LockUserID =auserID ,LockSessionID =null where filterfieldgroupid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update filterfieldgroup set LockUserID =null,LockSessionID =aCURSESSION  where filterfieldgroupid=aRowID;
     return;
   end if;
 end ;

procedure filterfieldgroup_HCL /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_fileterfield is select fileterfield.fileterfieldid ID from fileterfield where  fileterfield.ParentStructRowID = aRowid;
row_fileterfield lch_fileterfield%ROWTYPE;
begin  
--open lch_fileterfield;
for row_fileterfield in lch_fileterfield
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from fileterfield where fileterfieldid=row_fileterfield.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_fileterfield;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_fileterfield;
     return;
   end if; 
 end if;  
 fileterfield_HCL (acursession,row_fileterfield.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_fileterfield;
   return;
 end if;
end loop;
--close lch_fileterfield;
end;
aIsLocked :=0;
end;

procedure filterfieldgroup_UNLOCK /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 filterfieldgroup_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update filterfieldgroup set LockUserID =null  where filterfieldgroupid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update filterfieldgroup set LockSessionID =null  where filterfieldgroupid=aRowID;
     return;
   end if;
 end; 

procedure filterfieldgroup_SINIT /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from filterfieldgroup where filterfieldgroupid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =filterfieldgroup');
    return;
  end if;
if aSecurityStyleID is null then
 filterfieldgroup_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update filterfieldgroup set securitystyleid =aStyleID where filterfieldgroupid = aRowID;
else 
 update filterfieldgroup set securitystyleid =aSecurityStyleID where filterfieldgroupid = aRowID;
end if; 
end ; 

procedure filterfieldgroup_propagate /*Группа полей фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from filterfieldgroup where filterfieldgroupid=aRowid;
declare cursor pch_fileterfield  is select fileterfield.fileterfieldid ID from fileterfield where  fileterfield.ParentStructRowID = aRowid;
row_fileterfield  pch_fileterfield%ROWTYPE;
begin
--open pch_fileterfield;
for row_fileterfield in pch_fileterfield loop
   fileterfield_SINIT( acursession,row_fileterfield.id,assid);
   fileterfield_propagate( acursession,row_fileterfield.id);
end loop;
--close pch_fileterfield;
end;
end;


procedure fileterfield_BRIEF  (
 aCURSESSION CHAR,
 afileterfieldid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afileterfieldid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from fileterfield where fileterfieldID=afileterfieldID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from fileterfield where fileterfieldid=afileterfieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=fileterfield');
    return;
  end if;
  aBRIEF:=func.fileterfield_BRIEF_F(afileterfieldid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure fileterfield_DELETE /*Поле фильтра*/ (
 aCURSESSION CHAR,
 afileterfieldid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from fileterfield where fileterfieldID=afileterfieldID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from fileterfield where fileterfieldid=afileterfieldID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:fileterfield',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=fileterfield');
      return;
    end if;
  end if;
 --  verify lock  --
 fileterfield_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afileterfieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=fileterfield');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_fileterfield is select  instanceid ID from instance where OwnerPartName ='fileterfield' and OwnerRowID=afileterfieldid;
row_fileterfield  chld_fileterfield%ROWTYPE;
begin
--open chld_fileterfield;
for row_fileterfield in chld_fileterfield loop
 Kernel.INSTANCE_OWNER (acursession,row_fileterfield.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_fileterfield.id);
end loop;
--close chld_fileterfield;
end ;
  delete from  fileterfield 
  where  fileterfieldID = afileterfieldID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поле фильтра*/
procedure fileterfield_SAVE /*Поле фильтра*/ (
 aCURSESSION CHAR,
 afileterfieldid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,asequence
 NUMBER/* Последовательность *//* Последовательность */
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,afieldtype CHAR/* Тип поля *//* Тип поля */
,afieldsize
 NUMBER := null /* Размер *//* Размер */
,areftype
 NUMBER := null /* Тип ссылки *//* Тип ссылки */
,areftotype CHAR := null /* Тип, куда ссылаемся *//* Тип, куда ссылаемся */
,areftopart CHAR := null /* Раздел, куда ссылаемся *//* Раздел, куда ссылаемся */
,avaluearray
 NUMBER/* Массив значений *//* Массив значений */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from fileterfield where fileterfieldID=afileterfieldID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from fileterfield where fileterfieldid=afileterfieldID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:fileterfield',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=fileterfield');
      return;
    end if;
  end if;
 --  verify lock  --
 fileterfield_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afileterfieldid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fileterfield');
    return;
  end if;
 -- update row  --
 update  fileterfield set ChangeStamp=sysdate
,
  sequence=asequence
,
  name=aname
,
  caption=acaption
,
  fieldtype=afieldtype
,
  fieldsize=afieldsize
,
  reftype=areftype
,
  reftotype=areftotype
,
  reftopart=areftopart
,
  valuearray=avaluearray
  where  fileterfieldID = afileterfieldID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from filterfieldgroup where filterfieldgroupid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:fileterfield',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=fileterfield');
      return;
    end if;
 end if;
 filterfieldgroup_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=fileterfield');
    return;
  end if;
 insert into   fileterfield
 (  fileterfieldID 
,ParentStructRowID
,sequence

,name

,caption

,fieldtype

,fieldsize

,reftype

,reftotype

,reftopart

,valuearray

 ) values ( afileterfieldID 
,aParentStructRowID
,asequence

,aname

,acaption

,afieldtype

,afieldsize

,areftype

,areftotype

,areftopart

,avaluearray

 ); 
 fileterfield_SINIT( aCURSESSION,afileterfieldid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure fileterfield_PARENT /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from fileterfield where  fileterfieldid=aRowID;
  aParentTable := 'filterfieldgroup';
 end; 

procedure fileterfield_ISLOCKED /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from fileterfield where fileterfieldid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  fileterfield_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzfltr.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure fileterfield_LOCK /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 fileterfield_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  fileterfield_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from fileterfield where fileterfieldid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=fileterfield');
    return;
  end if;
   if  aLockMode =2  
   then   
    update fileterfield set LockUserID =auserID ,LockSessionID =null where fileterfieldid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update fileterfield set LockUserID =null,LockSessionID =aCURSESSION  where fileterfieldid=aRowID;
     return;
   end if;
 end ;

procedure fileterfield_HCL /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure fileterfield_UNLOCK /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 fileterfield_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update fileterfield set LockUserID =null  where fileterfieldid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update fileterfield set LockSessionID =null  where fileterfieldid=aRowID;
     return;
   end if;
 end; 

procedure fileterfield_SINIT /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from fileterfield where fileterfieldid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =fileterfield');
    return;
  end if;
if aSecurityStyleID is null then
 fileterfield_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update fileterfield set securitystyleid =aStyleID where fileterfieldid = aRowID;
else 
 update fileterfield set securitystyleid =aSecurityStyleID where fileterfieldid = aRowID;
end if; 
end ; 

procedure fileterfield_propagate /*Поле фильтра*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from fileterfield where fileterfieldid=aRowid;
end;


procedure filters_BRIEF  (
 aCURSESSION CHAR,
 afiltersid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if afiltersid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from filters where filtersID=afiltersID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from filters where filtersid=afiltersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=filters');
    return;
  end if;
  aBRIEF:=func.filters_BRIEF_F(afiltersid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure filters_DELETE /*Фильтр*/ (
 aCURSESSION CHAR,
 afiltersid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from filters where filtersID=afiltersID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from filters where filtersid=afiltersID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:filters',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=filters');
      return;
    end if;
  end if;
 --  verify lock  --
 filters_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afiltersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=filters');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_filters is select  instanceid ID from instance where OwnerPartName ='filters' and OwnerRowID=afiltersid;
row_filters  chld_filters%ROWTYPE;
begin
--open chld_filters;
for row_filters in chld_filters loop
 Kernel.INSTANCE_OWNER (acursession,row_filters.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_filters.id);
end loop;
--close chld_filters;
end ;
  delete from  filters 
  where  filtersID = afiltersID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Фильтр*/
procedure filters_SAVE /*Фильтр*/ (
 aCURSESSION CHAR,
 afiltersid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,athecaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from filters where filtersID=afiltersID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from filters where filtersid=afiltersID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:filters',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=filters');
      return;
    end if;
  end if;
 --  verify lock  --
 filters_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;afiltersid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=filters');
    return;
  end if;
 -- update row  --
 update  filters set ChangeStamp=sysdate
,
  name=aname
,
  thecaption=athecaption
,
  thecomment=athecomment
  where  filtersID = afiltersID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:filters',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=filters');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=filters');
    return;
  end if;
select Count(*) into existsCnt from filters where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;filters&gt;');
    return;
 End if;
 insert into   filters
 (  filtersID 
,InstanceID
,name

,thecaption

,thecomment

 ) values ( afiltersID 
,aInstanceID
,aname

,athecaption

,athecomment

 ); 
 filters_SINIT( aCURSESSION,afiltersid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure filters_PARENT /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from filters where  filtersid=aRowID;
 end; 

procedure filters_ISLOCKED /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from filters where filtersid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  filters_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzfltr.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure filters_LOCK /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 filters_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  filters_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from filters where filtersid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=filters');
    return;
  end if;
   if  aLockMode =2  
   then   
    update filters set LockUserID =auserID ,LockSessionID =null where filtersid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update filters set LockUserID =null,LockSessionID =aCURSESSION  where filtersid=aRowID;
     return;
   end if;
 end ;

procedure filters_HCL /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure filters_UNLOCK /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 filters_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update filters set LockUserID =null  where filtersid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update filters set LockSessionID =null  where filtersid=aRowID;
     return;
   end if;
 end; 

procedure filters_SINIT /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from filters where filtersid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =filters');
    return;
  end if;
if aSecurityStyleID is null then
 filters_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update filters set securitystyleid =aStyleID where filtersid = aRowID;
else 
 update filters set securitystyleid =aSecurityStyleID where filtersid = aRowID;
end if; 
end ; 

procedure filters_propagate /*Фильтр*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from filters where filtersid=aRowid;
end;
end mtzfltr;
/
">
      <FormData Name="" />
    </BlockHolder>
    <BlockHolder BlockName="--mtzrprt" BlockCode=" create or replace package body mtzrprt as

procedure mtzrprt_DELETE(acursession CHAR, aInstanceID CHAR) as  
aObjType  varchar2(255);
begin
select  objtype into aObjType from instance where instanceid=ainstanceid;
if  aObjType ='mtzrprt'
then
declare cursor child_rptstruct is select rptstruct.rptstructid ID from rptstruct where  rptstruct.InstanceID = ainstanceid;
row_rptstruct  child_rptstruct%ROWTYPE;
begin
--open child_rptstruct;
for row_rptstruct in child_rptstruct loop
 rptstruct_DELETE (acursession,row_rptstruct.id,aInstanceID);
end loop;
--close child_rptstruct;
end;
declare cursor child_rptformula is select rptformula.rptformulaid ID from rptformula where  rptformula.InstanceID = ainstanceid;
row_rptformula  child_rptformula%ROWTYPE;
begin
--open child_rptformula;
for row_rptformula in child_rptformula loop
 rptformula_DELETE (acursession,row_rptformula.id,aInstanceID);
end loop;
--close child_rptformula;
end;
declare cursor child_reports is select reports.reportsid ID from reports where  reports.InstanceID = ainstanceid;
row_reports  child_reports%ROWTYPE;
begin
--open child_reports;
for row_reports in child_reports loop
 reports_DELETE (acursession,row_reports.id,aInstanceID);
end loop;
--close child_reports;
end;
return;
&lt;&lt;del_error&gt;&gt;
return;
end if;
end;
procedure mtzrprt_HCL(acursession CHAR, aROWID CHAR, aIsLocked out integer) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin
select  objtype into aObjtype from instance where instanceid=aRowid;
if aobjtype = 'mtzrprt'
 then
 select usersid into auserID from  the_session where the_sessionid=acursession;
declare cursor lch_rptstruct is select rptstruct.rptstructid ID from rptstruct where  rptstruct.InstanceID = arowid;
ROW_rptstruct  lch_rptstruct%ROWTYPE;
begin
--open lch_rptstruct;
for row_rptstruct in lch_rptstruct loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from rptstruct where rptstructid=row_rptstruct.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_rptstruct;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_rptstruct;
     return;
   end if; 
 end if; 
 rptstruct_HCL (acursession,ROW_rptstruct.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_rptstruct;
   return;
 end if;
 end loop;
--close lch_rptstruct;
end;
declare cursor lch_rptformula is select rptformula.rptformulaid ID from rptformula where  rptformula.InstanceID = arowid;
ROW_rptformula  lch_rptformula%ROWTYPE;
begin
--open lch_rptformula;
for row_rptformula in lch_rptformula loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from rptformula where rptformulaid=row_rptformula.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_rptformula;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_rptformula;
     return;
   end if; 
 end if; 
 rptformula_HCL (acursession,ROW_rptformula.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_rptformula;
   return;
 end if;
 end loop;
--close lch_rptformula;
end;
declare cursor lch_reports is select reports.reportsid ID from reports where  reports.InstanceID = arowid;
ROW_reports  lch_reports%ROWTYPE;
begin
--open lch_reports;
for row_reports in lch_reports loop
 select LockUserID,LockSessionID into aLockUserID,aLockSessionID from reports where reportsid=row_reports.id;
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_reports;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked:= 3; /* Lockes by another user */
     close lch_reports;
     return;
   end if; 
 end if; 
 reports_HCL (acursession,ROW_reports.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_reports;
   return;
 end if;
 end loop;
--close lch_reports;
end;
 end if;
aIsLocked:=0;
end;
procedure mtzrprt_propagate(acursession CHAR, aROWID CHAR) as  
aObjType  varchar2(255);
atmpStr  varchar2(255);
achildlistid CHAR(38);
assid CHAR(38);
begin
select  objtype into aObjType from instance where instanceid=aRowid;
if aobjtype = 'mtzrprt'
 then
 select securitystyleid into aSSID from instance where instanceid=aRowID;
declare cursor pch_rptstruct is select rptstruct.rptstructid id from rptstruct where  rptstruct.InstanceID = arowid;
row_rptstruct  pch_rptstruct%ROWTYPE;
begin
--open pch_rptstruct;
for row_rptstruct in  pch_rptstruct loop
 rptstruct_SINIT( acursession,row_rptstruct.id,assid);
 rptstruct_propagate( acursession,row_rptstruct.id);
end loop;
--close pch_rptstruct;
end;
declare cursor pch_rptformula is select rptformula.rptformulaid id from rptformula where  rptformula.InstanceID = arowid;
row_rptformula  pch_rptformula%ROWTYPE;
begin
--open pch_rptformula;
for row_rptformula in  pch_rptformula loop
 rptformula_SINIT( acursession,row_rptformula.id,assid);
 rptformula_propagate( acursession,row_rptformula.id);
end loop;
--close pch_rptformula;
end;
declare cursor pch_reports is select reports.reportsid id from reports where  reports.InstanceID = arowid;
row_reports  pch_reports%ROWTYPE;
begin
--open pch_reports;
for row_reports in  pch_reports loop
 reports_SINIT( acursession,row_reports.id,assid);
 reports_propagate( acursession,row_reports.id);
end loop;
--close pch_reports;
end;
 end if; 
end;


procedure rptstruct_BRIEF  (
 aCURSESSION CHAR,
 arptstructid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if arptstructid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from rptstruct where rptstructID=arptstructID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from rptstruct where rptstructid=arptstructID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=rptstruct');
    return;
  end if;
  aBRIEF:=func.rptstruct_BRIEF_F(arptstructid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure rptstruct_DELETE /*Секции*/ (
 aCURSESSION CHAR,
 arptstructid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from rptstruct where rptstructID=arptstructID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from rptstruct where rptstructid=arptstructID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:rptstruct',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=rptstruct');
      return;
    end if;
  end if;
 --  verify lock  --
 rptstruct_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;arptstructid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=rptstruct');
    return;
  end if;
  --begin tran--  
 -- erase child items --
-- delete in-struct child
    declare cursor child_rptfields is select rptfields.rptfieldsid ID from rptfields where  rptfields.ParentStructRowID = arptstructid;
    child_rptfields_rec  child_rptfields%ROWTYPE;
    begin
    --open child_rptfields;
      for child_rptfields_rec in child_rptfields loop
      rptfields_DELETE (acursession,child_rptfields_rec.id,aInstanceid);
      end loop;
      --close child_rptfields;
    end ;
declare cursor chld_rptstruct is select  instanceid ID from instance where OwnerPartName ='rptstruct' and OwnerRowID=arptstructid;
row_rptstruct  chld_rptstruct%ROWTYPE;
begin
--open chld_rptstruct;
for row_rptstruct in chld_rptstruct loop
 Kernel.INSTANCE_OWNER (acursession,row_rptstruct.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_rptstruct.id);
end loop;
--close chld_rptstruct;
end ;
  delete from  rptstruct 
  where  rptstructID = arptstructID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Секции*/
procedure rptstruct_SAVE /*Секции*/ (
 aCURSESSION CHAR,
 arptstructid CHAR,
aInstanceID CHAR 
, aParentRowid CHAR :=null
,aname
 VARCHAR2/* Название *//* Название */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from rptstruct where rptstructID=arptstructID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from rptstruct where rptstructid=arptstructID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:rptstruct',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=rptstruct');
      return;
    end if;
  end if;
 --  verify lock  --
 rptstruct_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;arptstructid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=rptstruct');
    return;
  end if;
 -- update row  --
 update  rptstruct set ChangeStamp=sysdate
,ParentRowid= aParentRowid
,
  name=aname
,
  caption=acaption
  where  rptstructID = arptstructID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:rptstruct',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=rptstruct');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=rptstruct');
    return;
  end if;
 insert into   rptstruct
 (  rptstructID 
,ParentRowid
,InstanceID
,name

,caption

 ) values ( arptstructID 
,aParentRowid
,aInstanceID
,aname

,acaption

 ); 
 rptstruct_SINIT( aCURSESSION,arptstructid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure rptstruct_PARENT /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from rptstruct where  rptstructid=aRowID;
 end; 

procedure rptstruct_ISLOCKED /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from rptstruct where rptstructid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  rptstruct_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzrprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure rptstruct_LOCK /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 rptstruct_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  rptstruct_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from rptstruct where rptstructid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=rptstruct');
    return;
  end if;
   if  aLockMode =2  
   then   
    update rptstruct set LockUserID =auserID ,LockSessionID =null where rptstructid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update rptstruct set LockUserID =null,LockSessionID =aCURSESSION  where rptstructid=aRowID;
     return;
   end if;
 end ;

procedure rptstruct_HCL /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
-- verify child locks
declare cursor lch_rptfields is select rptfields.rptfieldsid ID from rptfields where  rptfields.ParentStructRowID = aRowid;
row_rptfields lch_rptfields%ROWTYPE;
begin  
--open lch_rptfields;
for row_rptfields in lch_rptfields
loop
 select  LockUserID, LockSessionID into aLockUserID,aLockSessionID from rptfields where rptfieldsid=row_rptfields.id;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     close lch_rptfields;
     return;
   end if;  
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     close lch_rptfields;
     return;
   end if; 
 end if;  
 rptfields_HCL (acursession,row_rptfields.id,aisLocked);
 if aisLocked &gt;2 then
   close lch_rptfields;
   return;
 end if;
end loop;
--close lch_rptfields;
end;
aIsLocked :=0;
end;

procedure rptstruct_UNLOCK /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 rptstruct_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update rptstruct set LockUserID =null  where rptstructid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update rptstruct set LockSessionID =null  where rptstructid=aRowID;
     return;
   end if;
 end; 

procedure rptstruct_SINIT /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from rptstruct where rptstructid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =rptstruct');
    return;
  end if;
if aSecurityStyleID is null then
 rptstruct_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update rptstruct set securitystyleid =aStyleID where rptstructid = aRowID;
else 
 update rptstruct set securitystyleid =aSecurityStyleID where rptstructid = aRowID;
end if; 
end ; 

procedure rptstruct_propagate /*Секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from rptstruct where rptstructid=aRowid;
declare cursor pch_rptfields  is select rptfields.rptfieldsid ID from rptfields where  rptfields.ParentStructRowID = aRowid;
row_rptfields  pch_rptfields%ROWTYPE;
begin
--open pch_rptfields;
for row_rptfields in pch_rptfields loop
   rptfields_SINIT( acursession,row_rptfields.id,assid);
   rptfields_propagate( acursession,row_rptfields.id);
end loop;
--close pch_rptfields;
end;
end;


procedure rptfields_BRIEF  (
 aCURSESSION CHAR,
 arptfieldsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if arptfieldsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from rptfields where rptfieldsID=arptfieldsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from rptfields where rptfieldsid=arptfieldsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=rptfields');
    return;
  end if;
  aBRIEF:=func.rptfields_BRIEF_F(arptfieldsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure rptfields_DELETE /*Поля секции*/ (
 aCURSESSION CHAR,
 arptfieldsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from rptfields where rptfieldsID=arptfieldsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from rptfields where rptfieldsid=arptfieldsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:rptfields',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=rptfields');
      return;
    end if;
  end if;
 --  verify lock  --
 rptfields_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;arptfieldsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=rptfields');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_rptfields is select  instanceid ID from instance where OwnerPartName ='rptfields' and OwnerRowID=arptfieldsid;
row_rptfields  chld_rptfields%ROWTYPE;
begin
--open chld_rptfields;
for row_rptfields in chld_rptfields loop
 Kernel.INSTANCE_OWNER (acursession,row_rptfields.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_rptfields.id);
end loop;
--close chld_rptfields;
end ;
  delete from  rptfields 
  where  rptfieldsID = arptfieldsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Поля секции*/
procedure rptfields_SAVE /*Поля секции*/ (
 aCURSESSION CHAR,
 arptfieldsid CHAR,
aInstanceID CHAR 
, aParentStructRowID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,afieldtype CHAR/* Тип поля *//* Тип поля */
,afieldsize
 NUMBER := null /* Размер *//* Размер */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from rptfields where rptfieldsID=arptfieldsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from rptfields where rptfieldsid=arptfieldsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:rptfields',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=rptfields');
      return;
    end if;
  end if;
 --  verify lock  --
 rptfields_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;arptfieldsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=rptfields');
    return;
  end if;
 -- update row  --
 update  rptfields set ChangeStamp=sysdate
,
  name=aname
,
  fieldtype=afieldtype
,
  fieldsize=afieldsize
,
  caption=acaption
  where  rptfieldsID = arptfieldsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from rptstruct where rptstructid=aParentStructRowID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:rptfields',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=rptfields');
      return;
    end if;
 end if;
 rptstruct_ISLOCKED (acursession=&gt;acursession,aROWID=&gt;aParentStructRowID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=rptfields');
    return;
  end if;
 insert into   rptfields
 (  rptfieldsID 
,ParentStructRowID
,name

,fieldtype

,fieldsize

,caption

 ) values ( arptfieldsID 
,aParentStructRowID
,aname

,afieldtype

,afieldsize

,acaption

 ); 
 rptfields_SINIT( aCURSESSION,arptfieldsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure rptfields_PARENT /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  select ParentStructRowID into aParentID  from rptfields where  rptfieldsid=aRowID;
  aParentTable := 'rptstruct';
 end; 

procedure rptfields_ISLOCKED /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from rptfields where rptfieldsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  rptfields_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzrprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure rptfields_LOCK /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 rptfields_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  rptfields_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from rptfields where rptfieldsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=rptfields');
    return;
  end if;
   if  aLockMode =2  
   then   
    update rptfields set LockUserID =auserID ,LockSessionID =null where rptfieldsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update rptfields set LockUserID =null,LockSessionID =aCURSESSION  where rptfieldsid=aRowID;
     return;
   end if;
 end ;

procedure rptfields_HCL /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure rptfields_UNLOCK /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 rptfields_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update rptfields set LockUserID =null  where rptfieldsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update rptfields set LockSessionID =null  where rptfieldsid=aRowID;
     return;
   end if;
 end; 

procedure rptfields_SINIT /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from rptfields where rptfieldsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =rptfields');
    return;
  end if;
if aSecurityStyleID is null then
 rptfields_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update rptfields set securitystyleid =aStyleID where rptfieldsid = aRowID;
else 
 update rptfields set securitystyleid =aSecurityStyleID where rptfieldsid = aRowID;
end if; 
end ; 

procedure rptfields_propagate /*Поля секции*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from rptfields where rptfieldsid=aRowid;
end;


procedure rptformula_BRIEF  (
 aCURSESSION CHAR,
 arptformulaid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if arptformulaid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from rptformula where rptformulaID=arptformulaID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from rptformula where rptformulaid=arptformulaID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=rptformula');
    return;
  end if;
  aBRIEF:=func.rptformula_BRIEF_F(arptformulaid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure rptformula_DELETE /*Формулы*/ (
 aCURSESSION CHAR,
 arptformulaid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from rptformula where rptformulaID=arptformulaID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from rptformula where rptformulaid=arptformulaID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:rptformula',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=rptformula');
      return;
    end if;
  end if;
 --  verify lock  --
 rptformula_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;arptformulaid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=rptformula');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_rptformula is select  instanceid ID from instance where OwnerPartName ='rptformula' and OwnerRowID=arptformulaid;
row_rptformula  chld_rptformula%ROWTYPE;
begin
--open chld_rptformula;
for row_rptformula in chld_rptformula loop
 Kernel.INSTANCE_OWNER (acursession,row_rptformula.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_rptformula.id);
end loop;
--close chld_rptformula;
end ;
  delete from  rptformula 
  where  rptformulaID = arptformulaID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Формулы*/
procedure rptformula_SAVE /*Формулы*/ (
 aCURSESSION CHAR,
 arptformulaid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,acode VARCHAR2 := null /* Выражение *//* Выражение */
,aplatform CHAR := null /* Платформа *//* Платформа */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from rptformula where rptformulaID=arptformulaID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from rptformula where rptformulaid=arptformulaID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:rptformula',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=rptformula');
      return;
    end if;
  end if;
 --  verify lock  --
 rptformula_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;arptformulaid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=rptformula');
    return;
  end if;
 -- update row  --
 update  rptformula set ChangeStamp=sysdate
,
  name=aname
,
  code=acode
,
  platform=aplatform
  where  rptformulaID = arptformulaID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:rptformula',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=rptformula');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=rptformula');
    return;
  end if;
 insert into   rptformula
 (  rptformulaID 
,InstanceID
,name

,code

,platform

 ) values ( arptformulaID 
,aInstanceID
,aname

,acode

,aplatform

 ); 
 rptformula_SINIT( aCURSESSION,arptformulaid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure rptformula_PARENT /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from rptformula where  rptformulaid=aRowID;
 end; 

procedure rptformula_ISLOCKED /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from rptformula where rptformulaid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  rptformula_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzrprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure rptformula_LOCK /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 rptformula_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  rptformula_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from rptformula where rptformulaid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=rptformula');
    return;
  end if;
   if  aLockMode =2  
   then   
    update rptformula set LockUserID =auserID ,LockSessionID =null where rptformulaid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update rptformula set LockUserID =null,LockSessionID =aCURSESSION  where rptformulaid=aRowID;
     return;
   end if;
 end ;

procedure rptformula_HCL /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure rptformula_UNLOCK /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 rptformula_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update rptformula set LockUserID =null  where rptformulaid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update rptformula set LockSessionID =null  where rptformulaid=aRowID;
     return;
   end if;
 end; 

procedure rptformula_SINIT /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from rptformula where rptformulaid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =rptformula');
    return;
  end if;
if aSecurityStyleID is null then
 rptformula_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update rptformula set securitystyleid =aStyleID where rptformulaid = aRowID;
else 
 update rptformula set securitystyleid =aSecurityStyleID where rptformulaid = aRowID;
end if; 
end ; 

procedure rptformula_propagate /*Формулы*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from rptformula where rptformulaid=aRowid;
end;


procedure reports_BRIEF  (
 aCURSESSION CHAR,
 areportsid CHAR,
 aBRIEF out varchar2
) as 
 aaccess integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 existsCnt integer;
begin
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
if areportsid is null then aBRIEF:=''; return; end if;
 -- Brief body -- 
select count(*)into existsCnt from reports where reportsID=areportsID;
if existsCnt &gt;0
 then
 --  verify access  --
 select  SecurityStyleID into atmpid from reports where reportsid=areportsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'BRIEF',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'No access for BRIEF Structure=reports');
    return;
  end if;
  aBRIEF:=func.reports_BRIEF_F(areportsid);
else
  aBRIEF:= 'неверный идентификатор';
end if;
 aBRIEF:=substr(aBRIEF,1,255);
end; 

procedure reports_DELETE /*Описание*/ (
 aCURSESSION CHAR,
 areportsid CHAR,
 ainstanceid char
) as 
 aaccess integer;
 aSysInstID CHAR(38);
 atmpID CHAR(38);
 existsCnt integer;
 aChildListid CHAR(38);
  begin  
 select  Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0 then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
end if;
 -- Delete body -- 
select count(*) into existsCnt from reports where reportsID=areportsID;
if existsCnt &gt;0 then
 --  verify access  --
 select   SecurityStyleID into atmpID from reports where reportsid=areportsID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW',aaccess=&gt;aaccess ) ;
 if aaccess=0 then 
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'DELETEROW:reports',aaccess=&gt;aaccess); 
    if aaccess=0 then
      raise_application_error(-20000,'Нет прав на удаление. Раздел=reports');
      return;
    end if;
  end if;
 --  verify lock  --
 reports_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;areportsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем. Раздел=reports');
    return;
  end if;
  --begin tran--  
 -- erase child items --
declare cursor chld_reports is select  instanceid ID from instance where OwnerPartName ='reports' and OwnerRowID=areportsid;
row_reports  chld_reports%ROWTYPE;
begin
--open chld_reports;
for row_reports in chld_reports loop
 Kernel.INSTANCE_OWNER (acursession,row_reports.id,null,null);
 Kernel.INSTANCE_DELETE (acursession,row_reports.id);
end loop;
--close chld_reports;
end ;
  delete from  reports 
  where  reportsID = areportsID; 
 end if;
 -- close transaction --
 &lt;&lt;del_error&gt;&gt;
 existsCnt:=0;
end;

/*Описание*/
procedure reports_SAVE /*Описание*/ (
 aCURSESSION CHAR,
 areportsid CHAR,
aInstanceID CHAR 
,aname
 VARCHAR2/* Название *//* Название */
,areportfile VARCHAR2 := null /* Файл отчета */
,areportfile_EXT varchar2 /* Файл отчета */
,acaption
 VARCHAR2 := null /* Заголовок *//* Заголовок */
,apreparemethod CHAR := null /* Метод для формирования *//* Метод для формирования */
,areporttype
 NUMBER/* Тип отчета *//* Тип отчета */
,athereportext CHAR := null /* Расширение для создания отчета *//* Расширение для создания отчета */
,areportview
 VARCHAR2 := null /* Базовый запрос *//* Базовый запрос */
,athecomment VARCHAR2 := null /* Описание *//* Описание */
) as 
 aUniqueRowCount integer;
 atmpStr varchar2(255);
 atmpID CHAR(38);
 aaccess int;
 aSysInstID CHAR(38);
 existsCnt integer;
 begin  
 select Instanceid into aSysInstID from instance where objtype=lower('MTZSYSTEM');
 -- checking the_session  --
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt =0 
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 -- Insert / Update body -- 
select count(*) into existsCnt from reports where reportsID=areportsID;
if existsCnt &gt;0
 then
 --  UPDATE  --
 --  verify access  --
 select SecurityStyleID into atmpID from reports where reportsid=areportsID;
 CheckVerbRight( acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'EDITROW:reports',aaccess=&gt;aaccess ); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на модификацию. Раздел=reports');
      return;
    end if;
  end if;
 --  verify lock  --
 reports_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;areportsid,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=reports');
    return;
  end if;
 -- update row  --
 update  reports set ChangeStamp=sysdate
,
  name=aname
,
  reportfile=areportfile
,reportfile_EXT=
areportfile_EXT 
,
  caption=acaption
,
  preparemethod=apreparemethod
,
  reporttype=areporttype
,
  thereportext=athereportext
,
  reportview=areportview
,
  thecomment=athecomment
  where  reportsID = areportsID; 
 -- checking unique constraints  --


 else
 --  INSERT  --
 --  verify access  --
 select  SecurityStyleID into atmpID from instance where instanceid=ainstanceid;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW',aaccess=&gt;aaccess );
 if aaccess=0 
  then
    CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'CREATEROW:reports',aaccess=&gt;aaccess); 
    if aaccess=0 
    then
      raise_application_error(-20000,'Нет прав на создание строк. Раздел=reports');
      return;
    end if;
 end if;
 MTO.Kernel.instance_ISLOCKED( acursession=&gt;acursession,aROWID=&gt;aInstanceID,aIsLocked=&gt;aaccess); 
 if aaccess&gt;2 
  then
    raise_application_error(-20000,'Строка заблокирована другим пльзователем. Раздел=reports');
    return;
  end if;
select Count(*) into existsCnt from reports where 
InstanceID=aInstanceID;
if existsCnt &gt;0 
 then
    raise_application_error(-20000,'Невозможно создать вторую строку в однострочной сессии. Раздел: &lt;reports&gt;');
    return;
 End if;
 insert into   reports
 (  reportsID 
,InstanceID
,name

,reportfile

,reportfile_EXT
,caption

,preparemethod

,reporttype

,thereportext

,reportview

,thecomment

 ) values ( areportsID 
,aInstanceID
,aname

,areportfile

,areportfile_EXT
,acaption

,apreparemethod

,areporttype

,athereportext

,areportview

,athecomment

 ); 
 reports_SINIT( aCURSESSION,areportsid,atmpid);
 -- checking unique constraints  --


 end if;
 -- close transaction --
 end; 

procedure reports_PARENT /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aParentID out CHAR ,
 aParentTable out varchar2
) as 
existsCnt integer;
 begin  
 -- checking the_session  --
select count(*)into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
  aParentTable := 'INSTANCE';
  select  INSTANCEID into aParentID from reports where  reportsid=aRowID;
 end; 

procedure reports_ISLOCKED /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 aParentTable varchar2(255); 
 existsCnt integer; 
  astr varchar2(4000);
begin
 aisLocked := 0;
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 select  LockUserID,LockSessionID into aLockUserID, aLockSessionID from reports where reportsid=aRowID;
 /* verify this row */
 if not aLockUserID is null  
 then   
   if  aLockUserID &lt;&gt; auserID  
   then   
     aisLocked := 4; /* CheckOut by another user */
     return;
   else 
     aisLocked := 2; /* CheckOut by caller */
     return;
   end  if; 
 end if;  
 if not aLockSessionID is null  
 then   
   if  aLockSessionID &lt;&gt; aCURSESSION  
   then   
     aisLocked := 3; /* Lockes by another user */
     return;
   else 
     aisLocked := 1; /* Locked by caller */
     return;
   end if;  
 end if;  
 aisLocked := 0; 
  reports_parent (aCURSESSION,aROWID,aParentID,aParentTable);
  if aparenttable='INSTANCE' then
      astr := 'begin Kernel.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    Else
      astr := 'begin mtzrprt.' || aPARENTTABLE || '_islocked (:1,:2,:3); end;';
    end if;
  execute immediate  astr using aCURSESSION,aParentID ,out aISLocked;
 end; 

procedure reports_LOCK /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aLockMode integer 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 atmpID CHAR(38);
 aaccess integer;
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer; 
 begin  
 select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0;
 -- checking the_session  --
if existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserid from  the_session where the_sessionid=acursession;
 reports_ISLOCKED (aCURSESSION,aROWID,aISLocked );
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблокирована другим пользователем');
    return;
  end if;
 if aIsLocked =0  
 then
  reports_HCL (acursession,aRowID,aisLocked);
  if aIsLocked &gt;=3  
  then
     raise_application_error(-20000,'У данной строки имеются дочерние строки, которые заблокированы другим пользователем');
     return;
   end if;
 end if;
 select  SecurityStyleID into atmpID from reports where reportsid=aROWID;
 CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'LOCKROW',aaccess=&gt;aaccess); 
 if aaccess=0 
 then
    raise_application_error(-20000,'Нет прав на блокировку строк. Раздел=reports');
    return;
  end if;
   if  aLockMode =2  
   then   
    update reports set LockUserID =auserID ,LockSessionID =null where reportsid=aRowID;
     return;
   end if;
   if  aLockMode =1  
   then   
    update reports set LockUserID =null,LockSessionID =aCURSESSION  where reportsid=aRowID;
     return;
   end if;
 end ;

procedure reports_HCL /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aIsLocked out integer
) as 
achildlistid CHAR(38);
 aUserID CHAR(38);
 aLockUserID CHAR(38);
 aLockSessionID CHAR(38);
 begin  
 select usersid into auserID from the_session where the_sessionid=acursession;
aIsLocked :=0;
end;

procedure reports_UNLOCK /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR 
) as 
 aParentID CHAR(38);
 aUserID CHAR(38);
 aIsLocked integer;
 aParentTable varchar2(255); 
 existsCnt integer;
 begin  
 -- checking the_session  --
select count(*) into existsCnt from the_session where the_sessionid=acursession and closed=0 ;
if  existsCnt=0
  then
    raise_application_error(-20000,'Сессия уже завершена.');
    return;
  end if;
 select usersid into auserID from the_session where the_sessionid=acursession;
 reports_ISLOCKED( aCURSESSION,aROWID,aISLocked);
 if aIsLocked &gt;=3  
  then
    raise_application_error(-20000,'Строка заблоирована другим пользователем');
    return;
  end if;
   if  aIsLocked =2  
   then   
    update reports set LockUserID =null  where reportsid=aRowID;
     return;
   end if;
   if  aIsLocked =1  
   then   
    update reports set LockSessionID =null  where reportsid=aRowID;
     return;
   end if;
 end; 

procedure reports_SINIT /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR ,
 aSecurityStyleID CHAR
) as 
 aParentID CHAR(38);
 aParentTable varchar2(255); 
 aStr varchar2(4000);
 aStyleID CHAR(38);
 atmpID CHAR(38);
 aaccess integer; 
begin
 select  SecurityStyleID into atmpID from reports where reportsid=aROWID;
  CheckVerbRight (acursession=&gt;acursession,aThe_Resource=&gt;atmpID,averb=&gt;'SECURE',aaccess=&gt;aaccess); 
 if aaccess=0 
  then
    raise_application_error(-20000,'Нет прав на управление защитой. Раздел =reports');
    return;
  end if;
if aSecurityStyleID is null then
 reports_parent( aCURSESSION,aROWID,aParentID ,aParentTable);
  astr:= 'select SecurityStyleID  from ' || aParentTable || ' where ' ||aParentTable || 'id=:1' ;
  execute immediate astr into aStyleID using aParentid;
 update reports set securitystyleid =aStyleID where reportsid = aRowID;
else 
 update reports set securitystyleid =aSecurityStyleID where reportsid = aRowID;
end if; 
end ; 

procedure reports_propagate /*Описание*/ (
 aCURSESSION CHAR,
 aRowID CHAR
) as 
achildlistid CHAR(38);
aSSID CHAR(38);
begin
select securityStyleid into aSSID from reports where reportsid=aRowid;
end;
end mtzrprt;
/
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
  <ModuleHolder ModuleName="--Init" File="">
    <BlockHolder BlockName="--body" BlockCode=" 

create or replace procedure InitBase as 
aid CHAR(38);
ainstid CHAR(38);
auid CHAR(38);
aSESSION CHAR(38);
acid CHAR(38);
asecid CHAR(38);
ahid CHAR(38);
atmpstr varchar2(255);
begin
ainstid := '{EE28F9E4-AFE3-44E9-8FEF-411E81913423}';
auid := '{38DEF86A-191E-49A8-963B-63E0C94F4F99}'; 
asecid := '{993DAAFD-589E-480D-97FF-1F9AB0568800}'; --user security instance 
ahid := '{27F56741-4140-4C9C-909B-446ECA089409}'; -- helper id
delete from typelist;
delete from sysoptions;
BEGIN
insert into instance(InstanceID, OBJTYPE, Name) values(ainstid, lower('MTZSYSTEM'),'Системная информация');
Exception
End;
BEGIN
insert into instance(InstanceID,OBJTYPE,Name) values(asecid, lower('mtzusers'), 'Пользователи и группы');
Exception
End;
BEGIN
delete from users where login='supervisor';
Exception
End;
BEGIN
insert into users(usersid,instanceid,login,password,name) values('{76CF54C1-4BF0-4F1E-AE49-035C433782D7}',asecid,'supervisor','bami','Администратор');
Exception
End;
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzmetamodel', 'mtzmetamodel_DELETE', 'mtzmetamodel_HCL', 'mtzmetamodel_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzjrnl', 'mtzjrnl_DELETE', 'mtzjrnl_HCL', 'mtzjrnl_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'tod', 'tod_DELETE', 'tod_HCL', 'tod_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'stdinfostore', 'stdinfostore_DELETE', 'stdinfostore_HCL', 'stdinfostore_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzsystem', 'mtzsystem_DELETE', 'mtzsystem_HCL', 'mtzsystem_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzwp', 'mtzwp_DELETE', 'mtzwp_HCL', 'mtzwp_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'roles', 'roles_DELETE', 'roles_HCL', 'roles_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'tosched', 'tosched_DELETE', 'tosched_HCL', 'tosched_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'totrn', 'totrn_DELETE', 'totrn_HCL', 'totrn_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'totask', 'totask_DELETE', 'totask_HCL', 'totask_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzusers', 'mtzusers_DELETE', 'mtzusers_HCL', 'mtzusers_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'toop', 'toop_DELETE', 'toop_HCL', 'toop_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'stdnumerator', 'stdnumerator_DELETE', 'stdnumerator_HCL', 'stdnumerator_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'tor', 'tor_DELETE', 'tor_HCL', 'tor_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzext', 'mtzext_DELETE', 'mtzext_HCL', 'mtzext_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'tocard', 'tocard_DELETE', 'tocard_HCL', 'tocard_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'toimg', 'toimg_DELETE', 'toimg_HCL', 'toimg_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtz2job', 'mtz2job_DELETE', 'mtz2job_HCL', 'mtz2job_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzfltr', 'mtzfltr_DELETE', 'mtzfltr_HCL', 'mtzfltr_propagate');
insert into typelist( typelistid,name,DeleteProc, HCLProc, propagateProc) values(newid(),'mtzrprt', 'mtzrprt_DELETE', 'mtzrprt_HCL', 'mtzrprt_propagate');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{A9D13DB7-F13B-4C78-8790-D263D5A970ED}', aName=&gt;'genpackage', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{D81BAEF1-B6A2-4441-A861-A9F66293163D}', aName=&gt;'generator_target', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{69C879E6-5803-4F66-B9B0-AE4347C53CE1}', aName=&gt;'generator_target', aValue=&gt;'genpackage', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{DEF245DA-30AE-4A76-B58D-32C8D11B60D7}', aName=&gt;'genreference', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{2D00C138-719A-47DE-B7A0-69689E240659}', aName=&gt;'genreference', aValue=&gt;'generator_target', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{ECE9F87C-B4F5-44DD-B5E3-159089332D53}', aName=&gt;'genmanualcode', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{23B0C317-14DA-473D-B1AD-99EFC84CD196}', aName=&gt;'genmanualcode', aValue=&gt;'generator_target', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{A7E7647C-4B0B-4952-ACFE-251F6D2B1604}', aName=&gt;'gencontrols', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{FF8DE6AD-1024-4884-9EF3-D0C7A32EAD1B}', aName=&gt;'gencontrols', aValue=&gt;'generator_target', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{5426F592-E8D2-44C1-8CEF-F6FECC621FDA}', aName=&gt;'genpackage', aValue=&gt;'autogenpackage', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{3A47DE37-B043-4277-A9B3-6D7AE228B78D}', aName=&gt;'generator_target', aValue=&gt;'autogenerator_target', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{8A630815-287F-4EBB-8574-2398F019013D}', aName=&gt;'genreference', aValue=&gt;'autogenreference', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{63DF4844-E5FD-4F87-9476-FE864FCE7848}', aName=&gt;'genmanualcode', aValue=&gt;'autogenmanualcode', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{BFB66CB3-20A0-439A-A5DA-D78C5E6D123D}', aName=&gt;'gencontrols', aValue=&gt;'autogencontrols', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{878DA760-09BE-40A7-B2CB-CB14224EDF20}', aName=&gt;'localizeinfo', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{7F65D271-5E3A-4BE8-92D2-D26C56E35F94}', aName=&gt;'localizeinfo', aValue=&gt;'autolocalizeinfo', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{5DB0073F-4A8D-478C-9DF2-4ACF5F17D89A}', aName=&gt;'fieldtype', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{0BC965E3-9AF9-4DD6-AE61-0419D2816CD8}', aName=&gt;'enumitem', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{64BC9DDD-A6EB-44B1-8196-F4756B5E64AD}', aName=&gt;'enumitem', aValue=&gt;'fieldtype', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{C22B384B-3A33-4B0D-9875-6E073676323F}', aName=&gt;'fieldtypemap', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{03651B0F-A732-419A-B858-87CF253946ED}', aName=&gt;'fieldtypemap', aValue=&gt;'fieldtype', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{4751F190-6B1D-48E2-8B7F-B50ADC81DBD3}', aName=&gt;'fieldtype', aValue=&gt;'autofieldtype', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{2737248F-3E88-4602-990D-A345B3145BD0}', aName=&gt;'enumitem', aValue=&gt;'autoenumitem', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{2F8F5B56-77F4-45C3-9C5C-991677BF009C}', aName=&gt;'fieldtypemap', aValue=&gt;'autofieldtypemap', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{A68BFC42-BA0B-4E9F-B43C-C22F6A887134}', aName=&gt;'sharedmethod', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{521A778C-1D02-411A-8AF5-8971DEF082A7}', aName=&gt;'script', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{CFF65A38-FCCA-4F0B-A660-33D4A6388405}', aName=&gt;'script', aValue=&gt;'sharedmethod', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{CCB0FD7F-FB1D-4C6A-99C7-1A8565ABF123}', aName=&gt;'parameters', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{B9A1B232-BB94-462C-A984-DFD0C9C19FAE}', aName=&gt;'parameters', aValue=&gt;'script', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{48E60A2A-0D9C-4807-90A5-7093E6975C04}', aName=&gt;'sharedmethod', aValue=&gt;'autosharedmethod', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{BCEF53F0-9BEA-49FE-82C5-AEC66ABFE6A2}', aName=&gt;'script', aValue=&gt;'autoscript', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{1FA48BCD-3FBC-4760-9156-9FBB1678BABF}', aName=&gt;'parameters', aValue=&gt;'autoparameters', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{F581813E-CD46-4C2F-9827-CB5E6B76C7CA}', aName=&gt;'objecttype', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{4FABFE2F-72A8-469F-AC56-D48B4A1522CC}', aName=&gt;'objstatus', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D023571A-A8E7-4B20-A590-6C358A4BCFB1}', aName=&gt;'objstatus', aValue=&gt;'objecttype', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{15C360E1-62B0-40B0-8AF9-2888713FB658}', aName=&gt;'nextstate', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{11B239C9-DA07-4438-9BFD-7B47CC9E6D66}', aName=&gt;'nextstate', aValue=&gt;'objstatus', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FACCC759-7C6A-4A3A-A5B2-C9CE835E1C0A}', aName=&gt;'objectmode', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{18FFF991-EBB3-4B80-8514-53146D46F1D6}', aName=&gt;'objectmode', aValue=&gt;'objecttype', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{F436FD5F-8C76-4C7F-9A94-50536A58E3A4}', aName=&gt;'structrestriction', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{4FCFBE5B-A3C5-4799-86B5-CFDD78580A9A}', aName=&gt;'structrestriction', aValue=&gt;'objectmode', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{93C1B60F-1731-40F3-B88E-9F138E0DDDE8}', aName=&gt;'methodrestriction', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{BFB11F0E-A953-48FB-9C18-60ACAA0A43EA}', aName=&gt;'methodrestriction', aValue=&gt;'objectmode', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{12C3C0DC-294D-405F-9E19-9C4F59729084}', aName=&gt;'fieldrestriction', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{1C3CAB54-DD31-4C54-BA2F-6FF5E3439A42}', aName=&gt;'fieldrestriction', aValue=&gt;'objectmode', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{A49B593B-11C2-4ACF-87CF-9C1141CA4FD8}', aName=&gt;'typemenu', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{28093C41-690E-4755-B538-654B7806899D}', aName=&gt;'typemenu', aValue=&gt;'objecttype', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{F456EDEF-D69C-40EB-8902-C49B68855731}', aName=&gt;'instancevalidator', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{DE53E14C-DEB4-4EA0-8589-01AC3FC4016F}', aName=&gt;'instancevalidator', aValue=&gt;'objecttype', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{BD4CAD32-72D4-40A6-B8BF-E163E2DBD948}', aName=&gt;'part', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{3BDEB3AD-05E8-4DC1-8BED-8AEAECBF3360}', aName=&gt;'part', aValue=&gt;'objecttype', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{84C2925D-B29F-4479-8778-9A32AB18CE55}', aName=&gt;'partmenu', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{4561BD06-62D6-42F6-87D6-42045DD04BC3}', aName=&gt;'partmenu', aValue=&gt;'part', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{F80CDF54-74D5-4178-BD81-16ED99EB01CC}', aName=&gt;'partparammap', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{03BB5CBB-B464-45AD-A371-48CD9DC8DB8C}', aName=&gt;'partparammap', aValue=&gt;'partmenu', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{9A50C6FE-1548-4DE7-9ED8-DDC673B6C22C}', aName=&gt;'partview', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{7158EDA6-983D-4C44-810F-215384920D5E}', aName=&gt;'partview', aValue=&gt;'part', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{2B9A3AED-3B2C-4C48-8C15-954FD5996112}', aName=&gt;'viewcolumn', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{3097D9ED-29B8-4CC9-B414-62312D302A8E}', aName=&gt;'viewcolumn', aValue=&gt;'partview', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{1B0BAC13-FF9E-45B2-A7EE-E09C695157B2}', aName=&gt;'partview_lnk', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6D11A5B8-8103-4E6D-B9AB-E3D47CB362C5}', aName=&gt;'partview_lnk', aValue=&gt;'partview', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FF882C2F-13DF-4B54-A96D-1CCB78F75A04}', aName=&gt;'validator', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C906F847-6565-4078-BB5D-5E2679C670EE}', aName=&gt;'validator', aValue=&gt;'part', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{4E2D1673-A72A-4729-9688-A21B075EAD28}', aName=&gt;'uniqueconstraint', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{285BCC5D-DAD1-472A-8AA6-FAF06C684063}', aName=&gt;'uniqueconstraint', aValue=&gt;'part', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{1DCA18B0-78D0-4AF1-A8CC-E53846AFBA59}', aName=&gt;'constraintfield', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{203F5750-0E5D-4E2E-B74B-30C866A75E1F}', aName=&gt;'constraintfield', aValue=&gt;'uniqueconstraint', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{C63426E6-121C-41AB-B771-67AD3BC6D535}', aName=&gt;'extenderinterface', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C8ACC0A9-EBBF-4D3C-90BD-8B2AFF66AF1E}', aName=&gt;'extenderinterface', aValue=&gt;'part', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{C3BA4B0F-9DD3-40B3-80A3-B2E3846C70D5}', aName=&gt;'field', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{44642D93-5C69-4A02-BC7B-CADFC586D4B8}', aName=&gt;'field', aValue=&gt;'part', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{D86634DB-AB9F-4789-876D-9FBCEF1E274E}', aName=&gt;'fldextenders', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{A343B47E-D7E5-4217-A73C-2FFA67BB0879}', aName=&gt;'fldextenders', aValue=&gt;'field', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FF000879-3651-4C4C-8F43-CA89812BB074}', aName=&gt;'fieldsrcdef', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D24E7ACD-DCF9-45B0-BDA9-157B5638CB56}', aName=&gt;'fieldsrcdef', aValue=&gt;'field', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{B6173F3E-82D2-4E54-B7AC-D1D07D7AE9B6}', aName=&gt;'dinamicfilterscript', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{10A530EC-7BFD-48D9-A5B7-0E93AC164D45}', aName=&gt;'dinamicfilterscript', aValue=&gt;'field', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{34AE8B58-5BB7-44E3-A6C5-735223814596}', aName=&gt;'fieldexpression', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F95F1793-10A2-4C09-8384-FFE09844B2E5}', aName=&gt;'fieldexpression', aValue=&gt;'field', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{0754F72E-FE37-4D2D-BFEF-7A760821751E}', aName=&gt;'fieldvalidator', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{91E1FB7F-24A2-4587-9FF3-A6F306B104FE}', aName=&gt;'fieldvalidator', aValue=&gt;'field', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{F094185D-07E6-4433-927C-E8161D4C42C5}', aName=&gt;'fieldmenu', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{78DE4F4B-992F-472B-96CA-2CC506B8736D}', aName=&gt;'fieldmenu', aValue=&gt;'field', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{9DC705C9-3630-4121-AA63-E5C2ABBA055B}', aName=&gt;'fieldparammap', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{BE04BAAE-FDAA-4101-ACFB-203C213487A6}', aName=&gt;'fieldparammap', aValue=&gt;'fieldmenu', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{E34BC24D-E567-4776-A46C-F597BA854A43}', aName=&gt;'objecttype', aValue=&gt;'autoobjecttype', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C4ACC1EE-088A-4BBC-B31F-DAEAB956FD45}', aName=&gt;'objstatus', aValue=&gt;'autoobjstatus', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{1DB30AFB-201B-46AC-B989-65639140295E}', aName=&gt;'nextstate', aValue=&gt;'autonextstate', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{073EC315-0A87-4FB7-9842-CE60EE5B34F5}', aName=&gt;'objectmode', aValue=&gt;'autoobjectmode', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{A7A75DCE-6EAF-4464-BB5F-65E9D604C8A4}', aName=&gt;'structrestriction', aValue=&gt;'autostructrestriction', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{EF96F476-604E-4B0B-B5F9-AEC7EBFAF5D5}', aName=&gt;'methodrestriction', aValue=&gt;'automethodrestriction', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6298A72B-243B-433E-9851-20430408CC60}', aName=&gt;'fieldrestriction', aValue=&gt;'autofieldrestriction', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{48CEC391-5707-4A4A-A567-3DB25E66A9FE}', aName=&gt;'typemenu', aValue=&gt;'autotypemenu', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{7C3060DD-0785-4329-801E-0FE211DA8744}', aName=&gt;'instancevalidator', aValue=&gt;'autoinstancevalidator', aOptionType=&gt;'DEFVIEW');


MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{4F8B2F6C-1BE5-4AAA-9D61-5CD444BD2453}', aName=&gt;'partmenu', aValue=&gt;'autopartmenu', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F7C0CAA7-E6F6-4A1A-A5D0-20DEC6D849E0}', aName=&gt;'partparammap', aValue=&gt;'autopartparammap', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{5EC07EC3-7E3D-42E6-A488-EE26AF3FEABA}', aName=&gt;'partview', aValue=&gt;'autopartview', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{30E939D1-F2C6-4F22-911D-3BF182749BA2}', aName=&gt;'viewcolumn', aValue=&gt;'autoviewcolumn', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{3024745E-9CB6-400A-8645-CA1A7AA188BC}', aName=&gt;'partview_lnk', aValue=&gt;'autopartview_lnk', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{DFD78E23-86D9-4155-861A-47547EEE75C1}', aName=&gt;'validator', aValue=&gt;'autovalidator', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{B26F45FD-AF87-4C2D-A495-5E67B6AF0539}', aName=&gt;'uniqueconstraint', aValue=&gt;'autouniqueconstraint', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{93436F0F-74F5-4BFD-A0B5-726FA9C38785}', aName=&gt;'constraintfield', aValue=&gt;'autoconstraintfield', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{1AA6B319-2047-4C06-A794-7AC792B7F351}', aName=&gt;'extenderinterface', aValue=&gt;'autoextenderinterface', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{403870FE-C67B-4B80-A41B-9FA2D90EC81A}', aName=&gt;'field', aValue=&gt;'autofield', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{1628A775-A12F-4BC2-A777-D4688FA7D6BC}', aName=&gt;'fldextenders', aValue=&gt;'autofldextenders', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{37FBF961-D6D1-4012-B458-4DC7C27EE021}', aName=&gt;'fieldsrcdef', aValue=&gt;'autofieldsrcdef', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{66014338-36CD-485C-A8B9-01C2220E51E4}', aName=&gt;'dinamicfilterscript', aValue=&gt;'autodinamicfilterscript', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{EC4CDB72-FB5F-48D8-B98D-D28E9200633E}', aName=&gt;'fieldexpression', aValue=&gt;'autofieldexpression', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C02BAF6F-6238-414D-B527-5A7387772BDC}', aName=&gt;'fieldvalidator', aValue=&gt;'autofieldvalidator', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{54A54E33-31D3-46E1-BC4E-9AE9B60B6661}', aName=&gt;'fieldmenu', aValue=&gt;'autofieldmenu', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{A55E875A-6C71-4D07-AFB9-3580EC643380}', aName=&gt;'fieldparammap', aValue=&gt;'autofieldparammap', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{2C3BBA40-47CA-4377-84EC-D17262021159}', aName=&gt;'mtzapp', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{620BAFAC-5825-4B38-8697-57374889B729}', aName=&gt;'parentpackage', aValue=&gt;'mtzmetamodel', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{45543174-AF32-48C8-8BD9-3D59BA0D04CD}', aName=&gt;'parentpackage', aValue=&gt;'mtzapp', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{FB62E1A3-7B4F-4A3C-9ACA-CC1F92BDF540}', aName=&gt;'mtzapp', aValue=&gt;'automtzapp', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F6BE89BD-0D15-455C-AD1B-708F0F942F39}', aName=&gt;'parentpackage', aValue=&gt;'autoparentpackage', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{7C845CE4-6B84-4664-AB30-1472BD5FF0F7}', aName=&gt;'journalcolumn', aValue=&gt;'mtzjrnl', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FBB263A6-43E7-45D5-A484-76D05F2B8C99}', aName=&gt;'jcolumnsource', aValue=&gt;'mtzjrnl', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{180DBCCE-2730-42FF-B058-49271D147789}', aName=&gt;'jcolumnsource', aValue=&gt;'journalcolumn', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{BD57A1F5-A8C6-410E-8E41-BAE7CB35D007}', aName=&gt;'journalcolumn', aValue=&gt;'autojournalcolumn', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{92778E38-054C-465F-BED7-237654942DA9}', aName=&gt;'jcolumnsource', aValue=&gt;'autojcolumnsource', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{4BE6CFCB-CE9A-497F-8CE7-7CA155584D08}', aName=&gt;'journalsrc', aValue=&gt;'mtzjrnl', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{55AE0D69-6BB4-4F56-86B4-3E6833B0379F}', aName=&gt;'journalsrc', aValue=&gt;'autojournalsrc', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{AB57A1DF-91B6-4F49-9312-FF7C70EB8297}', aName=&gt;'journal', aValue=&gt;'mtzjrnl', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{32BA14DF-0464-4D77-88AC-5C6055A35C99}', aName=&gt;'journal', aValue=&gt;'autojournal', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{3E259E1F-9357-4D01-A9B7-9EC52DC5EB6E}', aName=&gt;'tod_factory', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{951285C5-873A-45B1-82CC-DAA6200EA6F6}', aName=&gt;'tod_factory', aValue=&gt;'autotod_factory', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{CC6566D2-94E7-40DC-9B5C-05DC0C833585}', aName=&gt;'tod_bug', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{04BD5DB3-0954-4DE5-A693-F1A405C8D240}', aName=&gt;'tod_bug', aValue=&gt;'autotod_bug', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{8EF29A11-F54E-45E9-969A-F5EDAC94F862}', aName=&gt;'tod_building', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D23E8AEA-9F4A-43F5-B1B1-EA4DD5DBB5C5}', aName=&gt;'tod_building', aValue=&gt;'autotod_building', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{E2335880-FB65-4E13-B33B-7E717D703949}', aName=&gt;'tod_valtype', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{8EA045AD-4B99-4204-89EC-56D12B004B00}', aName=&gt;'tod_valtype', aValue=&gt;'autotod_valtype', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{6931534F-7A9C-4E34-BC24-C0A036226CC6}', aName=&gt;'tod_model', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{EF51E3F5-C31F-4AB3-BF51-9A0422932F6E}', aName=&gt;'tod_model', aValue=&gt;'autotod_model', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{CC4B5DCE-88F7-43F9-84AF-0E67C09D787F}', aName=&gt;'tod_system', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{A3BA7BCA-A008-44D0-9A80-0CE0A6C36431}', aName=&gt;'tod_system', aValue=&gt;'autotod_system', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{CAD08B8D-4005-42E8-90D8-0ED5408B6C87}', aName=&gt;'tod_oprole', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{18373F82-EA1E-4407-B9C6-93E18BCCFDA5}', aName=&gt;'tod_oprole', aValue=&gt;'autotod_oprole', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{706145A0-0ED8-4670-9AAF-9F35B9966E6D}', aName=&gt;'tod_trand', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{9DB53D0F-9D5B-470B-855E-185F32027DDC}', aName=&gt;'tod_trand', aValue=&gt;'autotod_trand', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{178247B4-B2D2-4A38-BBE6-55EC3FC5EFF6}', aName=&gt;'tod_st', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{8B6F63C7-153A-4B2C-B755-EA9349A0AE27}', aName=&gt;'tod_st', aValue=&gt;'autotod_st', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{C003564C-BDCD-4D75-9D77-48AF358FB8A3}', aName=&gt;'tod_material', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{A013F4C1-988B-4E31-9A36-75F6BABA77AB}', aName=&gt;'tod_material', aValue=&gt;'autotod_material', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{A9DC90D3-2997-4BC0-A823-BB4237B546F8}', aName=&gt;'tod_edizm', aValue=&gt;'tod', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{CE77D0DE-81D8-40A8-8178-030CE6442DFD}', aName=&gt;'tod_edizm', aValue=&gt;'autotod_edizm', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{D3A9465E-0B96-4B53-9A81-A55DD5219A41}', aName=&gt;'folder', aValue=&gt;'stdinfostore', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{16D22D31-CD6B-4482-AEB5-8D82F3D57C6D}', aName=&gt;'shortcut', aValue=&gt;'stdinfostore', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{36863CD4-5018-4C38-8932-00CDA55EC264}', aName=&gt;'shortcut', aValue=&gt;'folder', aOptionType=&gt;'PARENT');


MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6A9D8F8E-8F0A-4D5C-ABEE-4F3A653D33AD}', aName=&gt;'shortcut', aValue=&gt;'autoshortcut', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{997E508B-A0CF-4DAF-B004-DF3922113BBA}', aName=&gt;'infostoredef', aValue=&gt;'stdinfostore', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{B39C5A67-E3DF-4ADE-8FCE-A3FA569677C8}', aName=&gt;'infostoredef', aValue=&gt;'autoinfostoredef', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{B2FC3435-1965-420C-A428-2929308447AC}', aName=&gt;'the_session', aValue=&gt;'mtzsystem', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D2B45E08-4D04-4285-970A-123D3AC6C9D6}', aName=&gt;'the_session', aValue=&gt;'autothe_session', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{C2913043-21D1-472A-AD50-02D5FC03AFE7}', aName=&gt;'sysrefcache', aValue=&gt;'mtzsystem', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{4FC37F53-3D12-4D75-9E20-2EFAD88BD726}', aName=&gt;'sysrefcache', aValue=&gt;'autosysrefcache', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{D848F6D2-2959-43CE-8F64-7155AE119A05}', aName=&gt;'syslog', aValue=&gt;'mtzsystem', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{0E1B575E-2C5F-43E6-A601-EEA8AE0BDB84}', aName=&gt;'syslog', aValue=&gt;'autosyslog', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{194DB352-47C6-46B4-9605-42EA3807EE16}', aName=&gt;'armjournal', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FE4B2823-20F3-4AF3-BEB9-B1290971C284}', aName=&gt;'armjrnlrep', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F3DCF7BB-B9D8-421E-9399-5E77BFF2678A}', aName=&gt;'armjrnlrep', aValue=&gt;'armjournal', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{118BFA22-6D43-4E12-B596-F7117EC035E5}', aName=&gt;'armjrnlrun', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{8B8391E4-837C-4A3D-9547-838D115D13AA}', aName=&gt;'armjrnlrun', aValue=&gt;'armjournal', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{2F39B9C7-3510-4682-89DA-749056AA2688}', aName=&gt;'armjrnladd', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6D00C414-7C25-4CF7-9208-C2D0D601CF23}', aName=&gt;'armjrnladd', aValue=&gt;'armjournal', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{7BD62CDB-F734-4F2C-A2A6-72A30CDE9D47}', aName=&gt;'armjournal', aValue=&gt;'autoarmjournal', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{80199746-6C06-4674-847C-6828F00652EC}', aName=&gt;'armjrnlrep', aValue=&gt;'autoarmjrnlrep', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{FA1808F4-6F2E-40B5-BFD0-BAD6A1520C84}', aName=&gt;'armjrnlrun', aValue=&gt;'autoarmjrnlrun', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6FC80045-40F9-40AA-A95E-F6227C63D3EE}', aName=&gt;'armjrnladd', aValue=&gt;'autoarmjrnladd', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{0ADF47A1-6F9F-4E86-983F-20046C09A8DE}', aName=&gt;'entrypoints', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{230BAA26-A354-4A3C-B07D-FBF422AD4F16}', aName=&gt;'epfilterlink', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6E717F09-9BC8-46EE-A656-6581A8B3B353}', aName=&gt;'epfilterlink', aValue=&gt;'entrypoints', aOptionType=&gt;'PARENT');


MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D17B23AA-FF06-4CD6-BF68-523814DF248C}', aName=&gt;'epfilterlink', aValue=&gt;'autoepfilterlink', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{4BEC1F9B-89FC-41D8-88CB-A953FA4E706C}', aName=&gt;'workplace', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{0A1581D2-8C2D-4E9B-81E5-CF432E28F4AA}', aName=&gt;'workplace', aValue=&gt;'autoworkplace', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{B84FA687-1AE4-4CC6-8157-1D259FE9D894}', aName=&gt;'armtypes', aValue=&gt;'mtzwp', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{7E1F6AF9-EEE2-41E0-9D88-7E973C0F447A}', aName=&gt;'armtypes', aValue=&gt;'autoarmtypes', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{21A2A80C-899E-4381-9BB2-7E1ED9D84FD8}', aName=&gt;'roles_operations', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{624DA2E9-8044-441E-A8F9-8809F166B40B}', aName=&gt;'roles_operations', aValue=&gt;'autoroles_operations', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{CB908A72-EF66-43EF-88EA-0BAE1FF6C714}', aName=&gt;'roles_wp', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{F41B31CE-F68C-4A02-AFC1-9B41ECC7DBE1}', aName=&gt;'roles_act', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{90FE0D2F-69E9-43AB-9B57-022D6B3E1369}', aName=&gt;'roles_act', aValue=&gt;'roles_wp', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{DD9BEB01-73EB-4DF7-9B6F-E53EB5E8E3B4}', aName=&gt;'roles_wp', aValue=&gt;'autoroles_wp', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C6762489-98F1-4312-A443-D21C473A0575}', aName=&gt;'roles_act', aValue=&gt;'autoroles_act', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{8099F953-DF66-48B7-A621-66198141BBA9}', aName=&gt;'roles2_module', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{3A22CE1F-42EC-4DDC-9E33-24A46364651D}', aName=&gt;'roles2_modreport', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{92ED1ECA-16BA-4FD6-B1FF-E02B6CBBEA32}', aName=&gt;'roles2_modreport', aValue=&gt;'roles2_module', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{570109A6-9D0E-4976-8EDF-DDE17CD90AFD}', aName=&gt;'roles2_module', aValue=&gt;'autoroles2_module', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{17AF67E2-0CE0-48BF-A230-9C5CE7CC5BF1}', aName=&gt;'roles2_modreport', aValue=&gt;'autoroles2_modreport', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{12C13B65-EAE9-4F61-A8A2-E66F75822260}', aName=&gt;'roles_doc', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{D4E9CA69-304E-493D-97D1-83FEB49BAE68}', aName=&gt;'roles_doc_state', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{427C5AFD-4294-40F6-A9E9-2FC4B2B7B84F}', aName=&gt;'roles_doc_state', aValue=&gt;'roles_doc', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{59F58786-00B0-4933-8A5A-B0B19FC525DF}', aName=&gt;'roles_doc', aValue=&gt;'autoroles_doc', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{E8D2A965-C8F8-4F7E-810F-B4F6A7D17B8F}', aName=&gt;'roles_doc_state', aValue=&gt;'autoroles_doc_state', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{676B1DBF-6B24-4841-A24D-E5C5B8196392}', aName=&gt;'roles_reports', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{059D4E45-4D0A-4458-9B04-5124FA9FA0AE}', aName=&gt;'roles_reports', aValue=&gt;'autoroles_reports', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{BC2F1BC0-0065-4F1E-BC47-430471273162}', aName=&gt;'roles_user', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{391A3BD9-C18E-4C22-906B-BF2C7942F878}', aName=&gt;'roles_user', aValue=&gt;'autoroles_user', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{B02FB5AE-3561-4373-A894-7B95DA6CAB17}', aName=&gt;'roles_map', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{3812E086-765B-48E3-B6AF-FB6ABE49606E}', aName=&gt;'roles_map', aValue=&gt;'autoroles_map', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{2A48158E-8FC4-4B23-A771-AC50081CAB15}', aName=&gt;'roles_def', aValue=&gt;'roles', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{29699060-3902-4B05-9FF2-9B46DEF8E20E}', aName=&gt;'roles_def', aValue=&gt;'autoroles_def', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{EAB83160-3198-488B-982D-8CE665EF1CB2}', aName=&gt;'to_scheditems', aValue=&gt;'tosched', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{E95E08FA-8A2C-4D68-A3F1-4F12FAD0D2BA}', aName=&gt;'to_scheditems', aValue=&gt;'autoto_scheditems', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FFA28107-16B0-4DC1-9A2B-B6154E96CC75}', aName=&gt;'to_schedinfo', aValue=&gt;'tosched', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6DC74219-8B99-4D24-9AF0-E43BAA766B6B}', aName=&gt;'to_schedinfo', aValue=&gt;'autoto_schedinfo', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{707E06B4-A716-4C48-88BB-3A06B26C8FD9}', aName=&gt;'totrn_data', aValue=&gt;'totrn', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F7998677-AD4B-4785-8AA4-A8399C3EB924}', aName=&gt;'totrn_data', aValue=&gt;'autototrn_data', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{4289B753-1715-4321-9CDE-7D8B1001752A}', aName=&gt;'totrn_def', aValue=&gt;'totrn', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{4931B5CB-D7E9-40FE-9F42-7F4B9681A67E}', aName=&gt;'totrn_def', aValue=&gt;'autototrn_def', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{D4687E45-7E13-4234-8D75-83190DC338CD}', aName=&gt;'to_taskcomment', aValue=&gt;'totask', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{FEC6A7AD-C7EB-4005-AE06-7A3F58065F56}', aName=&gt;'to_taskcomment', aValue=&gt;'autoto_taskcomment', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{EED34482-E90C-48B8-8174-58C579101638}', aName=&gt;'to_taskinfo', aValue=&gt;'totask', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{726AD31F-933E-476E-9810-05A6AC5B0702}', aName=&gt;'to_taskinfo', aValue=&gt;'autoto_taskinfo', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{D574935F-9B72-4702-A08D-E7F634C108C0}', aName=&gt;'to_taskchecks', aValue=&gt;'totask', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{833C9874-B6EC-4D78-969A-E78604ACE38B}', aName=&gt;'to_taskcheckcomment', aValue=&gt;'totask', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{36646667-01D6-42F9-A3DB-36F8F8C18290}', aName=&gt;'to_taskcheckcomment', aValue=&gt;'to_taskchecks', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{17326CC8-4DC4-46D8-BE99-670920C874EC}', aName=&gt;'to_taskchecks', aValue=&gt;'autoto_taskchecks', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{5AC384C9-2889-4D8C-B262-910655EE87F2}', aName=&gt;'to_taskcheckcomment', aValue=&gt;'autoto_taskcheckcomment', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{B813870D-7D14-44C1-A423-7021580B7927}', aName=&gt;'users', aValue=&gt;'mtzusers', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{8D8A1043-79F0-42BD-8206-44CAD39C4B6E}', aName=&gt;'users', aValue=&gt;'autousers', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{837223EE-B845-4ACE-8B5F-91171AC54113}', aName=&gt;'groups', aValue=&gt;'mtzusers', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{6646062B-F137-4BBB-B687-43CD0AA269BC}', aName=&gt;'groupuser', aValue=&gt;'mtzusers', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{2C2CBB19-FE63-4FD5-B063-C72A374CB948}', aName=&gt;'groupuser', aValue=&gt;'groups', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{5A0212C9-2D5C-43D9-A89B-38733FD2767D}', aName=&gt;'groups', aValue=&gt;'autogroups', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{E1B16A7A-8E64-4DF6-9376-B17CFA9F1FD9}', aName=&gt;'groupuser', aValue=&gt;'autogroupuser', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{85BBA5E4-12EB-4358-8480-75F76CAF704B}', aName=&gt;'to_oper', aValue=&gt;'toop', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{37B914BA-FF1E-4F18-A9AD-D8DC4078AE4F}', aName=&gt;'to_oper', aValue=&gt;'autoto_oper', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FF6D2A9D-2BC7-4409-A249-86A512CFBA7A}', aName=&gt;'num_zones', aValue=&gt;'stdnumerator', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{E75AE0F3-ABA1-45FC-936A-AB4C66D7B9B0}', aName=&gt;'num_values', aValue=&gt;'stdnumerator', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{E035D06E-D06A-4DE3-B5FD-E2BEBF878C0A}', aName=&gt;'num_values', aValue=&gt;'num_zones', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{9C136F5F-B507-4E71-9DF0-F461AD10106C}', aName=&gt;'num_zones', aValue=&gt;'autonum_zones', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{A73165F9-9C5C-4083-8C98-5DB7CCC3096E}', aName=&gt;'num_values', aValue=&gt;'autonum_values', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{A7864253-A03F-416F-8605-E1FAFD21DF50}', aName=&gt;'num_head', aValue=&gt;'stdnumerator', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{544D77C6-484C-4E55-9DDD-7462CBCADDC2}', aName=&gt;'num_head', aValue=&gt;'autonum_head', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{B4B341E6-8F30-46E4-8A41-2658EB947E2B}', aName=&gt;'tor_info', aValue=&gt;'tor', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D59CCEA7-8907-4DBE-A53F-60226E8CF804}', aName=&gt;'tor_info', aValue=&gt;'autotor_info', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{446693CD-A19C-4DD8-8EEC-618D08363868}', aName=&gt;'mtzext_def', aValue=&gt;'mtzext', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{9D311DC7-0791-4C4E-B13F-6C26ECC9A605}', aName=&gt;'mtzext_def', aValue=&gt;'automtzext_def', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{B832CBC5-39EA-4B38-9E81-61AFA71196EC}', aName=&gt;'mtzextrel', aValue=&gt;'mtzext', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{8BE77482-D5C2-4B71-B32E-5279E431EA06}', aName=&gt;'mtzextrel', aValue=&gt;'automtzextrel', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{497D3461-A2D9-4F5C-93D4-5AC5BDDA9C76}', aName=&gt;'to_cardinfo', aValue=&gt;'tocard', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{12AAFB52-E033-42FB-B6A8-8B2B07DDD5FB}', aName=&gt;'to_cardinfo', aValue=&gt;'autoto_cardinfo', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{AF74157E-01FB-4C8C-882A-F5B47C9985AC}', aName=&gt;'to_cardchecks', aValue=&gt;'tocard', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{ED568579-91B4-44DF-87A9-2F2DE992E131}', aName=&gt;'to_carddevices', aValue=&gt;'tocard', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{3557CC04-92D9-4293-BF1A-F1DE40E438BF}', aName=&gt;'to_carddevices', aValue=&gt;'to_cardchecks', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{DF7F5BCC-3BFE-4DBF-A378-F49324213514}', aName=&gt;'to_cardchecks', aValue=&gt;'autoto_cardchecks', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F895633B-E12D-4A25-BE73-33B2B15F245A}', aName=&gt;'to_carddevices', aValue=&gt;'autoto_carddevices', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{E54E5A58-D916-42B8-873F-4884FD572FB0}', aName=&gt;'toimg_data', aValue=&gt;'toimg', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{4A6C9BA3-02F3-488E-8843-E32188765001}', aName=&gt;'toimg_data', aValue=&gt;'autotoimg_data', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{231EA516-1046-4B6F-8A5A-6BF8179A500F}', aName=&gt;'toimg_todelete', aValue=&gt;'toimg', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{B4679889-6C8D-4620-BB81-0880413A9EE0}', aName=&gt;'toimg_todelete', aValue=&gt;'autotoimg_todelete', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{53073E72-DDB4-479F-9B83-D97DF5CE4503}', aName=&gt;'toimg_def', aValue=&gt;'toimg', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{30762528-21E8-45C4-BA13-D58DE0CF8568}', aName=&gt;'toimg_def', aValue=&gt;'autotoimg_def', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{1CE5D5CF-0131-4021-8B8D-1EE4DD33D20A}', aName=&gt;'mtz2job_def', aValue=&gt;'mtz2job', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C39890D7-1971-4C51-A82B-68E272D757B3}', aName=&gt;'mtz2job_def', aValue=&gt;'automtz2job_def', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{1CE557BE-079F-45F3-B396-15CFEADF301B}', aName=&gt;'filterfieldgroup', aValue=&gt;'mtzfltr', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{983B20B6-6434-4210-A6CD-7F295015D8E6}', aName=&gt;'fileterfield', aValue=&gt;'mtzfltr', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D1A118C8-8BA1-45F2-9BC7-C4C3C4BF1A1E}', aName=&gt;'fileterfield', aValue=&gt;'filterfieldgroup', aOptionType=&gt;'PARENT');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{1A679ABA-25C4-4D43-977D-D3B66AFBFABA}', aName=&gt;'filterfieldgroup', aValue=&gt;'autofilterfieldgroup', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{ED5DDF5D-3468-49FD-9A9F-6BC231A24A42}', aName=&gt;'fileterfield', aValue=&gt;'autofileterfield', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{F2B0F140-0A02-4AF3-8F28-F58618C97903}', aName=&gt;'filters', aValue=&gt;'mtzfltr', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{52431265-ECFD-4AEF-9448-61A1BFCC8785}', aName=&gt;'filters', aValue=&gt;'autofilters', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{59BCF26D-E936-43BE-99D2-43661ADEA40C}', aName=&gt;'rptstruct', aValue=&gt;'mtzrprt', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{0A85B079-9344-4FBD-9E0C-B39B73D3491C}', aName=&gt;'rptfields', aValue=&gt;'mtzrprt', aOptionType=&gt;'STRUCT_TYPE');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{7F6E5609-1C3C-48E9-B918-1B73CBE83DDD}', aName=&gt;'rptfields', aValue=&gt;'rptstruct', aOptionType=&gt;'PARENT');


MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{74F86FD3-293C-4FEC-9067-56EFA66B3B54}', aName=&gt;'rptfields', aValue=&gt;'autorptfields', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{CB37665A-7455-4C13-9EB1-6CA15DB04D22}', aName=&gt;'rptformula', aValue=&gt;'mtzrprt', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{B4D571D2-7CC7-4BE7-8178-2A8B747A329E}', aName=&gt;'rptformula', aValue=&gt;'autorptformula', aOptionType=&gt;'DEFVIEW');

MTO.Kernel.SysOptions_SAVE  (aSysOptionsid=&gt;'{FB4B9F13-86F2-48B4-ACB0-4A07DD045342}', aName=&gt;'reports', aValue=&gt;'mtzrprt', aOptionType=&gt;'STRUCT_TYPE');

MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C44A43F2-E5A7-47AA-BF8F-30C74F0D284C}', aName=&gt;'reports', aValue=&gt;'autoreports', aOptionType=&gt;'DEFVIEW');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{539637C3-D2D1-4865-B1AD-794A7E151B2C}', aName=&gt;'9181AF0D-F0D0-4539-8CDB-67CDB500C41E', aValue=&gt;'GetFreeNumber', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{E3FE5890-3545-490C-B1FC-418BD2B92EA9}', aName=&gt;'2BB30818-90ED-4627-8ABB-85B3FBA46750', aValue=&gt;'VBNewPayOut', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{E7CEC5C9-5192-4FB3-80C7-374EB7EC81FE}', aName=&gt;'4FB59D1A-0123-47D3-9F4F-E12085C5D074', aValue=&gt;'VBUpdateItemName', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{57023316-B568-437E-946D-4CE073A6D8FF}', aName=&gt;'477B8D25-4FF7-491A-A0B0-D3437EC16957', aValue=&gt;'MakeNewFolderEC', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{7DFDE093-F450-4715-967A-F2BA9E9AEDC3}', aName=&gt;'42A1A436-8AA2-4F1F-999B-6680DFF514DE', aValue=&gt;'VBSaveHistory', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{0AD1C5E6-B6A5-4394-AEB6-A6F014C52907}', aName=&gt;'6FB1873A-45A9-420F-90CE-CDE34B5AEE19', aValue=&gt;'AutoCloseSession', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{0899ADBB-C6DB-496D-913C-33D31FDF1D1C}', aName=&gt;'61393545-ABF7-46F7-82F3-9B7E610DD9C0', aValue=&gt;'VBUpdateObjName', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C7316ABC-87F0-440A-BE14-BC5800E9CA83}', aName=&gt;'897D3B55-6599-42DB-AA1C-54BAB3D2F597', aValue=&gt;'GetNewNumber', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{24B0741E-8433-4C43-AF17-AE1DA675FE8D}', aName=&gt;'2B0CEE5C-7FFA-490D-9F5A-B5E8692551DD', aValue=&gt;'EraseNumber', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{5A77793B-21D6-4830-9311-EEDB61476B95}', aName=&gt;'73BE205E-F7EA-4A5A-A41F-85E25CA6511E', aValue=&gt;'SessionCheckPoint', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{EA50A102-E7E5-494E-B10C-FCCD5AD6EEE0}', aName=&gt;'A282DD68-9188-4C40-B0F2-BE69CAEE3DEA', aValue=&gt;'CheckVerbRight', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{1BE6D1F0-73BF-40C7-ADC6-D0103E148238}', aName=&gt;'68BD7F75-AD54-4837-A6A7-A8DDE3B2992A', aValue=&gt;'MTZLogin', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{213AB545-4C74-46AF-9A55-B2E227517CFB}', aName=&gt;'A2EEE876-54D8-4AED-B124-775F5DA2D911', aValue=&gt;'VBAddObjByRef', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{90E06CB3-8C51-4601-B737-2B7CCBAFE161}', aName=&gt;'73E7CF77-E6BA-42B4-A03B-4F67EEDEF4F1', aValue=&gt;'AdminUnlockAll', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{9A8960AD-3661-4E12-B070-CF86416D1273}', aName=&gt;'8D492A94-7078-4B7D-9847-AEFC27B4855D', aValue=&gt;'RowToInstance', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{98A3368C-1756-45B8-9E3B-26535557518B}', aName=&gt;'7929D795-41C5-4A5C-BFF2-A4E677A62143', aValue=&gt;'SessionTouch', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F278C815-FE38-4247-A36D-E537850813F5}', aName=&gt;'6C6E6DAA-5CD2-48C3-A2AA-A24539B45A49', aValue=&gt;'GetServerTime', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{9B051E18-B9D8-441C-80A9-CF19BEE9218C}', aName=&gt;'0C9985AF-27EE-4AD5-A564-635E0BFFC9D5', aValue=&gt;'TestNumber', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{F7798BBC-0BF3-4D0F-AA7E-A89DADC64370}', aName=&gt;'8D3B38B4-C4F9-45AC-8ECE-BF3BE39D8100', aValue=&gt;'Logout', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{19F3107B-7E6F-432A-B13F-E56B5282A943}', aName=&gt;'D8914FB4-6B5D-491A-A72F-985617727583', aValue=&gt;'WFFuncName', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{32E13266-9877-444C-9DFB-993836F87F5C}', aName=&gt;'074E33B9-1EC9-4AA1-8300-E98C73D55FE2', aValue=&gt;'Login', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{54D9EB25-C688-43F0-88FD-A57A943377FE}', aName=&gt;'D49A40B9-6174-4946-A81D-B7FE105C3546', aValue=&gt;'AdminUnlock', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{EAE0AB6F-62E4-4445-AA63-826EFA5AE219}', aName=&gt;'5B8FB7B9-D8B1-4CA0-90AF-55F83D1A6E5D', aValue=&gt;'VBMakeReport', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D3CC9CE8-FEBB-4F24-9687-C578ADA0FC4D}', aName=&gt;'94E8F6DB-106A-44DC-9483-86C801798FF0', aValue=&gt;'VBOpenRef', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{336EAC4A-B37E-4E40-BA4C-79E3FB7ED53E}', aName=&gt;'069956DC-3305-45EF-9331-91CE323B5942', aValue=&gt;'WFDefName', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6B900FDF-AFE6-4453-AF47-541F49808C02}', aName=&gt;'AA4085E6-745B-4A37-8EC4-65D99A653966', aValue=&gt;'VBRemoveSymmetricObjRef', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{6CBB6348-F835-4257-98CB-829B1493E6D3}', aName=&gt;'49A49AE8-DB4B-4329-80FB-801A24C9D7AF', aValue=&gt;'ClearNumerators', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{A13B6FCF-5574-4B4F-9E28-C4EB6F066373}', aName=&gt;'79E6BDEB-91D5-4B2E-81F7-3E091FB65E3A', aValue=&gt;'VBCheckDescrs', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{9F93CE56-5898-4780-B760-FDCA4ED2DAB4}', aName=&gt;'0454D6F0-8624-4887-94B0-64FBC74775E6', aValue=&gt;'SessionVerify', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{D6337625-BC19-4696-B801-AC3C33C07535}', aName=&gt;'5B376AF5-339B-4365-BA80-785E28BCF4DA', aValue=&gt;'VBUpdateSymmetricObjRef', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{C0FE1466-419C-49A0-9F8E-427EDCA46E48}', aName=&gt;'31EC6CF7-8DBD-4EFE-BF12-4D168F653D34', aValue=&gt;'VBApplySecurity', aOptionType=&gt;'METHODNAME');
MTO.Kernel.SysOptions_SAVE ( aSysOptionsid=&gt;'{3EF02C5E-8A51-4A43-9D0C-8E75E00D2F79}', aName=&gt;'79DED4FD-045C-45F8-AC79-2E5A3D956D97', aValue=&gt;'VBMigrateRight', aOptionType=&gt;'METHODNAME');
 --Logout  (acursession=&gt;asession);
end;
">
      <FormData Name="" />
    </BlockHolder>
  </ModuleHolder>
</root>